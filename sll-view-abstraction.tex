\begin{center}
\begin{figure}
\input{sll-lazy-list-shape}
\caption{Example of Fragment Abstraction}
\label{lazylist}
\end{figure}
\end{center}
\section{Fragment Abstraction: Singly Linked Lists}
\label{sec:fragment-abstraction}
In this section, we describe in more detail our fragment abstraction for
concurrent programs that operate on a shared heap.
We consider a program with global variables $\glvarset$ and
thread-local variables $\locvarset$.
We assume that all global variables are pointer variables.
We describe our fragment abstractions for three classes of heap structures:
in the following subsection, we consider programs operating on singly-linked
lists, in Subsection~\ref{subsect:skiplists}, we consider programs operating
on skiplists, and in
Subsection~\ref{subsect:skiplists}, we consider programs operating
arrays of singly linked lists.


%% In the actual verification, we compute a symbolic representation
%% of an invariant that is satisfied by all reachable program configurations (including observer states).
%% This invariant is obtained by an abstract-interpretation-based
%% fixpoint procedure, which starts
%% from a representation of the set of initial configurations, and
%% thereafter repeatedly performs
%% postcondition computations that extend the
%% symbolic representation by the effect of any execution step of the program,
%% until convergence.
%% This analysis needs to deal with the challenges of an unbounded domain of
%% data values, an unbounded number of concurrently executing threads, and an
%% unbounded heap. 

\subsection{Fragment Abstraction for Singly-Linked List-Based Programs}
In this subsection, we describe our symbolic representation, using fragment
abstraction, for programs that operate on singly-linked lists (SLLs). This
representation is also the basis for our representation for programs
operating on skiplists, described in Subsection~\ref{subsect:skiplists}
and programs operating on arrays of SLLs, in Subsection~\ref{subsect:skiplists}.

\bjcom{Say that for now, we ignore timers?}

We assume that we must analyze the product of a program and an observer.
The program operates on a heap, where each cell has exactly one
pointer field, named {\tt next}, and at most one {\tt data} field, which
assumes values from the same domain $\ddomain$ as observer registers.

\bjcom{Introduce notation for the set of local $\ddomain$-variables?.
  Maybe defined which threads we talk about?
  For now, we skip timestamps.
}

We first define our {\em data abstraction}.
For each thread-local variable, and each non-pointer cell field, which ranges
over some concrete domain, we define a corresponding abstract domain,
as follows.
\begin{itemize}
\item For small concrete domains (including that of the program counter),
  the abstract domain is the same as the concrete one.
\item
  For locks variables and lock fields, the abstract domain is $\set{\mathit{me},\mathit{other},\mathit{free}}$.
\bjcom{Should we explain?}
\item For the concrete domain $\ddomain$ of data values, the abstract domain
  is the set of mappings from local variables ranging over $\ddomain$ and
  observer registers to the set $\set{<,=,>}$.
  An element in the abstract domain represents a concrete data value $\tt d$
  if
    it maps each local variable and observer register with value $\tt d'$
    to a set which includes a relation
    $\sim$ such that $\tt d \sim \tt d'$.
\end{itemize}
Define a {\em local symbolic configuration} as a mapping from local
variables (including the program counter) to their corresponding abstract
domains.
We use $\conf \satlocsymbconf{\thread} \locsymbconf$ to denote that in the
global configuration $\conf$, the
local configuration of thread $\thread$ satisfies the local symbolic
configuration $\locsymbconf$, defined in the natural way.

As partial motivation for the definition of tags, we
observe that in order to verify ordering properties represented by the
observer, e.g., that data elements are popped in LIFO order, it is necessary to
track the relative positions of heap cells whose {\tt data} field has the same
value as some observer register. Thus,   in a given configuration,
for an observer register $\reg_i$,  define a
{\em $\reg_i$-cell} to be a heap cell whose
${\tt data}$ has the same value as $\reg_i$.
\bjcom{Move this paragraph?}

Next, define a {\em tag} as a tuple
$\atag = \tagtuple$, where
\begin{itemize}
\item
  $\vals$ is a mapping from non-pointer fields to their corresponding abstract
  domains,
\item
  $\pvars$ is a set of (global or local) pointer variables,
 \item
   $\reachfrom$ and $\reachto$ are sets of global pointer variables and observer registers, and
  \item $\private$ is a boolean value.
\end{itemize}
Assume some global configuration $\conf$.
We say that a heap cell $\cell$ be {\em accessible} to a thread $\thread$
%% in a configuration $\conf$
if $\cell$ is reachable (directly or via sequence of
next-pointers) from a global pointer variable or local pointer
variable of $\thread$.
For a cell $\cell$ which is accessible to thread $\thread$, and a tag
$\atag = \tagtuple$, we write $\cell \satfrag{\thread} \atag$ to denote that
\begin{itemize}
\item
  $\vals$ represents the concrete values of the non-pointer fields of $\cell$,
%%   is satisfied in the following sense:
%%   \begin{enumerate}[(i)]
%%     \item
%%       $\vals(\field) = \cellval(\cell,\field)$ for each each non-lock
%%       $\mathbb{F}$-field $\field$,
%%   \item
%%       for each lock field $\field$, we have
%%       $\vals(\field) = \mathit{me}$ if $\thread$ holds the lock,
%%       $\vals(\field) = \mathit{other}$ if some other thread holds the lock, and
%%       $\vals(\field) = \mathit{free}$ if the lock is free,
%%   and
%% \item
%%   for each $\intgrs$-field $\field$ and each
%%   observer register $x  \in \ovarset$ we have that
%%   $\vals(\field)(x)$ is $=$ iff $\cellval(\cell,\field)$ is equal to the value
%%   of $x$.
%% \bjcom{Should we also do that for local data and timestamp variables?}
%%   \end{enumerate}
\item
  $\pvars$ is the set of global pointer variables and
  local pointer variables of $\thread$ that point to $\cell$,
\item
  $\reachfrom$ is the set of
  \begin{inparaenum}[(i)]
  \item global pointer variables
    %% and local pointer variables of $\thread$
    from which $\cell$ is reachable via a (possibly empty)
    sequence of {\tt next} pointers, and
  \item observer registers $\reg_i$ such that $\cell$ is reachable from
    some $\reg_i$-cell.
  \end{inparaenum}
\item
  $\reachto$ is the set of
  \begin{inparaenum}[(i)]
  \item global pointer variables
    %% and local pointer variables of $\thread$
    that point to a cell which is reachable from $\cell$, and
  \item observer registers $\reg_i$ such that some $\reg_i$-cell is reachable
    from $\cell$.
  \end{inparaenum}
\item
  $\private$ is $\true$ if
   $\cell$ has never been published (by assigning a heap pointer-field or global pointer variable) by its creating thread $\thread$.
\end{itemize}


\begin{definition}[SLL-fragment]
\label{def:sll-fragment}
An {\em SLL-fragment} $\frag$ (or just fragment)
is a triple of of form
$\fragtupleat{\frag}$, of form
$\tuple{\inat{\frag},\nullconst}$, or of form
$\tuple{\inat{\frag},\dangconst}$,
where $\inat{\frag}$ and $\outat{\frag}$ are tags,
    and where $\datarelat{\frag}$ is a subset of $\set{<, =, >}$.
\end{definition}

For a cell $\cell$ which is accessible to thread $\thread$, and a fragment
$\frag$ of form $\fragtupleat{\frag}$, we write $\cell \satfrag{\thread}\frag$ to denote that
the ${\tt next}$ field of $\cell$ points to a cell $\cell'$ such that
$\cell \satfrag{\thread} \inat{\frag}$, and
$\cell' \satfrag{\thread} \outat{\frag}$, and
$\cell.\mathtt{data} \sim \cell'.\mathtt{data}$ for some $\sim \in \datarel$.
For a fragment $\frag = \tuple{\inat{\frag},\nullconst}$, let
$\cell \lhd \frag$ denote that
$\cell \lhd \inat{\frag}$ and $\mathtt{next}(\cell) = \nullconst$.
Define $\cell \lhd \frag$ for $\frag$ of form $\tuple{\inat{\frag},\dangconst}$
analogously.
%% For $\tuple{\inat{\frag},\dangconst}$, the definition is adapted in the obvious way.

Let $\fragset$ be a set of fragments.
A global configuration satisfies a set $\fragset$ of fragments wrp.\ to $\thread$,
denoted  $\conf \satfragset{\thread} \fragset$,
if
for any cell $\cell$ that is accessible to $\thread$, there is a fragment
$\frag \in \fragset$ such that $\cell \satfrag{{\thread}} \frag$.
For a local symbolic  configuration $\locsymbconf$ and set $\fragset$ of
fragments, we write
$\conf \satconf{\thread} \tuple{\locsymbconf,\fragset}$ to denote that
that $\conf \satlocsymbconf{\thread} \locsymbconf$
and $\conf \satfragset{\thread} \fragset$.

%% \begin{itemize}
%% \item
%%   $\pvarsofth{\cell}{\thread} = \pvars$,
%% \item
%%   $\valsofth{\cell}{\thread} = \vals$,
%% \item
%%   $\reachfromofth{\cell}{\thread} = \reachfrom$,
%% \item
%%   $\reachtoofth{\cell}{\thread} = \reachto$,
%%   and
%% \item
%%   if $\private$ is true then $\cell$ is not accessible from any thread other
%%   than $\thread$.
%% \end{itemize}
%% We can now define the notion of fragment.q

%% A {\em symbolic configuration} is a pair
%% $\tuple{\locsymbconf,\fragset}$ consisting of a local symbolic 
%% configuration $\locsymbconf$, and a set $\fragset$ of fragments.
%% A configuration $\conf$ of a program satisfies a symbolic configuration
%% $\tuple{\locsymbconf,\fragset}$ if for each thread $\thread$,
%% \begin{itemize}
%% \item the local configuration of $\thread$ satisfies $\locsymbconf$, in the
%%   natural way, and
%% \item for each $\cell$ that is accessible from $\thread$, there is
%%   a fragment $\frag$ such that $\cell \lhd_{\thread} \frag$.
%% \end{itemize}
A {\em symbolic representation} $\symbrep$ is a mapping from
local symbolic  configurations to sets of fragments.
A configuration $\conf$ of a program satisfies a symbolic representation
if for each thread $\thread$, 
the domain of $\symbrep$ contains a local symbolic configuration
$\locsymbconf$ such that $\conf \satconf{\thread}
\tuple{\locsymbconf,\symbrep(\locsymbconf)}$.

\todo[inline]{Skip the following example. Do we need one?}
\paragraph{Example:} Let us show an example of how a singly linked list (SLL) is split into a set of fragments. Fig.~\ref{lazylist}(a) shows an example of a concrete shape of a singly linked list. Each cell contains the values of $\tt val$, $\tt mark$, and $\tt lock$ from top to bottom, where \tick \; denotes $\tt true$, and \cross \; denotes $\tt false$ (or $\tt free$ for $\tt lock$) and the value of $\tt val$ is denoted by a pair of the observer register $\tt z$ and a subset of $\set{<, =, >}$. There are two threads $1$ and $2$ with two local variables $\tt c_1$ and $\tt c_2$. There are two global variables $\tt H$ and $\tt T$ pointing to the head and tail of the list. The observer register $\tt z$ has value 8. Fig.~\ref{lazylist}(b) shows the result of splitting the list in Fig.~\ref{lazylist}(a) into fragments where each heap fragment is a small list of two nodes. Fig.~\ref{lazylist}(c) shows the abstraction of fragments in Fig.~\ref{lazylist}(b) where for each cell $\cell$, the value of $val$ is abstracted to a subset in $\tt \{<z, =z, >z\}$, the reachability relation between $\cell$ and global variables and observer registers is abstracted to the predicate $\tt X \mapsto \tt Y$ where $\tt X$, $\tt Y$ are sets of global variables and observer registers, $\tt i$ or $\tt o$ states that $\cell$ is an input or output cell.

\subsubsection{Computing Postconditions}
\label{subsect:postcond}
In the  verification, we must compute a symbolic representation
that is satisfied by all reachable program configurations.
%% (including observer states).
This invariant is obtained by an abstract-interpretation-based
fixpoint procedure, which starts
from a representation of the set of initial configurations, and
thereafter repeatedly performs
postcondition computations that extend the
symbolic representation by the effect of any execution step of the program,
until convergence.
In this subsection, we describe the symbolic postcondition computation, which
is the key step in this procedure.
%% \bjcom{The following should be included more smoothly, if really needed}
%% Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$.

%% Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
  
%% $\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. 

%% We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments, and any heap is ``broken down into pre-defined fragments''. A fragment retains the information about a particular part of a heap. This choice of fragments defines the level of abstraction that transforms heap into fragments. The abstract function $\alpha_k$ maps a heap into a set of fragments. Whereas, the concretization function $\gamma_k$ inputs a set of fragments, and returns the set of heaps that can be reconstructed from these fragments. 

%% \paragraph{Fragment Definition:} A heap fragment of size $\tt k$ is represented as \begin{center}
%% 	${\tt v} = \viewconf$ where 
%% \end{center} 

%We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments parameterized by a constant $\tt k$, and any heap is “broken down into pieces” of size (at most) k, called fragments. A fragment retains the information about $\tt k$ connected cells from a heap and abstracts away the other cells. This choice defines the level of abstraction that transforms heap into fragments.There is a certain freedom in what information to retain and what to abstract away. The abstract function $\alpha_k$ maps a heap into a set of heap fragments of sizes $\tt k$. The concretization function $\gamma_k$ inputs a set of heap fragments, and returns the set of heaps that can be reconstructed from the these fragments. Let us represent symbolic representations of heap fragments. A heap fragment of size $\tt k$ is represented as ${\tt \Omega} = \viewconf$ where 

%\paragraph{Abstract Configuration}:
%A abstract {\it configuration} of a program $\prog$ in the fragment of a single thread $\thread$
% is a tuple
%$\tuple{\tt c,\lambda, \Omega , S}$ where
%\begin{itemize}
%\item $\tt c$ is an observer configuration, 
%\item $\lambda$ is the label of the program statement, 
%\item $\tt \Omega$ is a tuple $\tt \tuple{\Omega_p, \Omega_l, Val}$ where $\tt \Omega_p$ contains a set ordering constrains between pointer variables, $\tt \Omega_l$ contains a set ordering constrains between data local variables and $\tt Val$ maps each data local variable to its value.
%\item $\tt S$ is a set of fragments.
%\end{itemize}
%
%% We use $\confsetof\prog$ to denote the set of configurations

%% In this subsection, we describe how to perform the abstract postcondition computation on our symbolic representation for singly linked lists.
The symbolic postcondition computation must ensure that the symbolic representation
of the reachable configurations of a program is closed under execution of a
statement by some thread.
More precisely, assume that a global configuration $\conf$ satisfies
a symbolic representation $\symbrep$. Let $\thread$ be an arbitrary thread.
Assume that there is
a local symbolic configuration $\locsymbconf \in \domof{\symbrep}$ such that
$\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$.
We must ensure that this property still hols after any execution of a
statement by some thread.
%% it is still the case that
%% $\domof{\symbrep}$ contains a local symbolic configuration 
%% $\locsymbconf'$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf',\symbrep(\locsymbconf)}$
%% for some thread $\thread$.
In the thread-modular approach, we must consider two cases:
\begin{itemize}
\item
  {\it Local Steps:} The thread $\thread$ itself executes some statement,
  which may change its local state and the state of the heap.
  In this case, we compute a local symbolic configuration $\locsymbconf'$ and
  set $\fragset'$ such that the resulting configuration $\conf'$ satisfies
  $\conf' \satconf{\thread} \tuple{\locsymbconf',\fragset'}$, and (if necessary)
  extend $\symbrep$ so that $\locsymbconf' \in \domof{\symbrep}$ and
  $\fragset' \in \symbrep(\locsymbconf')$.
\item
  {\it Interference Steps:} Another thread $\thread_2$, which 
  satisfies a local symbolic configuration $\locsymbconf_2$
  in $\domof{\symbrep}$ with
  $\conf \satconf{\thread_2} \tuple{\locsymbconf_2,\symbrep(\locsymbconf_2)}$
  performs a computation step,  which affects the state of the heap in
  such a way that makes it necessary to extend $\symbrep(\locsymbconf)$.
  We must then compute a set $\fragset'$ of fragments such that
  the resulting configuration $\conf'$ satisfies
  $\conf' \satfragset{\thread} \fragset'$ and 
  make sure that $\fragset' \in \symbrep(\locsymbconf)$.
  To do this, we first combine the the local symbolic configurations
  $\locsymbconf$ and $\locsymbconf_2$ and the sets of fragments
  $\symbrep(\locsymbconf)$ and $\symbrep(\locsymbconf_2)$, using an
%%   of $\thread_1$ and $\thread_2$ and then compute a representation of the
%%   the possible heaps whose projection onto $\thread_i$ satisfies
%%   $\symbrep(\locsymbconf_i)$ for $i=1,2$.
%% This is done by performing an
  operation, called {\em intersection}, into
  a joint local symbolic configuration of $\thread$ and $\thread_2$ and
  a set $\fragset_{1,2}$ of fragments that represents the cells accessible
  to either $\thread$ or $\thread_2$.
  We thereafter symbolically compute the postcondition of the statement
  execution of $\thread_2$, as in the local case, finally project back the
  set of fragments onto $\thread$ in the natural way, to obtain $\fragset'$.
\end{itemize}
In the following, we first describe the symbolic postcondition computation for
local steps, and thereafter the intersection operation.


\paragraph{Symbolic Postcondition Computation for Local Steps}
Let $\thread$ be an arbitrary thread, and assume 
that $\locsymbconf \in \domof{\symbrep}$ with
For each statement that $\thread$ can execute in a configuration $\conf$
with $\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$,
we must compute a local symbolic configuration $\locsymbconf'$ and
a set  $\fragset'$ of fragments such that
such that the resulting configuration $\conf'$ satisfies
  $\conf' \satconf{\thread} \tuple{\locsymbconf',\fragset'}$.
This computation has do be done differently for
each statement. For statements that do not affect the heap or pointer variables,
this computation is standard, and affects only the local symbolic
configuration and data abstraction part of fragments.
We therefore here describe how to compute the effect of statements that update
pointer variables or the heap, since these are the most interesting cases.


The main difficulty in the
postcondition computation is to update the reachability information provided
in the fields $\reachfrom$ and $\reachto$ in each tag of a 
fragment. For instance, considerthat a statement $\gvarof{g} := \lvarof{p}$,
which assigns the value of a local pointer variable $\lvarof{p}$ to a global
pointer variable $\gvarof{g}$.
In the postcondition computation, we must for each fragment
determine how to update the field $\reachfrom$ in its tags, and in particular
whether $\gvarof{g}$ should be in this set after the statement
(the same problem occurs for the set $\reachto$),
If $\lvarof{v}$ would have been a global variable, this information could
be obtained by checking whether $\lvarof{v}$ is in the set before the operation.
However, since the $\reachfrom$ field does not include local variables, we
start the postcondition computation by computing a number of
transitive-closure-like relations between fragments, which will allow
to determine whether $\gvarof{g}$ should be in the $\reachfrom$ field after
the statement with rather good accuracy. Note that if our procedure can not
determine whether $\gvarof{g}$ should be in  a $\reachfrom$ field, then it
generates fragments for both possibilities.

First, we say that two tags
$\atag = \tagtuple$ and $\atag' = \tagtupleprime$ are {\em consistent} if
if there is some concrete valuation of non-pointer fields represented by both
$\vals$ and $\vals'$, and if
$\pvars = \pvars'$, $\reachfrom = \reachfrom'$, $\reachto = \reachto'$, and
$\private = \private'$.
Intuitively, $\atag$ and $\atag'$ are consistent if there can exist a cell
$\cell$ accessible to $\thread$ with $\cell \satfrag{\thread} \atag$
and $\cell \satfrag{\thread} \atag'$.
\todo[inline]{To Quy: Can you really require that the data abstrations must
  be the same?}

Let $\frag_1$ and $\frag_2$ be two fragments in a set $\fragset$ of fragments.
\begin{itemize}
\item  Let $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denote that $\outat{\frag_1}$   and $\inat{\frag_2}$ are consistent.
  %% \todo[inline]{Quy: PLEASE  you provide the precise definition of when
  %%   $\tagat{\outat{\frag_1}}$ and $\tagat{\inat{\frag_2}}$ are consistent?}
  %% \quycom{They are consistent if they have same $\reachfrom$, $\reachto$, $\pvars$, $\private$, $\data$. This is for local thread. When we check for consistent between two tags when doing intersection, we have to define differently.}  
\item  Let $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denote that $\outat{\frag_1} = \outat{\frag_2}$ are consistent, and that either
  $\pvarsat{\inat{\frag_1}} \cap \pvarsat{\inat{\frag_2}} = \emptyset$ or that
  the global variables in  $\reachfromat{\inat{\frag_1}}$ are disjoint from
  those in $\reachfromat{\inat{\frag_2}}$.
\todo[inline]{Question: Is this correct?}
%%   \quycom{$\reachfromat{\inat{\frag_1}} \cap \reachfromat{\inat{\frag_2}} = \emptyset$ here is not correct, we only need the global variables of reachfrom and reachto in this case}
%% \quycom{In my definition, the consistent here is defined for two views in the same threads. With the view from other thread, I use the notion of intersection.}
\end{itemize}
Intuitively, $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denotes that it is
possible that  $\mathtt{next}(\cell_1) = \cell_2$ for some cells with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Intuitively, $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denotes that it is
possible that
  $\mathtt{next}(\cell_1) = \mathtt{next}(\cell_2)$.
for different cells  $\cell_1$ and $\cell_2$ with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Note that the above definitions also work for the cases that the output tag is
$\nullconst$ or $\dangconst$.

We use the above relations to define several derived relations:
%% \bjcom{We could use a common pattern for these and save space in definitions.}
\begin{itemize}
\item Let $\overset{+}\hookrightarrow_{\fragset}$ denote the transitive closure of
  $\hookrightarrow_{\fragset}$, and
   $\overset{*}\hookrightarrow_{\fragset}$ the reflexive transitive closure of
$\hookrightarrow_{\fragset}$.
\item Let $\frag_1  \overset{**}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1',\frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{*}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{*+}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1', \frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{*}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{*\circ}\leftrightarrow_{\fragset}  \frag_2$ denote that is a
  $\frag_1' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2$ such that
  $\frag_1  \overset{*}\hookrightarrow_{\fragset} \frag_1'$.
\item Let $\frag_1  \overset{++}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1',\frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{+}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{+*}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1', \frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{+}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{+\circ}\leftrightarrow_{\fragset}  \frag_2$ denote that is a
  $\frag_1' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2$ such that
  $\frag_1  \overset{+}\hookrightarrow_{\fragset} \frag_1'$.
\end{itemize}
We say that $\frag_1$ and $\frag_2$ are {\em compatible} if $\frag_x \overset{*}\hookrightarrow \frag_y$ or $\frag_y \overset{*}\hookrightarrow \frag_x$ or $\frag_x \overset{**}\leftrightarrow \frag_y$. Intuitively, this means that $\frag_1$ and
$\frag_2$ can be satisfied by two cells in the same heap state.
\input viewrelations
Figure~\ref{fig:viewrelations} illustrates the above relations for a heap state
with $13$ heap cells. The figure shoes 4 fragments that are satisfied heap
cells, as denoted by green boxes, and how the relationship between heap cells
is reflect by relations between the corresponding fragments.

We can now describe how to perform the symbolic postcondition computations for
statements that assign to a pointer variable.
Consider a statement of form
${\tt x := y}$, where $\mathtt{x}$ and $\mathtt{y}$ are global or local
(to thread $\thread$) pointer variables.
  The transformer is computed as follows: For each fragment $\frag_y \in S$ such that $\mathtt{y} \in \pvarsat{\inat{\frag_y}}$, 
create $\frag'$ which is the same as $\frag_y$, except that

%% Let $\tt kill(x,v)$ be the procedure to remove $\tt x$ if it exists from
%% $\reachfromat{\inat{\frag}}$,
%% $\reachfromat{\outat{\frag}}$,
%% $\reachtoat{\inat{\frag}}$,
%% $\reachtoat{\outat{\frag}}$,
%% $\pvarsat{\inat{\frag}}$, and
%% $\pvarsat{\outat{\frag}}$.
\begin{description}
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag_y}} \cup \set{x}$ and
  $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$
\end{itemize}
and furthermore, if $\gvarof{x}$ is a global variable, then
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ and
$\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ and
$\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$.
\end{itemize}
and add $\frag'$ to $\tt S_{post}$.
Thereafter, we must ensure that any cell $\cell$ which is accessible to $\thread$
satisfies some fragement in $\fragset_{post}$. The cell $\cell$ satisfies some
fragment in $\fragset$, and must be in some reachability relationship to
the cell pointed to by $\gvarof{y}$. We make a case analysis on the possible
relationships:
\begin{enumerate}
\item 
\item  for each fragment $\frag$ where $\frag \hookrightarrow_{\fragset} \frag_y$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \overset{*o}\leftrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\end{enumerate}
\item[${\tt x := y.next}$]: The local abstract transformer is quite similar to the previous case with some slight differences. For each fragment $\frag_y \in S$ where $\gvarof{y} \in \pvarsat{\inat{\frag_y}}$, first
create $\frag'$ which is same as $\frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$. Thereafter, we perform a case analysis on
the relationship between the view that $\cell$ satisfies and $\frag_y$:
\begin{enumerate}
\item  for each fragment $\frag$ where $\frag \overset{*}\hookrightarrow_{\fragset} \frag_y$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \hookrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ then
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \cup \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \leftrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize} 
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,

\item for each fragment $\frag$ where $\frag_y \overset{+}\hookrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \overset{*o}\leftrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$, create $\frag'$ which is same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \{x\{$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\item for each fragment $\frag$ where $\frag \overset{+\circ}\leftrightarrow_{\fragset} \frag_y$, create $\frag'$ which is same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\frag'$ to $\tt S_{post}$,
\end{enumerate}	
\item[${\tt x.next:= y}$]
  This is the most difficult statement, since it is a destructive update of the heap. For each pair of fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inat{\frag_x}}$, $\tt y \in \pvarsat{\inat{\frag_y}}$, and
  $\frag_x$ and $\frag_y$ are compatible,
let $\frag_{new}$ be a new fragment of size 2 where $\tagat{\inat{\frag_{new}}} = \tagat{\inat{\frag_x}}$ and $\tagat{\outat{\frag_{new}}} = \tagat{\inat{\frag_y}}$ except that $\reachfromat{\outat{\frag_{new}}} = \reachfromat{\inat{\frag_y}} \cup \reachfromat{\inat{\frag_x}}$,
and add $\frag_{new}$ to $\fragset_{post}$.
\todo[inline]{Question to Quy: How is $\datarelat{\frag_{new}}$ defined?}\quycom{we fixed this in the disscussion}
Thereafter, we add all possible fragments that can result from a transformation
of some fragment $\frag$ which is in $\frag$. This is done by an exhaustive
case analysis on the relationship between $\frag$, $\frag_x$ and $\frag_y$:
\begin{enumerate}
\item  for each fragment $\frag \in \fragset$ where $\frag \overset{*}\hookrightarrow_{\fragset} \frag_x$, we do as follows: For each subset $\regset$ of observer registers in $\reachtoat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$
\begin{itemize}
\item create a fragment $\frag'$ which is the same as $\frag$, except that
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = (\reachtoat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}} \cup \reachtoat{\inat{\frag_y}} \cup \regset$.
\item $\reachtoat{\outat{\frag'}} = (\reachtoat{\outat{\frag}} \cap \reachfromat{\inat{\frag_x}} \cup \reachtoat{\inat{\frag_y}} \cup \regset$.
\end{itemize}
and add $\frag'$ to $\fragset_{post}$
\end{itemize}
\todo[inline]{Question to Quy: Can you add an explanation in text of why this is
  correct, is not at all obvious?}

\item for each fragment $\frag \in \fragset$ where $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$ or $\frag_y = \frag$,
  \bjcom{Question to Quy: Isn't $\frag_y = \frag$ included in $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$?} \quycom{yes, they are different}
  \bjcom{You did not quite answer the question: The question was whether it is
    possible to replace: ($\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$ or $\frag_y = \frag$) by  ($\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$)?}
\begin{itemize}
	\item create  $\frag'$ which is same as $\frag$ except that
\begin{itemize}
 \item $\tt \reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\inat{\frag}}$, 
\item $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
\end{itemize}
\item add $\frag'$ to $\fragset_{post}$
\end{itemize}
\item for each fragment $\frag$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} \frag$ and either $\frag \hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*\circ}\leftrightarrow_{\fragset} \frag$, 
\begin{itemize}
\item  create $\frag'$ which is same as $\frag$ except that $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
 \item add $\frag'$ to $\fragset_{post}$ 
\end{itemize}


\item for each fragment $\frag$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} \frag$ and either $\frag \hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*\circ}\leftrightarrow_{\fragset} \frag$,  
\begin{itemize}
\item create $\frag'$ which is same as $\frag$ then except that $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
\item for each subset $\regset$ of observer registers in $\reachfromat{\inat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$
\begin{itemize}
\item create $\frag''$ which is same as $\frag'$, except that $\reachfromat{\inat{\frag''}} = (\reachfromat{\inat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$.
\item add $\frag''$ to $\fragset_{post}$
\end{itemize}
\end{itemize}

\item for each fragment $\frag$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} \frag$ and either $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\frag \overset{*+}\leftrightarrow_{\fragset} \frag_y$, 
\begin{itemize}
\item create $\frag'$ which is same as $\frag$
\item  add $\frag'$ to $\fragset_{post}$
\end{itemize}

\item for each fragment $\frag$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} \frag$ and either $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*+}\leftrightarrow \frag$, then for each subset $\regset$ of observer registers in $\tt \reachfromat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$, 
\begin{itemize}
\item create $\frag'$ which is same as $\frag$, except that $\reachfromat{\inat{\frag'}} = (\tt \reachfromat{\inat{\frag}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$. 
 \item for each set $\regset'$ of observer registers in $\reachfromat{\outat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$,  
\begin{itemize}
\item create $\frag''$ which is same as $\frag'$, except that $\frag''.o.reachfrom = (\reachfromat{\outat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset'$. 
\item add $\frag''$ to $\fragset_{post}$
\end{itemize}
\end{itemize}
\end{enumerate}

\end{description}

\paragraph{Fragment Intersection:} 
Let us now describe how to form the intersection of two sets of fragments
$\fragset_1$ and $\fragset_2$, where $\fragset_i$ characterizes the projection of the heap onto thread $\thread_i$ for $i=1,2$. In order to distinguish
between local variables of $\thread_1$ and $\thread_2$, we assume that local variable $\lvarof{x}$ in $\thread_i$ is named as $\lvarof{x[i]}$.
Let $\fragset$ denote the result of intersecting $\fragset_1$ and $\fragset_2$.
Then, for each heap cell $\cell$, which is
accessible to either $\thread_1$ or $\thread_2$, the set $\fragset$ must
contain a fragment $\frag$ with $\cell \satfrag{1,2} \frag$.
\bjcom{This notation to be defined}
There are  here two possibilities.
\begin{itemize}
\item If $\cell$ is accessible to both $\thread_1$ and $\thread_2$, then
  there are fragments $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$
  such that $\cell \satfrag{1} \frag_1$ and $\cell \satfrag{2} \frag_2$.
  We use the notation $\frag_1 \sqcap \frag_2$ to denote a set of views such that
  whenever $\cell \satfrag{1} \frag_1$ and $\cell \satfrag{2} \frag_2$ then
  $\cell \satfrag{1,2} \frag$ for some $\frag \in (\frag_1 \sqcap \frag_2)$.
\item If $\cell$ is accessible to only one of $\thread_1$ and $\thread_2$,
  say $\thread_1$, then $\fragset$ should contain some fragment
  $\frag_1 \in \fragset_1$ with $\cell \satfrag{1,2} \frag_1$
  \bjcom{Check that we need not change $\frag_1$}
\end{itemize}
For a fragment $\frag$, define
$\greachfromat{\inat{\frag}}$ as the set of global variables in
$\reachfromat{\inat{\frag}}$. Define
$\greachtoat{\inat{\frag}}$,
$\greachfromat{\outat{\frag}}$,
$\greachtoat{\outat{\frag}}$,
$\gpvarsat{\inat{\frag}}$, and
$\gpvarsat{\outat{\frag}}$
analogously.
Define $\gtagat{\outat{\frag}}$ as the tuple
$\tuple{\gpvarsat{\outat{\frag}},\valsat{\outat{\frag}},\greachfromat{\outat{\frag}},\greachtoat{\outat{\frag}},\privateat{\outat{\frag}}}$.

\todo[inline]{Question to Quy: You have also used the notation
  $\gvalsat{\inat{\frag}}$. Will you need it, and if so what does it mean?} \quycom{Because in the data, I add data constraint between data fields and local data variable. When we do intersection, we do not need to care about this constraint because its local constraint}

Let us now describe how to compute  $\frag_1 \sqcap \frag_2$ for
two views $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$.
Firstly, we consider the case where both $\frag_1$ and $\frag_2$ have size 2.
Let us consider some different cases.
They all take into account the  observation that if a cell $\cell$ satisfies
$\cell \satfrag{1} \frag_1$ and $\cell \satfrag{2} \frag_2$, then
the information about global variables in $\frag_1$ and $\frag_2$ must coincide.
 \begin{itemize}
 \item if $\greachfromat{\inat{\frag_1}} \neq \emptyset$ and $\greachfromat{\inat{\frag_2}} \neq \emptyset$ then the global information in $\frag_1$ and $\frag_2$ must coincide. We hence obtain:
  \begin{itemize}
  \item if $\gtagat{\inat{\frag_1}} = \gtagat{\inat{\frag_2}}$ and $\gtagat{\outat{\frag_1}} = \gtagat{\outat{\frag_2}}$ then $\frag_1 \sqcap v_2 = \set{\frag_{12}}$ where $\frag_{12}$ is identical to $\frag_1$ except that 
  \begin{itemize}
  \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$ 
  \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$
   \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
     \todo[inline]{Question to Quy: Why do this union only for $\pvars$ and $\reachfrom$, and not for $\reachto$ and $\vals$?}\quycom{we fixed this in the disscussion}
    \end{itemize}
  \todo[inline]{Question to Quy: Should we not have an ``else'' here, with
    $\frag_1 \sqcap \frag_2 = \emptyset$?}\quycom{we fixed this in the disscussion}
 \end{itemize}

 \item if $\greachfromat{\inat{\frag_1}} = \emptyset$, $\greachfromat{\inat{\frag_2}} = \emptyset$, $\greachfromat{\outat{\frag_1}} \neq \emptyset$ and $\greachfromat{\outat{\frag_2}} \neq \emptyset$ then 
  \begin{itemize}
  \item if $\gtagat{\outat{\frag_1}} = \gtagat{\outat{\frag_2}}$, $\privateat{\inat{\frag_1}} = \false$ and $\privateat{\inat{\frag_2}} = \false$ then $\frag_1 \sqcap \frag_2 = \set{\frag_1', \frag_2', \frag_{12}}$ where
      %$\frag_{12}$ is same as $\frag_1$ except that 
%    \begin{itemize}
%  \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$ 
%  \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
%  \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$
%   \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
%    \end{itemize} and
      \begin{itemize}
      \item
        $\frag_1'$ is same as $\frag_1$ except that 
    \begin{itemize}
  \item  $\pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\reachfromat{\outat{\frag_1'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
    \end{itemize}
  \item
    $\frag_2'$ is same as $\frag_2$ except that 
    \begin{itemize}
  \item  $\pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\reachfromat{\outat{\frag_2'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
    \end{itemize}
  \item
    $\frag_{12}$ is as in the previous case.
    \bjcom{to Quy: I added this, is it correct?}
      \end{itemize}
    \item if $\gtagat{\outat{\frag_1}} = \gtagat{\outat{\frag_2}}$ and $\privateat{\inat{\frag_1}} = \true$ or $\privateat{\inat{\frag_2}} = \true$ then $\frag_1 \sqcap \frag_2 = \set{\frag_1', \frag_2'}$ where
$\frag_1'$ and $\frag_2'$ are as above.
 \end{itemize}
 
 \item if $\greachfromat{\inat{\frag_1}} = \emptyset$, $\greachfromat{\inat{\frag_2}} = \emptyset$, $\greachfromat{\outat{\frag_1}} = \emptyset$ and $\greachfromat{\outat{\frag_2}} = \emptyset$ then 
 \begin{itemize}
 \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\privateat{\inat{\frag_1}} = false$, $\privateat{\outat{\frag_1}} = false$, $\privateat{\outat{\frag_1}} = false$ and $\privateat{\outat{\frag_2}} = false$ then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2',\frag_{12}\}$ %where $\frag_{12}$ is same as $\frag_1$ except that 
   % \begin{itemize}
 % \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$ 
 % \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
 % \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$
 %  \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
 %   \end{itemize} and 
 %   $\frag_{1'}$ is same as $\frag_1$ except that 
 %   \begin{itemize}
 % \item  $\pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \frag_2.vars(j_o)$
 % \item $\reachfromat{\outat{\frag_1'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
 %   \end{itemize}
 %  and $\frag_2'$ is same as $\frag_2$ except that 
 %   \begin{itemize}
 % \item  $\pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \frag_2.vars(j_o)$
 % \item $\reachfromat{\outat{\frag_2'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
 %   \end{itemize}
    
    
   \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, ($\privateat{\inat{\frag_1}} = true$ or $\privateat{\inat{\frag_2}} = true$) and $\privateat{\outat{\frag_1}} = false$ and $\privateat{\outat{\frag_2}} = false$ then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2'\}$  

  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\privateat{\outat{\frag_1}} = true$ or $\privateat{\outat{\frag_1}} = true$) then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$ 

    \item if $\tt gtag(\frag_1, o) \neq gtag(\frag_2, o)$ then $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$
 \end{itemize}
 
 \end{itemize}


 \section{Fragment Abstraction for  Skip-Lists}

 \todo[inline]{Here goes a description of the fragment abstraction for
   skip lists}
   \begin{itemize}
  \item In the fragment abstraction, $\tt tag$ is define exactly same as $\tt tag$ in SLL abstraction where $\reachfrom$ and $\reachto$ is defined based on the main level of skip-list. It means that we do not keep the reachability information in higher levels.
  \item Same as timestamp stacks and queues, in skip-list we keep the main level and abstract all the higher levels. It means that we do not distinguish the differences between high levels. Hence, we have two types of fragments including main level fragments and higher level fragments which are defined same as SLL fragments. 
   \end{itemize}
 \begin{figure}  
 \input skiplistshape  
 \caption{A concrete shape of 3-level skipl-list with two threads}
\end{figure}

 \begin{figure}  
 \input skiplistabs 
 \caption{skipl-list fragments \quycom{i am working with this figure}}
\end{figure}
\subsection{Abstract transformers for skip-lists}
Let us show how to perform the abstract transformer for skip-list programs on the set of fragments $\fragset$ depending on the particular statement.  We consider fragments of size $2$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \{{o}\}$, and $\tt next(i) = {o}$ and fragments of size $1$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \emptyset$, and $\tt next(i) = null$ or $\tt next(i) = \bot$. For each fragment $\tt v$, let $\tt v.level \in \{1,2\}$ be the level of $\tt v$.

\paragraph{Local Abstract Transformers:} First, let us show the abstract transformer on the set of fragment $\fragset$ in the fragment of the concurrent thread. Let $\fragset_1$ be set of fragments of level 1 in $\fragset$, $\fragset_2$ be set of fragments of level 2 in $\fragset$. For each program statement, let $\fragset_{post}$ be the set of fragments after executing the statement. Let $\fragset_{post}$ be initialized as the empty set.  Let $\tt R$ be the set of pairs of fragments. Intuitively, in each element in $\tt R$, the second fragment is the transformation of the first fragment. Let $\tt R$ be initialized as the empty set.
\begin{itemize}
\item ${\tt x := y}$: The transformer is performed as follows:  For each fragment $\tt \frag_y \in \fragset_1$ where $\tt y \in\pvarsat{\inat{ \frag_y}}$, 
%\begin{itemize}
\begin{enumerate}
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item for each fragment $\tt v$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*\circ}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item create $\tt v'$ which is same as $\tt \frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \cup \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
%\item for each fragment $\tt v'$ in $\fragset_{post}$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
\item for each fragment $\tt v \in \fragset_2$ we do as follows. For each $\tt (\frag_1,\frag_1')$, $\tt (\frag_2,\frag_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, and $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \frag_1'.i_1.vars$,
\item $\pvarsat{\outat{\frag'}} = \frag_2'.i_2.vars$,

\item $\reachfromat{\inat{\frag'}} = \frag_1'.i_1.reachfrom$,
\item $\reachfromat{\outat{\frag'}} = \frag_2'.i_2.reachfrom$,
\item $\reachtoat{\inat{\frag'}} = \frag_1'.i_1.reachto$,
\item $\reachtoat{\outat{\frag'}} = \frag_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\fragset_{post}$. 
\end{enumerate}
%\item If there does not exist such $\tt \frag_y$ in $\fragset_1$
%\end{itemize}
%\begin{enumerate}
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%%\begin{itemize}
%%\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
%%\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
%%\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
%% \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
%%\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\fragset_{post}$,
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%%\begin{itemize}
%%\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
%%\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
%%\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
%% \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
%%\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\fragset_{post}$,
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$ 
%\end{itemize}
%
%%4%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%5%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%6%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%7%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%8%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%9%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%10%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%11%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%12%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%\end{enumerate}
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X := Y.NEXT1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item ${\tt x := y.next1}$: The local abstract transformer is quite similar to the previous case with slightly differences. For each fragment $\tt \frag_y \in S$ where $\tt y \in {\tt vars}(\tt i)$,
%\begin{enumerate}
%
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%\end{itemize}
%
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{+}\hookrightarrow_{\fragset} \frag_1$ 
%\end{itemize}
%
%%-------------------------------------------4------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%-------------------------------------------5------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-------------------------------------------6------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%-------------------------------------------7-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%------------------------------------------8-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-----------------------------------------9-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%-----------------------------------------10-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%-----------------------------------------11-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$  where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-----------------------------------------12-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1y\overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%\end{enumerate}




\begin{enumerate}
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{*}\hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ then
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \cup \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize} 
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$

\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{+}\hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*\circ}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \{x\{$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ ,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{+\circ}\leftrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$

\item create $\tt v'$ which is same as $\tt \frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
%\item for each fragment $\tt v'$ in $\fragset_o$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
%

\item for each fragment $\tt v \in \fragset_2$ we do as follows. For each $\tt (\frag_1,\frag_1')$, $\tt (\frag_2,\frag_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, and $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \frag_1'.i_1.vars$,
\item $\pvarsat{\outat{\frag'}} = \frag_2'.i_2.vars$,

\item $\reachfromat{\inat{\frag'}} = \frag_1'.i_1.reachfrom$,
\item $\reachfromat{\outat{\frag'}} = \frag_2'.i_2.reachfrom$,
\item $\reachtoat{\inat{\frag'}} = \frag_1'.i_1.reachto$,
\item $\reachtoat{\outat{\frag'}} = \frag_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\fragset_{post}$. 
\end{enumerate}	




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X.NEXT1 := Y %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item  ${\tt x.next1:= y}$: The local abstract transformer is performed by several steps as follows: For each pair of fragments $\frag_x$, $\tt \frag_y$ in $\fragset_1$ where $\tt x \pvarsat{\inat{\in \frag_x}}$, $\tt y \in\pvarsat{\inat{ \frag_y}}$, and $\frag_x \overset{*}\hookrightarrow \frag_y$ or $\tt \frag_y \overset{*}\hookrightarrow \frag_x$ or $\frag_x \overset{**}\leftrightarrow \frag_y$, let $\tt R_1$, $\tt R_2$, $\tt R_3$, $\tt R_4$, $\tt R_5$, $\tt R_6$ be initialized as $\tt R$,  
\begin{enumerate}
\item let $\tt \frag_{new}$ be the fragment of size 2 and of level 1 where $\tt tag(\frag_{new},i) = tag(\frag_x, i)$ and $\tt tag(\frag_{new},o) = tag(\frag_y,i)$ except that $\tt \reachfromat{\outat{\frag_{new}}} = \reachfromat{\inat{\frag_y}} \cup \reachfromat{\inat{\frag_x}}$,
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{*}\hookrightarrow_{\fragset} \frag_x$, we do as follows: For each subset $\regset$ of observer registers in $\reachtoat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$


\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = (\tt \reachtoat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}) \cup \reachto{\inat{\frag_y}} \cup \regset$.
\item $\reachtoat{\outat{\frag'}} = (\tt \reachtoat{\outat{\frag}} \cap \reachfromat{\inat{\frag_x}}) \cup \reachto{\inat{\frag_y}} \cup \regset$.
\end{itemize}
\item add $\tt v'$ to $\fragset_{post}$ 
\item add $\tt (v,v')$ to $\tt R_1$
\end{itemize}

\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} v$ or $\tt \frag_y = v$, 
\begin{itemize}
	\item create  $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
 \item $\tt \reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\inat{\frag}}$, 
\item $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
\end{itemize}
\item add $\tt v'$ to $\fragset_{post}$,
\item add $\tt (v,v')$ to $\tt R_2$
\end{itemize}
\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} v$ and either $\tt v \hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*o}\leftrightarrow_{\fragset} v$, 
\begin{itemize}
\item  create $\tt v'$ which is same as $\tt v$ except that $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
 \item add $\tt v'$ to $\fragset_{post}$, 
 \item add $\tt (v,v')$ to $\tt R_3$

\end{itemize}


\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} v$ and either $\tt v \hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*o}\leftrightarrow_{\fragset} v$,  
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$ then except that $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
\item for each subset $\regset$ of observer registers in $\reachfromat{\inat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\reachfromat{\inat{\frag''}} = (\reachfromat{\inat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$.
\item add $\tt v''$ to $\fragset_{post}$,
\item add $\tt (v,v'')$ to $\tt R_4$
\end{itemize}
\end{itemize}

\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} v$ and either $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\tt v \overset{*+}\leftrightarrow_{\fragset} \frag_y$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$
\item  add $\tt v'$ to $\fragset_{post}$,
\item add $\tt (v,v')$ to $\tt R_5$

\end{itemize}


\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} v$ and either $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*+}\leftrightarrow v$, then for each subset $\regset$ of observer registers in $\tt \reachfromat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that $\reachfromat{\inat{\frag'}} = (\tt \reachfromat{\inat{\frag}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$. 
 \item for each set $\regset'$ of observer registers in $\reachfromat{\outat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$,  
\begin{itemize}
\item create $\frag''$ which is same as $\frag'$, except that $\reachfromat{\outat{\frag''}} = (\reachfromat{\outat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset'$. 
\item add $\frag''$ to $\fragset_{post}$
\item add $\tt (v,v'')$ to $\tt R_6$
\end{itemize}
\end{itemize}
\item add $\tt \frag_{new}$ to $\fragset_{post}$ 
\end{enumerate}

\item for each fragment $\frag \in \fragset_2$ then we do as follows. for each $\tt (\frag_1,\frag_1') \in R_i$, $\tt (\frag_2,\frag_2') \in R_j$ where $\tt i \neq j$ and $\tt 1 \leq i,j \leq 6$. For each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\frag'$ which is same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \frag_1'.i_1.vars$,
\item $\pvarsat{\outat{\frag'}} = \frag_2'.i_2.vars$,

\item $\reachfromat{\inat{\frag'}} = \frag_1'.i_1.reachfrom$,
\item $\reachfromat{\outat{\frag'}} = \frag_2'.i_2.reachfrom$,
\item $\reachtoat{\inat{\frag'}} = \frag_1'.i_1.reachto$,
\item $\reachtoat{\outat{\frag'}} = \frag_2'.i_2.reachto$,
\end{itemize} then add $\frag'$ to $\fragset_{post}$. 


\newpage
 \end{itemize}
 
 \paragraph{Fragment Intersection:} Let us describe the intersection of two fragments $\tt \frag_1 \in \fragset_1$ and $\tt \frag_2 \in \fragset_2$ denoted as $\tt \frag_1 \sqcap \frag_2$. Firstly, we consider the case where both $\tt \frag_1$ and $\tt \frag_2$ have size 2.
 \begin{itemize}
 \item if $\tt \frag_1.greachfrom(i,\{1,2\}) \neq \emptyset$ and $\tt \frag_2.greachfrom(i,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(\frag_1, i) = gtag(\frag_2, i)$ and $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_{12}\}$ where $\tt \frag_{12}$ is same as $\tt \frag_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$ 
  \begin{itemize}
  \item $\tt \frag_{12}.vars(i) = \frag_1.vars(i) \cup \frag_2.vars(i)$ 
  \item  $\tt \pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_{12}.reachfrom(i,l) = \frag_{1}.reachfrom(i,l) \cup \frag_{2}.reachfrom(i,l)$
   \item $\tt \frag_{12}.reachfrom(i,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
 \end{itemize}

 \item if $\tt \frag_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_1.greachfrom(o,\{1,2\}) \neq \emptyset$ and $\tt \frag_2.greachfrom(o,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\tt \frag_1.private(i) = false$ and $\tt \frag_2.private(i) = false$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1', \frag_2', \frag_{12}\}$ where %$\tt \frag_{12}$ is same as $\tt \frag_1$ except that 
  $\tt \frag_1'$ is same as $\tt \frag_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$
    \begin{itemize}
  \item  $\tt \pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_1'.reachfrom(o,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
   and $\tt \frag_2'$ is same as $\tt \frag_2$ except that 
    \begin{itemize}
  \item  $\tt \pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_2'.reachfrom(o,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
     \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\tt \frag_1.private(i) = true$ or $\tt \frag_2.private(i) = true$) then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1', \frag_2'\}$ 
 \end{itemize}
 
 
  \item if $\tt \frag_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_1.greachfrom(o,\{1,2\}) = \emptyset$ and $\tt \frag_2.greachfrom(o,\{1,2\}) = \emptyset$ then 
 \begin{itemize}
 
 
 \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\tt \frag_1.private(i) = false$, $\tt \privateat{\outat{\frag_1}} = false$, $\tt \privateat{\outat{\frag_1}} = false$ and $\tt \privateat{\outat{\frag_2}} = false$ then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2',\frag_{12}\}$ %where $\tt \frag_{12}$ is same as $\tt \frag_1$ except that 
    \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, ($\tt \frag_1.private(i) = true$ or $\tt \frag_2.private(i) = true$) and $\tt \privateat{\outat{\frag_1}} = false$ and $\tt \privateat{\outat{\frag_2}} = false$ then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2'\}$  

  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\tt \privateat{\outat{\frag_1}} = true$ or $\tt \privateat{\outat{\frag_1}} = true$) then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$ 

    \item if $\tt gtag(\frag_1, o) \neq gtag(\frag_2, o)$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$
 \end{itemize}
 
 \end{itemize}



%
