%% \begin{center}
%% \begin{figure}
%% \input{sll-lazy-list-shape}
%% \caption{Example of Fragment Abstraction}
%% \label{lazylist}
%% \end{figure}
%% \end{center}
\section{Fragment Abstraction for Skiplists}
\label{sec:fragment-abstraction}
In the previous section, we reduced the problem of verifying linearizability
to the problem of verifying
that, in any execution of the cross-product of a program and an observer, 
the observer cannot reach an accepting state.
We perform this verification by  computing a symbolic representation
of an invariant that is satisfied by all reachable program configurations,
using an abstract-interpretation-based
fixpoint procedure, which starts
from a representation of the set of initial configurations.
thereafter repeatedly performs
symbolic postcondition computations that extend the
symbolic representation by the effect of any execution step of the program,
until convergence.
In this section, we first define in more detail the representation,
focusing in particular on the use of fragment abstraction, and thereafter
describe the symbolic postcondition computation. 


%% The main novel contribution is our fragment abstraction for
%% representing the possible heap configurations of a concurrent program.
%% In this section, we describe this symbolic representation and our
%% verification technique
%% for programs that operate on singly-linked lists (SLLs). This
%% representation is also the basis for our representation for programs
%% operating on skiplists, described in Section~\ref{subsect:skiplists}
%% and programs operating on arrays of SLLs, in Section~\ref{subsect:skiplists}.

%% We describe our fragment abstractions for three classes of heap structures:
%% in the following subsection, we consider programs operating on singly-linked
%% lists, in Subsection~\ref{subsect:skiplists}, we consider programs operating
%% on skiplists, and in
%% Subsection~\ref{subsect:skiplists}, we consider programs operating
%% arrays of singly linked lists.


%% In the actual verification, we compute a symbolic representation
%% of an invariant that is satisfied by all reachable program configurations (including observer states).
%% This invariant is obtained by an abstract-interpretation-based
%% fixpoint procedure, which starts
%% from a representation of the set of initial configurations, and
%% thereafter repeatedly performs
%% postcondition computations that extend the
%% symbolic representation by the effect of any execution step of the program,
%% until convergence.
%% This analysis needs to deal with the challenges of an unbounded domain of
%% data values, an unbounded number of concurrently executing threads, and an
%% unbounded heap. 

\subsubsection*{Symbolic Representations}
%% \bjcom{Say that for now, we ignore timers?}
%% \bjcom{Introduce notation for the set of local $\ddomain$-variables?.
%%   Maybe define which threads we talk about?
%%   For now, we skip timestamps.
%% }
%% We assume that we must analyze the product of a program and an observer.
Let us describe our symbolic representation for programs that
operate on skiplists, as introduced in Section~\ref{sec:overview}.
%% The representation is parameterized on a suitable data abstraction.
We first define more precisely our data abstraction by defining an
abstract domain for each concrete domain of data values, as follows.
We assume that each heap cell has at most one $\ddomain$-field, named {\tt data}.
For an observer register $\reg_i$, let a {\em $\reg_i$-cell} be a heap cell whose
${\tt data}$ field has the same value as $\reg_i$.
%% For each thread-local variable, and each non-pointer cell field, which ranges
%% over some concrete domain, we define a corresponding abstract domain,
%% as follows.
\begin{itemize}
\item For small concrete domains (including that of the program counter, and
  of the observer location),
  the abstract domain is the same as the concrete one.
\item
  For locks, the abstract domain is $\set{\mathit{me},\mathit{other},\mathit{free}}$,
  meaning that the lock is held by $\thread$,  held by some other thread, or is
  free, respectively.
\item For the concrete domain $\ddomain$ of data values, the abstract domain
  is the set of mappings from observer registers and local variables
  ranging over $\ddomain$ to subsets of $\set{<,=,>}$.
  An element in this abstract domain represents a concrete data value $\tt d$
  if it maps each local variable and observer register with a value ${\tt d'} \in \ddomain$
  to a set which includes a relation $\sim$ such that $\tt d \sim \tt d'$.
\end{itemize}
Define a {\em local symbolic configuration} $\locsymbconf$ to be
a mapping from local non-pointer
variables (including the program counter) to their corresponding abstract
domains.
We let $\sconf \satlocsymbconf{\thread} \locsymbconf$ denote that in the
global configuration $\sconf$, the
local configuration of thread $\thread$ satisfies the local symbolic
configuration $\locsymbconf$, defined in the natural way.

Let us now define our fragment abstraction for skiplists more precisely.
Let $\klevel$ be a level.
Define the abstraction of a pointer variable of form $\tt p[k]$
to be $\tt p[k]$ if ${\tt k} = 1$, otherwise $\tt p[higher]$.
That is, this abstraction does not distinguish different higher levels.
A {\em tag} is a tuple $\atag = \tagtuple$, where
\begin{inparaenum}[(i)]
\item
  $\vals$ is a mapping from non-pointer fields at level $\klevel$
  to their corresponding abstract domains (for array fields, the abstract
  domain is the same as for its elements),
\item
  $\pvars$ is a set of abstracted pointer variables,
 \item
   $\reachfrom$ and $\reachto$ are sets of global pointer variables and observer registers, and
  \item $\private$ is a boolean value.
\end{inparaenum}

For a heap cell $\cell$ that is accessible to thread $\thread$ 
in a configuration $\sconf$, and a tag $\atag = \tagtuple$,
we let $\cell \lsatfrag{\klevel}{\thread}{\sconf} \atag$ denote that
\begin{itemize}
\item
  $\vals$ is an abstraction of the concrete values of the non-pointer fields of $\cell$ (for array fields $\tt f$ we use the concrete value $\tt f[k]$),
%%   is satisfied in the following sense:
%%   \begin{enumerate}[(i)]
%%     \item
%%       $\vals(\field) = \cellval(\cell,\field)$ for each each non-lock
%%       $\mathbb{F}$-field $\field$,
%%   \item
%%       for each lock field $\field$, we have
%%       $\vals(\field) = \mathit{me}$ if $\thread$ holds the lock,
%%       $\vals(\field) = \mathit{other}$ if some other thread holds the lock, and
%%       $\vals(\field) = \mathit{free}$ if the lock is free,
%%   and
%% \item
%%   for each $\intgrs$-field $\field$ and each
%%   observer register $x  \in \ovarset$ we have that
%%   $\vals(\field)(x)$ is $=$ iff $\cellval(\cell,\field)$ is equal to the value
%%   of $x$.
%% \bjcom{Should we also do that for local data and timestamp variables?}
%%   \end{enumerate}
\item
  $\pvars$ is the set of abstractions of pointer variables (global or
  local to $\thread$) that point to $\cell$,
\item
  $\reachfrom$ is the set of
  \begin{inparaenum}[(i)]
  \item abstractions of global pointer variables
    %% and local pointer variables of $\thread$
    from which $\cell$ is reachable via a (possibly empty)
    sequence of {\tt next} pointers, and
  \item observer registers $\reg_i$ such that $\cell$ is reachable from
    some $\reg_i$-cell.
  \end{inparaenum}
\item
  $\reachto$ is the set of
  \begin{inparaenum}[(i)]
  \item abstractions of global pointer variables
    %% and local pointer variables of $\thread$
    pointing to a cell that is reachable from $\cell$, and
  \item observer registers $\reg_i$ such that some $\reg_i$-cell is reachable
    from $\cell$.
  \end{inparaenum}
\item
  $\private$ is $\true$ only if $\cell$ is 
not accessible to any other thread than $\thread$.
  %% $\private$ is $\true$ if
  %%  $\cell$ has never been published (by assigning a heap pointer-field or global pointer variable) by its creating thread $\thread$.
\end{itemize}
Note that the parameter $\klevel$ in the relation
$\lsatfrag{\klevel}{\thread}{\sconf}$
determines the element of non-pointer arrays that is represented by $\vals$. 


%% \begin{definition}[SLL-fragment]
%% \label{def:sll-fragment}
A {\em skiplist-fragment} $\frag$ (or just fragment)
is a triple of form
$\fragtupleat{\frag}$, of form
$\tuple{\inat{\frag},\nullconst}$, or of form
$\tuple{\inat{\frag},\dangconst}$,
where $\inat{\frag}$ and $\outat{\frag}$ are tags
    and $\datarelat{\frag}$ is a subset of $\set{<, =, >}$.
For a cell $\cell$ which is accessible to thread $\thread$, and a fragment
$\frag$ of form $\fragtupleat{\frag}$, let $\cell \lsatfrag{\klevel}{\thread}{\sconf}\frag$ denote that
the ${\tt next[k]}$ field of $\cell$ points to a cell $\cell'$ such that
%% \begin{inparaenum}[(i)]
%% \item
  $\cell \lsatfrag{\klevel}{\thread}{\sconf} \inat{\frag}$,
and
%% \item
$\cell' \lsatfrag{\klevel}{\thread}{\sconf} \outat{\frag}$, and 
%% \item
  $\cell.\mathtt{data} \sim \cell'.\mathtt{data}$ for some $\sim \in \datarelat{\frag}$.
%% \end{inparaenum}
The definition of $\cell \lsatfrag{\klevel}{\thread}{\sconf}\frag$
is adapted to fragments of form
$\tuple{\inat{\frag},\nullconst}$ and $\tuple{\inat{\frag},\dangconst}$ in the
obvious way.
%% For a fragment of form $\frag = \tuple{\inat{\frag},\nullconst}$, let
%% $\cell \satfrag{\thread}{\sconf} \frag$ denote that
%% $\cell \satfrag{\thread}{\sconf} \inat{\frag}$ and $\mathtt{next}(\cell) = \nullconst$.
%% Define $\cell \satfrag{\thread}{\sconf} \frag$ for $\frag$ of form $\tuple{\inat{\frag},\dangconst}$
%% analogously.
%% For $\tuple{\inat{\frag},\dangconst}$, the definition is adapted in the obvious way.

Let $\tuple{\fragset_1,\fragset_h}$ be a pair of sets of fragments.
A global configuration $\sconf$ satisfies a pair $\tuple{\fragset_1,\fragset_h}$
wrp.\ to $\thread$, denoted  $\sconf \satfragset{\thread} \tuple{\fragset_1,\fragset_h}$, if
\begin{itemize}
  \item for any cell $\cell$ that is accessible to $\thread$ (different from $\nullconst$ and $\bot$), there is a fragment
$\frag \in \fragset_1$ such that $\cell \lsatfrag{1}{{\thread}}{\sconf} \frag$,
    and
  \item
    for all levels $\klevel$ from $2$ up to the height of $\cell$, 
there is a fragment
$\frag \in \fragset_h$ such that $\cell \lsatfrag{\klevel}{{\thread}}{\sconf} \frag$.
\end{itemize}
Intuitively, a set of heap states is represented by two sets of fragments:
the set of level-1 fragments represents pairs of cells connected by
a $\tt next[1]$ pointer, and represents their array fields only at index
$k$;
the set of higher-level fragments represents pairs of cells connected by
a $\tt next[k]$ pointer for some $\klevel \geq 2$, and represents their
array fields only at index $k$.

We are now ready to define our abstract symbolic representation, which
is defined as a partial mapping from augmented local symbolic
configurations to sets of fragments. 
\begin{definition}
  \label{def:symbrep}
    A {\em symbolic representation} $\symbrep$ is a partial mapping from
pairs of local symbolic configurations and observer locations
to sets of fragments.
A system configuration $\sconf$ satisfies a symbolic representation $\symbrep$,
denoted $\sconf \satsymbrep \symbrep$,
if for each thread $\thread$, 
the domain of $\symbrep$ contains a pair
$\tuple{\locsymbconf,\ostate}$ such that
\begin{inparaenum}[(i)]
\item $\sconf \satlocsymbconf{\thread} \locsymbconf$,
\item the observer is in location $\ostate$, and
\item  $\sconf \satfragset{\thread} \symbrep(\tuple{\locsymbconf,\ostate})$.
\end{inparaenum}
\end{definition}
%% For a local symbolic  configuration $\locsymbconf$ and set $\fragset$ of
%% fragments, we write
%% $\conf \satconf{\thread} \tuple{\locsymbconf,\fragset}$ to denote that
%% that $\conf \satlocsymbconf{\thread} \locsymbconf$
%% and

\todo[inline]{We may need some examples here}






%% \begin{itemize}
%% \item
%%   $\pvarsofth{\cell}{\thread} = \pvars$,
%% \item
%%   $\valsofth{\cell}{\thread} = \vals$,
%% \item
%%   $\reachfromofth{\cell}{\thread} = \reachfrom$,
%% \item
%%   $\reachtoofth{\cell}{\thread} = \reachto$,
%%   and
%% \item
%%   if $\private$ is true then $\cell$ is not accessible from any thread other
%%   than $\thread$.
%% \end{itemize}
%% We can now define the notion of fragment.q

%% A {\em symbolic configuration} is a pair
%% $\tuple{\locsymbconf,\fragset}$ consisting of a local symbolic 
%% configuration $\locsymbconf$, and a set $\fragset$ of fragments.
%% A configuration $\conf$ of a program satisfies a symbolic configuration
%% $\tuple{\locsymbconf,\fragset}$ if for each thread $\thread$,
%% \begin{itemize}
%% \item the local configuration of $\thread$ satisfies $\locsymbconf$, in the
%%   natural way, and
%% \item for each $\cell$ that is accessible from $\thread$, there is
%%   a fragment $\frag$ such that $\cell \satfrag{\thread}{\sconf}_{\thread} \frag$.
%% \end{itemize}






\todo[inline]{What to replace the below example with?}
\paragraph{Example:} Let us show an example of how a singly linked list (SLL) is split into a set of fragments. Fig.~\ref{lazylist}(a) shows an example of a concrete shape of a singly linked list. Each cell contains the values of $\tt val$, $\tt mark$, and $\tt lock$ from top to bottom, where \tick \; denotes $\tt true$, and \cross \; denotes $\tt false$ (or $\tt free$ for $\tt lock$) and the value of $\tt val$ is denoted by a pair of the observer register $\tt z$ and a subset of $\set{<, =, >}$. There are two threads $1$ and $2$ with two local variables $\tt c_1$ and $\tt c_2$. There are two global variables $\tt H$ and $\tt T$ pointing to the head and tail of the list. The observer register $\tt z$ has value 8. Fig.~\ref{lazylist}(b) shows the result of splitting the list in Fig.~\ref{lazylist}(a) into fragments where each heap fragment is a small list of two nodes. Fig.~\ref{lazylist}(c) shows the abstraction of fragments in Fig.~\ref{lazylist}(b) where for each cell $\cell$, the value of $val$ is abstracted to a subset in $\tt \{<z, =z, >z\}$, the reachability relation between $\cell$ and global variables and observer registers is abstracted to the predicate $\tt X \mapsto \tt Y$ where $\tt X$, $\tt Y$ are sets of global variables and observer registers, $\tt i$ or $\tt o$ states that $\cell$ is an input or output cell.


\subsubsection{Symbolic Postcondition Computation}
\label{subsect:postcond}
In the  verification, we must compute an invariant in the form
of a symbolic representation
which is satisfied by all reachable program configurations.
%% (including observer states).
Such an invariant is obtained by an abstract interpretation-based
fixpoint procedure, which starts
from a representation of the set of initial configurations, and
thereafter repeatedly performs postcondition computations that extend the
symbolic representation by the effect of any execution step of the program,
until convergence.
We will now describe the symbolic postcondition computation.
%% \bjcom{The following should be included more smoothly, if really needed}
%% Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$.

%% Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
  
%% $\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. 

%% We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments, and any heap is ``broken down into pre-defined fragments''. A fragment retains the information about a particular part of a heap. This choice of fragments defines the level of abstraction that transforms heap into fragments. The abstract function $\alpha_k$ maps a heap into a set of fragments. Whereas, the concretization function $\gamma_k$ inputs a set of fragments, and returns the set of heaps that can be reconstructed from these fragments. 

%% \paragraph{Fragment Definition:} A heap fragment of size $\tt k$ is represented as \begin{center}
%% 	${\tt v} = \viewconf$ where 
%% \end{center} 

%We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments parameterized by a constant $\tt k$, and any heap is “broken down into pieces” of size (at most) k, called fragments. A fragment retains the information about $\tt k$ connected cells from a heap and abstracts away the other cells. This choice defines the level of abstraction that transforms heap into fragments.There is a certain freedom in what information to retain and what to abstract away. The abstract function $\alpha_k$ maps a heap into a set of heap fragments of sizes $\tt k$. The concretization function $\gamma_k$ inputs a set of heap fragments, and returns the set of heaps that can be reconstructed from the these fragments. Let us represent symbolic representations of heap fragments. A heap fragment of size $\tt k$ is represented as ${\tt \Omega} = \viewconf$ where 

%\paragraph{Abstract Configuration}:
%A abstract {\it configuration} of a program $\prog$ in the fragment of a single thread $\thread$
% is a tuple
%$\tuple{\tt c,\lambda, \Omega , S}$ where
%\begin{itemize}
%\item $\tt c$ is an observer configuration, 
%\item $\lambda$ is the label of the program statement, 
%\item $\tt \Omega$ is a tuple $\tt \tuple{\Omega_p, \Omega_l, Val}$ where $\tt \Omega_p$ contains a set ordering constrains between pointer variables, $\tt \Omega_l$ contains a set ordering constrains between data local variables and $\tt Val$ maps each data local variable to its value.
%\item $\tt S$ is a set of fragments.
%\end{itemize}
%
%% We use $\confsetof\prog$ to denote the set of configurations

The symbolic postcondition computation must ensure that the symbolic
representation
of the reachable configurations of a program is closed under execution of a
statement by some thread. That is, 
the symbolic postcondition operation applied to a symbolic representation
$\symbrep$ must produce an extension $\symbrep'$
of $\symbrep$, such that whenever $\sconf \satsymbrep \symbrep$
and $\sconf\movesto{\system}{}\sconf'$ then
${\sconf}' \satsymbrep \symbrep'$.
Let $\thread$ be an arbitrary thread. Then $\sconf \satsymbrep \symbrep$
implies that $\domof{\symbrep}$ contains some
$\auglocsymbconf$ with
$\sconf \satlocsymbconf{\thread} \auglocsymbconf$ and
$\sconf \satfragset{\thread} \symbrep(\auglocsymbconf)$. Our
symbolic postcondition computation must ensure that
%% this property still holds after any execution of a
%% statement by some thread, i.e., that
$\domof{\symbrep'}$ contains a pair
$\auglocsymbconf' = \tuple{\locsymbconf',\ostate'}$ such that
${\sconf}' \satlocsymbconf{\thread} \auglocsymbconf'$ and
${\sconf}' \satfragset{\thread} \symbrep(\auglocsymbconf')$.
%% from which a step $\sconf \movesto{\system} {\sconf}'$, then ${\sconf}' \satsymbrep \symbrep'$.
%% More precisely, assume that a global configuration $\conf$ satisfies
%% a symbolic representation $\symbrep$. Let $\thread$ be an arbitrary thread.
%% Assume that there is
%% a local symbolic configuration $\locsymbconf \in \domof{\symbrep}$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$.
%% it is still the case that
%% $\domof{\symbrep}$ contains a local symbolic configuration 
%% $\locsymbconf'$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf',\symbrep(\locsymbconf)}$
%% for some thread $\thread$.
In the thread-modular approach, there are two cases to consider, depending
on which thread causes the step from $\sconf$ to ${\sconf}'$.
\begin{itemize}
\item
  {\it Local Steps:} The step
  is caused by $\thread$ itself executing a statement
  which may change its local state, the location of the observer,
  and the state of the heap.
  In this case, we first compute a local symbolic configuration $\locsymbconf'$ and
  observer location $\ostate'$, and a set $\fragset'$ of fragments such that
  ${\sconf}' \satlocsymbconf{\thread} \tuple{\locsymbconf',\ostate'}$ and
  ${\sconf}' \satfragset{\thread} \fragset'$,
  and then (if necessary) extend $\symbrep$ so that
  $\tuple{\locsymbconf',\ostate'} \in \domof{\symbrep}$ and
  $\fragset' \subseteq \symbrep(\tuple{\locsymbconf',\ostate'})$.
\item
  {\it Interference Steps:} The step is caused by another thread $\thread_2$,
  which may change the location of the observer (to $\ostate'$)
  and the state of the heap.
%%   such a way that makes it necessary to extend $\symbrep(\locsymbconf)$.
  By assumption, there is a local symbolic configuration $\locsymbconf_2$
  with $\tuple{\locsymbconf_2,\ostate} \in \domof{\symbrep}$ such that
  $\sconf \satlocsymbconf{\thread_2} \tuple{\locsymbconf_2,\ostate}$ and
  $\sconf' \satfragset{\thread_2} \symbrep(\tuple{\locsymbconf_2,\ostate})$.
  For any such $\locsymbconf_2$ and statement of $\thread_2$,
  we must compute a set $\fragset'$ of fragments such that
  the resulting configuration ${\sconf}'$ satisfies
  $\sconf' \satfragset{\thread} \fragset'$ and 
  make sure that $\tuple{\locsymbconf,\ostate'} \in \domof{\symbrep}$ and
  $\fragset' \subseteq \symbrep(\tuple{\locsymbconf,\ostate'})$.
  To do this, we first combine the the local symbolic configurations
  $\locsymbconf$ and $\locsymbconf_2$ and the sets of fragments
  $\symbrep(\tuple{\locsymbconf,\ostate})$ and
  $\symbrep(\tuple{\locsymbconf_2,\ostate})$, using an
%%   of $\thread_1$ and $\thread_2$ and then compute a representation of the
%%   the possible heaps whose projection onto $\thread_i$ satisfies
%%   $\symbrep(\locsymbconf_i)$ for $i=1,2$.
%% This is done by performing an
  operation called {\em intersection}, into
  a joint local symbolic configuration of $\thread$ and $\thread_2$ and
  a set $\fragset_{1,2}$ of fragments that represents the cells accessible
  to either $\thread$ or $\thread_2$.
  We thereafter symbolically compute the postcondition of the statement
  executed by $\thread_2$, in the same was as for local steps,
  and finally project the set of resulting fragments back onto $\thread$
  to obtain $\fragset'$.
\end{itemize}
In the following, we first describe the symbolic postcondition computation for
local steps, and thereafter the intersection operation.


\paragraph{Symbolic Postcondition Computation for Local Steps}
Let $\thread$ be an arbitrary thread, and assume
that $\auglocsymbconf \in \domof{\symbrep}$.
For each statement that $\thread$ can execute in a configuration $\sconf$
with $\sconf \satlocsymbconf{\thread} \auglocsymbconf$ and
$\sconf \satfragset{\thread} \symbrep(\auglocsymbconf)$,
we must compute a local symbolic configuration $\locsymbconf'$, a new
observer location $\ostate'$ and a set  $\fragset'$ of fragments such that
such that the resulting configuration ${\sconf}'$ satisfies
  ${\sconf}' \satlocsymbconf{\thread} \tuple{\locsymbconf',\ostate'}$ and
  ${\sconf}' \satfragset{\thread} \fragset'$.
This computation is done differently for
each statement. For statements that do not affect the heap or pointer variables,
this computation is standard, and affects only the local symbolic
configuration, the observer location, and the $\vals$ component of
tags.
We therefore here describe how to compute the effect of statements that update
pointer variables or pointer fields of heap cells,
since these are the most interesting cases.

Let us fist consider a statement of form $\gvarof{g} := \lvarof{p}$,
which assigns the value of a local pointer variable $\lvarof{p}$ to a global
pointer variable $\gvarof{g}$. The set $\fragset'$ of fragments is obtained by
modifying each fragment in $\symbrep(\auglocsymbconf)$ to reflect the effect
of the assignment. For any tag in a fragment, the $\vals$ field is not affected.
The $\pvars$ field  is updated to contain the variable $\gvarof{g}$ if and only if it contained the variable $\lvarof{p}$ before the statement. 
The difficulty is to update the reachability information represented
by the fields $\reachfrom$ and $\reachto$,
and in particular to determine whether $\gvarof{g}$ should be in such a
set after the statement
(note that if $\lvarof{p}$ were a global variable, then the corresponding
reachability information for $\lvarof{p}$ would be in the fields
$\reachfrom$ and $\reachto$, and the update would be simple: just
reflecting that $\gvarof{g}$ and $\lvarof{p}$ are now aliases, just as
in the update of $\pvars$).
In order to compute the postcondition with sufficient precision, we
%% However, since the $\reachfrom$ field does not include local variables, we
therefore investigate whether the set of fragments $\symbrep(\auglocsymbconf)$
allows to form a heap in which a $p$-cell can reach or be
reached from a particular tag of a fragment.
It also checks whether a heap can be formed
in which a $p$-cell can {\em not} reach or be reached from a particular tag.
For each
case that succeeds, the set $\fragset'$ will contain fragment with
corresponding content of $\reachto$ and $\reachfrom$ fields.

Our postcondition computation performs this investigation in a
systematic manner, by computing a set of transitive closure-like relations
between fragments.
First, say that two tags
$\atag$ and $\atag'$ are {\em consistent} if the concretizations of their
$\vals$-fields overlap, and if the other fields agree.
Thus, $\atag$ and $\atag'$ are consistent if there can exist a cell
$\cell$ accessible to $\thread$ in some heap,
with $\cell \satfrag{\thread}{\sconf} \atag$
and $\cell \satfrag{\thread}{\sconf} \atag'$.
%% \todo[inline]{To Quy: Can you really require that the data abstrations must
%%   be the same?}
Then, for two fragments $\frag_1$ and $\frag_2$ in a set $\fragset$ of fragments,
\begin{itemize}
\item let $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denote that $\outof{\frag_1}$   and $\inof{\frag_2}$ are consistent, and
  %% \todo[inline]{Quy: PLEASE  you provide the precise definition of when
  %%   $\tagat{\outof{\frag_1}}$ and $\tagat{\inof{\frag_2}}$ are consistent?}
  %% \quycom{They are consistent if they have same $\reachfrom$, $\reachto$, $\pvars$, $\private$, $\data$. This is for local thread. When we check for consistent between two tags when doing intersection, we have to define differently.}  
\item let $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denote that $\outof{\frag_1} = \outof{\frag_2}$ are consistent, and that either
  $\pvarsat{\inof{\frag_1}} \cap \pvarsat{\inof{\frag_2}} = \emptyset$ or that
  the global variables in  $\reachfromat{\inof{\frag_1}}$ are disjoint from
  those in $\reachfromat{\inof{\frag_2}}$.
  \bjcom{Question: Is this correct?}
%%   \quycom{$\reachfromat{\inof{\frag_1}} \cap \reachfromat{\inof{\frag_2}} = \emptyset$ here is not correct, we only need the global variables of reachfrom and reachto in this case}
%% \quycom{In my definition, the consistent here is defined for two views in the same threads. With the view from other thread, I use the notion of intersection.}
\end{itemize}
Intuitively, $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denotes that it is
possible that  $\mathtt{next}(\cell_1) = \cell_2$ for some cells with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Intuitively, $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denotes that it is
possible that
  $\mathtt{next}(\cell_1) = \mathtt{next}(\cell_2)$
for different cells  $\cell_1$ and $\cell_2$ with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$
(Note that these definitions also work for views containing
$\nullconst$ or $\dangconst$).
We use these relations to define several derived relations:
%% \bjcom{We could use a common pattern for these and save space in definitions.}
\begin{itemize}
\item $\overset{+}\hookrightarrow_{\fragset}$ denotes the transitive closure,
%%   of   $\hookrightarrow_{\fragset}$,
  and
   $\overset{*}\hookrightarrow_{\fragset}$ the reflexive transitive closure, of
  $\hookrightarrow_{\fragset}$,
\item $\frag_1 \!  \overset{**}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that 
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{*+}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1', \frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{*\circ}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that $\exists \frag_1' \in \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1'$,
\item $\frag_1 \!  \overset{++}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{+*}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{+\circ}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1' \in \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1'$.
\end{itemize}
We say that $\frag_1$ and $\frag_2$ are {\em compatible} if $\frag_x \overset{*}\hookrightarrow \frag_y$, or $\frag_y \overset{*}\hookrightarrow \frag_x$, or $\frag_x \overset{**}\leftrightarrow \frag_y$. Intuitively, if $\frag_1$ and
$\frag_2$ are satisfied by two cells in the same heap state, then they are
be compatible.
\input viewrelations
\bjcom{Do we need to update the following example?}
Figure~\ref{fig:viewrelations} illustrates the above relations for a heap state
with $13$ heap cells. The figure shows 4 fragments that are satisfied by heap
cells, as denoted by green boxes, and how the relationship between heap cells
is reflect by relations between the corresponding fragments.

We can now describe the symbolic postcondition computations for
statements that affect pointer variables or pointer fields.

First, consider a statement of form
${\tt x := y}$, where $\mathtt{x}$ and $\mathtt{y}$ are local
(to thread $\thread$) or global pointer variables.
We must compute a set $\fragsetpost$ of
fragments which are satisfied by the configuration after the statement. This
means that for any cell $\cell$ which is accessible to $\thread$ after
the statement, there must be some fragment $\frag'$ in $\fragsetpost$
with $\cell \satfrag{\thread}{\sconf} \frag'$
By assumption, $\cell$ satisfies some fragment $\frag$ in $\fragset$
before the statement, and is in the same heap state as the cell pointed to by
$\gvarof{y}$.
This implies that $\frag$ must be compatible with some
fragment $\frag_y\in\fragset$ such that $\mathtt{y} \in \pvarsat{\inof{\frag_y}}$. This means that we can make a case analysis on the possible relationships
between $\frag$ and any such $\frag_y$.
Thus, for each fragment $\frag_y\in\fragset$ such that
$\mathtt{y} \in \pvarsat{\inof{\frag_y}}$ we let $\fragsetpost$ contain
the fragments obtained by any of the following transformations on any fragment in
$\fragset$.
\begin{enumerate}
\item
First, for the fragment $\frag_y$ itself, we let $\fragsetpost$ contain
$\frag_y'$, which is the same as $\frag_y$, except that
%% Let $\tt kill(x,v)$ be the procedure to remove $\tt x$ if it exists from
%% $\reachfromat{\inof{\frag}}$,
%% $\reachfromat{\outof{\frag}}$,
%% $\reachtoat{\inof{\frag}}$,
%% $\reachtoat{\outof{\frag}}$,
%% $\pvarsat{\inof{\frag}}$, and
%% $\pvarsat{\outof{\frag}}$.
\begin{itemize}
\item $\pvarsat{\inof{\frag_y'}} = \pvarsat{\inof{\frag_y}} \cup \set{x}$ and
  $\pvarsat{\outof{\frag_y'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$
\end{itemize}
and furthermore, if $\gvarof{x}$ is a global variable, then
{\small
  \begin{itemize}
\item $\reachtoat{\inof{\frag_y'}} = \reachtoat{\inof{\frag_y}} \cup \set{x}$ and
$\reachfromat{\inof{\frag_y'}} = \reachfromat{\inof{\frag_y}} \cup \set{x}$,
\item $\reachfromat{\outof{\frag_y'}} = \reachfromat{\outof{\frag_y}} \cup \set{x}$ and
$\reachtoat{\outof{\frag_y'}} = \reachtoat{\outof{\frag_y}} \setminus \set{x}$.
\end{itemize}
}
\item  for each fragment $\frag$ with $\frag \hookrightarrow_{\fragset} \frag_y$, let $\fragsetpost$ contain $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{x}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
\item We perform analogous inclusions for fragments $\frag$ with
  $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$,
  $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$,
  $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$, and
  $\frag_y \overset{*\circ}\leftrightarrow_{\fragset} \frag$. For space reasons,
  we show only the case of $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$,
  in which case we let $\fragsetpost$ contain $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
\end{enumerate}
The statement ${\tt x := y.next}$ is handled rather similarly to the 
case ${\tt x := y}$.
Let us therefore describe the postcondition computation for statements of the form
${\tt x.next:= y}$.
This is the most difficult statement, since it is a destructive update of the heap. It affects reachability relations for both $\gvarof{x}$ and $\gvarof{y}$.
The postcondition computation makes a case analysis on how a fragment
in $\fragset$ is related to some pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inof{\frag_x}}$, $\tt y \in \pvarsat{\inof{\frag_y}}$. 
Thus, for each pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inof{\frag_x}}$ and $\tt y \in \pvarsat{\inof{\frag_y}}$, it is first checked whether the statement may form
a cycle in the heap. This may happen if
$\frag_y \overset{*}\hookrightarrow_{\fragset}\frag_x$, in which case the postcondition reports a potential cycle.
Otherwise, we let $\fragsetpost$ contain
the fragments obtained by the following transformations on fragments in
$\fragset$.
\begin{enumerate}
  \item
    First, let $\fragsetpost$ contain a new fragment $\frag_{new}$, representing
    the new pair of neighbours formed by the statement, of form
    $\frag_{new} = \fragtupleat{\frag_{new}}$ such that
    $\tagat{\inof{\frag_{new}}} = \tagat{\inof{\frag_x}}$ and
    $\tagat{\outof{\frag_{new}}} = \tagat{\inof{\frag_y}}$ except that
    $\reachfromat{\outof{\frag_{new}}} = \reachfromat{\inof{\frag_y}} \cup \reachfromat{\inof{\frag_x}}$ and
    $\reachtoat{\inof{\frag_{new}}} = \reachtoat{\inof{\frag_y}} \cup \pvarsat{\inof{\frag_x}}$, and
    $\datarelof{\frag_{new}} = \set{<,=,>}$.
    \bjcom{This last thing needs fixing}
  \item
    Thereafter, we add all possible fragments that can result from a transformation
of some fragment $\frag$ which is in $\frag$. This is done by an exhaustive
case analysis on the possible
relationship between $\frag$, $\frag_x$ and $\frag_y$.
Let us consider an interesting case, in which
$\frag_x \overset{*}\hookrightarrow_{\fragset} \frag$ and either $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*+}\leftrightarrow \frag$.
In this case,
\begin{enumerate}
\item
  for each subset $\regset$ of observer registers in $\tt \reachfromat{\inof{\frag}} \cap \reachfromat{\inof{\frag_x}}$, we first create
  a fragment $\frag'$ which is same as $\frag$, except that $\reachfromat{\inof{\frag'}} = (\tt \reachfromat{\inof{\frag}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset$.
\item
  Thereafter, 
for each set $\regset'$ of observer registers in $\reachfromat{\outof{\frag'}} \cap \reachfromat{\inof{\frag_x}}$,  we let $\fragsetpost$ contain a fragment
$\frag''$ which is same as $\frag'$, except that $\reachfromat{\outof{\frag''}} = (\reachfromat{\outof{\frag'}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset'$. 
\end{enumerate}
\end{enumerate}
\todo[inline]{We should include an argument why the last case above is correct.
  Quy, could you produce one?}

\paragraph{Symbolic Postcondition Computation for Interference Steps.} 
Here, the key step is the {\em intersection} operation, which
takes two sets of fragments
$\fragset_1$ and $\fragset_2$, and produces a set of joint fragments
$\fragset_{1,2}$, such that
$\sconf \satfragset{\thread_1,\thread_2} \fragset_{1,2}$ for any configuration
such that
$\sconf \satfragset{\thread_i} \fragset_i$ for $i=1,2$.
This means that for each heap cell accessible to either
$\thread_1$ or $\thread_2$, the set $\fragset_{1,2}$ 
contains a fragment $\frag$ with $\cell \satfrag{\{\thread_1,\thread_2\}}{\sconf} \frag$ (generalizing the notation  $\satfrag{\thread}{\sconf}$ to several
threads).
In order to distinguish
between local variables of $\thread_1$ and $\thread_2$, we use the notation
$\lvarof{x[i]}$ for a local variable $\lvarof{x}$ of thread $\thread_i$.
There are  here two possibilities.
\begin{itemize}
\item If $\cell$ is accessible to both $\thread_1$ and $\thread_2$, then
  there are fragments $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$
  such that $\cell \satfrag{\thread_1}{\sconf} \frag_1$ and $\cell \satfrag{\thread_2}{\sconf} \frag_2$.
  We use the notation $\frag_1 \sqcap \frag_2$ to denote a set of views such that
  whenever $\cell \satfrag{\thread_1}{\sconf} \frag_1$ and $\cell \satfrag{\thread_2}{\sconf} \frag_2$ then
  $\cell \satfrag{\{\thread_1,\thread_2\}}{\sconf} \frag$ for some $\frag \in (\frag_1 \sqcap \frag_2)$.
\item If $\cell$ is accessible to only one thread,
  %% of $\thread_1$ and $\thread_2$,
  say $\thread_1$, then $\fragset$ should contain some fragment
  $\frag_1 \in \fragset_1$ with $\cell \satfrag{\set{\thread_1,\thread_2}}{\sconf} \frag_1$
  \bjcom{Maybe we need to change $\frag_1$, e.g., if we are at a cutpoint?}
\end{itemize}
For a fragment $\frag$, define
$\greachfromat{\inof{\frag}}$ as the set of global variables in
$\reachfromat{\inof{\frag}}$. Define
$\greachtoat{\inof{\frag}}$,
$\greachfromat{\outof{\frag}}$,
$\greachtoat{\outof{\frag}}$,
$\gpvarsat{\inof{\frag}}$, and
$\gpvarsat{\outof{\frag}}$
analogously.
Define $\gtagat{\outof{\frag}}$ as the tuple
$\tuple{\valsat{\outof{\frag}},\gpvarsat{\outof{\frag}},\greachfromat{\outof{\frag}},\greachtoat{\outof{\frag}},\privateat{\outof{\frag}}}$.
\todo[inline]{Question to Quy: Should we also define $\gtagat{\inof{\frag}}$,
  since it is used below?}

\todo[inline]{Question to Quy: You have also used the notation
  $\gvalsat{\inof{\frag}}$. Will you need it, and if so what does it mean?} \quycom{Because in the data, I add data constraint between data fields and local data variable. When we do intersection, we do not need to care about this constraint because its local constraint}

Let us now describe how to compute  $\frag_1 \sqcap \frag_2$ for
two views $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$.
%% Firstly, we consider the case where both $\frag_1$ and $\frag_2$ have size 2.
We observe that if a cell $\cell$ satisfies
$\cell \satfrag{\thread_1}{\sconf} \frag_1$ and $\cell \satfrag{\thread_2}{\sconf} \frag_2$, then
the information about global variables in $\frag_1$ and $\frag_2$ must coincide.
This leads to the following cases.
 \begin{itemize}
 \item if $\greachfromat{\inof{\frag_1}} \neq \emptyset$ and $\greachfromat{\inof{\frag_2}} \neq \emptyset$ then the global information in $\frag_1$ and $\frag_2$ must coincide. We hence obtain:
  \begin{itemize}
  \item if $\gtagat{\inof{\frag_1}} = \gtagat{\inof{\frag_2}}$ and $\gtagat{\outof{\frag_1}} = \gtagat{\outof{\frag_2}}$ then $\frag_1 \sqcap v_2 = \set{\frag_{12}}$ where $\frag_{12}$ is identical to $\frag_1$ except that
    \bjcom{Quy: It is strange that {\tt private} is included. Please check!!!}
  \begin{itemize}
  \item $\pvarsat{\inof{\frag_{12}}} = \pvarsat{\inof{\frag_1}} \cup \pvarsat{\inof{\frag_2}}$ 
  \item  $\pvarsat{\outof{\frag_{12}}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$
  \item $\reachfromat{\inof{\frag_{12}}} = \reachfromat{\inof{\frag_{1}}} \cup \reachfromat{\inof{\frag_{2}}}$
   \item $\reachfromat{\outof{\frag_{12}}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
     \todo[inline]{Question to Quy: Why do this union only for $\pvars$ and $\reachfrom$, and not for $\reachto$ and $\vals$?}\quycom{we fixed this in the disscussion}
    \end{itemize}
  \todo[inline]{Question to Quy: Should we not have an ``else'' here, with
    $\frag_1 \sqcap \frag_2 = \emptyset$?}\quycom{we fixed this in the disscussion}
 \end{itemize}

 \item if $\greachfromat{\inof{\frag_1}} = \emptyset$, $\greachfromat{\inof{\frag_2}} = \emptyset$, $\greachfromat{\outof{\frag_1}} \neq \emptyset$ and $\greachfromat{\outof{\frag_2}} \neq \emptyset$ then 
  \begin{itemize}
  \item if $\gtagat{\outof{\frag_1}} = \gtagat{\outof{\frag_2}}$, $\privateat{\inof{\frag_1}} = \false$ and $\privateat{\inof{\frag_2}} = \false$ then $\frag_1 \sqcap \frag_2 = \set{\frag_1', \frag_2', \frag_{12}}$ where
      %$\frag_{12}$ is same as $\frag_1$ except that 
%    \begin{itemize}
%  \item $\pvarsat{\inof{\frag_{12}}} = \pvarsat{\inof{\frag_1}} \cup \pvarsat{\inof{\frag_2}}$ 
%  \item  $\pvarsat{\outof{\frag_{12}}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$
%  \item $\reachfromat{\inof{\frag_{12}}} = \reachfromat{\inof{\frag_{1}}} \cup \reachfromat{\inof{\frag_{2}}}$
%   \item $\reachfromat{\outof{\frag_{12}}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
%    \end{itemize} and
      \begin{itemize}
      \item
        $\frag_1'$ is same as $\frag_1$ except that 
    \begin{itemize}
  \item  $\pvarsat{\outof{\frag_1'}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$
  \item $\reachfromat{\outof{\frag_1'}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
    \end{itemize}
  \item
    $\frag_2'$ is same as $\frag_2$ except that 
    \begin{itemize}
  \item  $\pvarsat{\outof{\frag_2'}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$
  \item $\reachfromat{\outof{\frag_2'}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
    \end{itemize}
  \item
    $\frag_{12}$ is as in the previous case.
    \bjcom{to Quy: I added this, is it correct?}
      \end{itemize}
    \item if $\gtagat{\outof{\frag_1}} = \gtagat{\outof{\frag_2}}$ and $\privateat{\inof{\frag_1}} = \true$ or $\privateat{\inof{\frag_2}} = \true$ then $\frag_1 \sqcap \frag_2 = \set{\frag_1', \frag_2'}$ where
$\frag_1'$ and $\frag_2'$ are as above.
 \end{itemize}
 
 \item if $\greachfromat{\inof{\frag_1}} = \emptyset$, $\greachfromat{\inof{\frag_2}} = \emptyset$, $\greachfromat{\outof{\frag_1}} = \emptyset$ and $\greachfromat{\outof{\frag_2}} = \emptyset$ then 
 \begin{itemize}
 \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\privateat{\inof{\frag_1}} = false$, $\privateat{\outof{\frag_1}} = false$, $\privateat{\outof{\frag_1}} = false$ and $\privateat{\outof{\frag_2}} = false$ then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2',\frag_{12}\}$ %where $\frag_{12}$ is same as $\frag_1$ except that 
   % \begin{itemize}
 % \item $\pvarsat{\inof{\frag_{12}}} = \pvarsat{\inof{\frag_1}} \cup \pvarsat{\inof{\frag_2}}$ 
 % \item  $\pvarsat{\outof{\frag_{12}}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$
 % \item $\reachfromat{\inof{\frag_{12}}} = \reachfromat{\inof{\frag_{1}}} \cup \reachfromat{\inof{\frag_{2}}}$
 %  \item $\reachfromat{\outof{\frag_{12}}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
 %   \end{itemize} and 
 %   $\frag_{1'}$ is same as $\frag_1$ except that 
 %   \begin{itemize}
 % \item  $\pvarsat{\outof{\frag_1'}} = \pvarsat{\outof{\frag_1}} \cup \frag_2.vars(j_o)$
 % \item $\reachfromat{\outof{\frag_1'}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
 %   \end{itemize}
 %  and $\frag_2'$ is same as $\frag_2$ except that 
 %   \begin{itemize}
 % \item  $\pvarsat{\outof{\frag_2'}} = \pvarsat{\outof{\frag_1}} \cup \frag_2.vars(j_o)$
 % \item $\reachfromat{\outof{\frag_2'}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$
 %   \end{itemize}
    
    
   \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, ($\privateat{\inof{\frag_1}} = true$ or $\privateat{\inof{\frag_2}} = true$) and $\privateat{\outof{\frag_1}} = false$ and $\privateat{\outof{\frag_2}} = false$ then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2'\}$  

  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\privateat{\outof{\frag_1}} = true$ or $\privateat{\outof{\frag_1}} = true$) then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$ 

    \item if $\tt gtag(\frag_1, o) \neq gtag(\frag_2, o)$ then $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$
 \end{itemize}
 
 \end{itemize}


 \section{Fragment Abstraction for  Skiplists}
\label{sect:skiplists}
Our fragment abstraction for skiplist extends the fragment abstraction for
singly-linked lists in several ways:
\begin{itemize}
\item
We abstract all occurrences of levels
higher than 2 by the single abstract element $\tt higher$, i.e., 
we do not distinguish between different higher levels.
  A pointer or non-pointer variable indexed by a level,
  of form $\tt v[i]$ with ${\tt i} \geq 2$, is
  abstracted to the variable $\tt v[higher]$.
\bjcom{Does it imply something more?}
\item
  We use two types of fragments: {\em level 1-fragments} to represent pairs of
cells connected by a $\tt next[1]$-pointer, and {\em higher level-fragments} for
representing pairs of cells connected by a higher level pointer.
\item
  The fields $\reachfrom$ and $\reachto$ in tags represent reachability information with respect to sequences of lowest-level {\tt next[1]} pointers, in
  both level 1-fragments and higher level-fragments. Thus, the fragments do
  not explicitly represent such reachability relations with respect to
  {\tt next[i]} pointers for ${\tt i} \geq 2$.
\item
  \bjcom{There are several more fine distinctions that must be made.
    A discussion is needed. For instance, how do we represent
  arrays of {\tt marked} fields?}
\end{itemize}
 \begin{figure}  
 \input skiplistshape  
 \caption{A concrete shape of 3-level skipl-list with two threads}
\end{figure}

 \begin{figure}  
 \input skiplistabs
 \caption{skipl-list fragments \quycom{i am working with this figure}}
\end{figure}

 \paragraph{Symbolic Postcondition Computation for Skiplists}
 The symbolic postcondition computation for skiplists is an extension of that
 for singly-linked lists. Thus, for statements that
do not affect higher-level $\tt next$ fields,
   the postcondition computation is performed for the augmented local
   symbolic configuration and the level 1-fragments in the same way as
   for singly-linked lists.
   Based on this postcondition computation, higher-level fragments are
   updated as follows.
     For each higher level-fragment $\frag \in \fragset$, let
     $\frag_1$ and $\frag_2$ be level 1-fragments such that
     $\tagat{\inof{\frag_1}} = \tagat{\inof{\frag}}$ and
     $\tagat{\inof{\frag_2}} = \tagat{\outof{\frag}}$.
     For any fragments $\frag_1'$ and $\frag_2'$ that are derived from
     $\frag_1$ and $\frag_2$, respectively, we add a higher-level
     fragment $\frag'$ to $\fragset_{posst}$
     which is the same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inoneof{\frag_1'}}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\intwoof{\frag_2'}}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inoneof{\frag_1'}}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\intwoof{\frag_2'}}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inoneof{\frag_1'}}$,
\item $\reachtoat{\outof{\frag'}} =  \reachtoat{\intwoof{\frag_2'}}$,
\end{itemize}


 \todo[inline]{The rest is old stuff, which could go into appendix}
 First, a symbolic postcondition computation is performed for 
Let us show how to perform the abstract transformer for skip-list programs on the set of fragments $\fragset$ depending on the particular statement.
%% We consider fragments of size $2$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \{{o}\}$, and $\tt next(i) = {o}$ and fragments of size $1$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \emptyset$, and $\tt next(i) = null$ or $\tt next(i) = \bot$.
For each fragment $\tt v$, let $\tt v.level \in \{1,2\}$ be the level of $\tt v$.

\paragraph{Local Abstract Transformers:} First, let us show the abstract transformer on the set of fragment $\fragset$ in the fragment of the concurrent thread. Let $\fragset_1$ be set of fragments of level 1 in $\fragset$, $\fragset_2$ be set of fragments of level 2 in $\fragset$. For each program statement, let $\fragset_{post}$ be the set of fragments after executing the statement. Let $\fragset_{post}$ be initialized as the empty set.  Let $\tt R$ be the set of pairs of fragments. Intuitively, in each element in $\tt R$, the second fragment is the transformation of the first fragment. Let $\tt R$ be initialized as the empty set.
\begin{itemize}
\item ${\tt x := y}$: The transformer is performed as follows:  For each fragment $\tt \frag_y \in \fragset_1$ where $\tt y \in\pvarsat{\inof{ \frag_y}}$, 
%\begin{itemize}
\begin{enumerate}
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{x}$,
\item if $\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \cup \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item for each fragment $\tt v$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*\circ}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item create $\tt v'$ which is same as $\tt \frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \cup \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
 \item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \cup \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
%\item for each fragment $\tt v'$ in $\fragset_{post}$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
\item for each fragment $\frag \in \fragset_2$ we do as follows. For each $(\frag_1,\frag_1')$ and $(\frag_2,\frag_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, and $\tt tag(v,o) = tag(\frag_2, i_2)$.
  \bjcom{This needs revising}
 Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inoneof{\frag_1'}}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\intwoof{\frag_2'}}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inoneof{\frag_1'}}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\intwoof{\frag_2'}}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inoneof{\frag_1'}}$,
\item $\reachtoat{\outof{\frag'}} =  \reachtoat{\intwoof{\frag_2'}}$,
\end{itemize} then add $\tt v'$ to $\fragset_{post}$. 
\end{enumerate}
%\item If there does not exist such $\tt \frag_y$ in $\fragset_1$
%\end{itemize}
%\begin{enumerate}
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%%\begin{itemize}
%%\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
%%\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{x}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
%%\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
%% \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
%%\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\fragset_{post}$,
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%%\begin{itemize}
%%\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
%%\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{x}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
%%\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
%% \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
%%\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\fragset_{post}$,
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$ 
%\end{itemize}
%
%%4%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%5%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%6%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%7%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%8%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%9%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%10%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%11%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%12%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%\end{enumerate}
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X := Y.NEXT1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item ${\tt x := y.next[1]}$: The local abstract transformer is quite similar to the previous case with slightly differences. For each fragment $\tt \frag_y \in S$ where $\tt y \in {\tt vars}(\tt i)$,
%\begin{enumerate}
%
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%\end{itemize}
%
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{+}\hookrightarrow_{\fragset} \frag_1$ 
%\end{itemize}
%
%%-------------------------------------------4------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%-------------------------------------------5------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-------------------------------------------6------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%-------------------------------------------7-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%------------------------------------------8-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-----------------------------------------9-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%-----------------------------------------10-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%-----------------------------------------11-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$  where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-----------------------------------------12-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1y\overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%\end{enumerate}




\begin{enumerate}
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{*}\hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ then
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \cup \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize} 
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$

\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{+}\hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \cup \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*\circ}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \{x\{$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$ ,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{+\circ}\leftrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$

\item create $\tt v'$ which is same as $\tt \frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
%\item for each fragment $\tt v'$ in $\fragset_o$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
%

\item for each fragment $\tt v \in \fragset_2$ we do as follows. For each $\tt (\frag_1,\frag_1')$, $\tt (\frag_2,\frag_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, and $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inoneof{\frag_1'}}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\intwoof{\frag_2'}}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inoneof{\frag_1'}}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\intwoof{\frag_2'}}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inoneof{\frag_1'}}$,
\item $\reachtoat{\outof{\frag'}} =  \reachtoat{\intwoof{\frag_2'}}$,
\end{itemize} then add $\tt v'$ to $\fragset_{post}$. 
\end{enumerate}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X.NEXT1 := Y %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item  ${\tt x.next[1]:= y}$: The local abstract transformer is performed by several steps as follows: For each pair of fragments $\frag_x$, $\tt \frag_y$ in $\fragset_1$ where $\tt x \pvarsat{\inof{\in \frag_x}}$, $\tt y \in\pvarsat{\inof{ \frag_y}}$, and $\frag_x \overset{*}\hookrightarrow \frag_y$ or $\tt \frag_y \overset{*}\hookrightarrow \frag_x$ or $\frag_x \overset{**}\leftrightarrow \frag_y$, let $\tt R_1$, $\tt R_2$, $\tt R_3$, $\tt R_4$, $\tt R_5$, $\tt R_6$ be initialized as $\tt R$,  
\begin{enumerate}
\item let $\tt \frag_{new}$ be the fragment of size 2 and of level 1 where $\tt tag(\frag_{new},i) = tag(\frag_x, i)$ and $\tt tag(\frag_{new},o) = tag(\frag_y,i)$ except that $\tt \reachfromat{\outof{\frag_{new}}} = \reachfromat{\inof{\frag_y}} \cup \reachfromat{\inof{\frag_x}}$,
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{*}\hookrightarrow_{\fragset} \frag_x$, we do as follows: For each subset $\regset$ of observer registers in $\reachtoat{\inof{\frag}} \cap \reachfromat{\inof{\frag_x}}$


\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that
\begin{itemize}
\item $\reachtoat{\inof{\frag'}} = (\tt \reachtoat{\inof{\frag}} \cap \reachfromat{\inof{\frag_x}}) \cup \reachto{\inof{\frag_y}} \cup \regset$.
\item $\reachtoat{\outof{\frag'}} = (\tt \reachtoat{\outof{\frag}} \cap \reachfromat{\inof{\frag_x}}) \cup \reachto{\inof{\frag_y}} \cup \regset$.
\end{itemize}
\item add $\tt v'$ to $\fragset_{post}$ 
\item add $\tt (v,v')$ to $\tt R_1$
\end{itemize}

\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} v$ or $\tt \frag_y = v$, 
\begin{itemize}
	\item create  $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
 \item $\tt \reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag_x}} \cup \tt \reachfromat{\inof{\frag}}$, 
\item $\tt \reachfromat{\outof{\frag'}} = \reachfromat{\inof{\frag_x}} \cup \tt \reachfromat{\outof{\frag}}$, 
\end{itemize}
\item add $\tt v'$ to $\fragset_{post}$,
\item add $\tt (v,v')$ to $\tt R_2$
\end{itemize}
\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} v$ and either $\tt v \hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*o}\leftrightarrow_{\fragset} v$, 
\begin{itemize}
\item  create $\tt v'$ which is same as $\tt v$ except that $\tt \reachfromat{\outof{\frag'}} = \reachfromat{\inof{\frag_x}} \cup \tt \reachfromat{\outof{\frag}}$, 
 \item add $\tt v'$ to $\fragset_{post}$, 
 \item add $\tt (v,v')$ to $\tt R_3$

\end{itemize}


\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} v$ and either $\tt v \hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*o}\leftrightarrow_{\fragset} v$,  
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$ then except that $\tt \reachfromat{\outof{\frag'}} = \reachfromat{\inof{\frag_x}} \cup \tt \reachfromat{\outof{\frag}}$, 
\item for each subset $\regset$ of observer registers in $\reachfromat{\inof{\frag'}} \cap \reachfromat{\inof{\frag_x}}$
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\reachfromat{\inof{\frag''}} = (\reachfromat{\inof{\frag'}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset$.
\item add $\tt v''$ to $\fragset_{post}$,
\item add $\tt (v,v'')$ to $\tt R_4$
\end{itemize}
\end{itemize}

\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} v$ and either $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\tt v \overset{*+}\leftrightarrow_{\fragset} \frag_y$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$
\item  add $\tt v'$ to $\fragset_{post}$,
\item add $\tt (v,v')$ to $\tt R_5$

\end{itemize}


\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} v$ and either $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*+}\leftrightarrow v$, then for each subset $\regset$ of observer registers in $\tt \reachfromat{\inof{\frag}} \cap \reachfromat{\inof{\frag_x}}$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that $\reachfromat{\inof{\frag'}} = (\tt \reachfromat{\inof{\frag}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset$. 
 \item for each set $\regset'$ of observer registers in $\reachfromat{\outof{\frag'}} \cap \reachfromat{\inof{\frag_x}}$,  
\begin{itemize}
\item create $\frag''$ which is same as $\frag'$, except that $\reachfromat{\outof{\frag''}} = (\reachfromat{\outof{\frag'}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset'$. 
\item add $\frag''$ to $\fragset_{post}$
\item add $\tt (v,v'')$ to $\tt R_6$
\end{itemize}
\end{itemize}
\item add $\tt \frag_{new}$ to $\fragset_{post}$ 
\end{enumerate}

\item for each fragment $\frag \in \fragset_2$ then we do as follows. for each $\tt (\frag_1,\frag_1') \in R_i$, $\tt (\frag_2,\frag_2') \in R_j$ where $\tt i \neq j$ and $\tt 1 \leq i,j \leq 6$. For each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\frag'$ which is same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inoneof{\frag_1'}}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\intwoof{\frag_2'}}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inoneof{\frag_1'}}$,
\item $\reachfromat{\outof{\frag'}} = \reachfromat{\intwoof{\frag_2'}}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inoneof{\frag_1'}}$,
\item $\reachtoat{\outof{\frag'}} =  \reachtoat{\intwoof{\frag_2'}}$,
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$. 


\newpage
 \end{itemize}
 
 \paragraph{Fragment Intersection:} Let us describe the intersection of two fragments $\tt \frag_1 \in \fragset_1$ and $\tt \frag_2 \in \fragset_2$ denoted as $\tt \frag_1 \sqcap \frag_2$. Firstly, we consider the case where both $\tt \frag_1$ and $\tt \frag_2$ have size 2.
 \begin{itemize}
 \item if $\tt \frag_1.greachfrom(i,\{1,2\}) \neq \emptyset$ and $\tt \frag_2.greachfrom(i,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(\frag_1, i) = gtag(\frag_2, i)$ and $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_{12}\}$ where $\tt \frag_{12}$ is same as $\tt \frag_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$ 
  \begin{itemize}
  \item $\tt \frag_{12}.vars(i) = \frag_1.vars(i) \cup \frag_2.vars(i)$ 
  \item  $\tt \pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_{12}.reachfrom(i,l) = \frag_{1}.reachfrom(i,l) \cup \frag_{2}.reachfrom(i,l)$
   \item $\tt \frag_{12}.reachfrom(i,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
 \end{itemize}

 \item if $\tt \frag_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_1.greachfrom(o,\{1,2\}) \neq \emptyset$ and $\tt \frag_2.greachfrom(o,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\tt \frag_1.private(i) = false$ and $\tt \frag_2.private(i) = false$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1', \frag_2', \frag_{12}\}$ where %$\tt \frag_{12}$ is same as $\tt \frag_1$ except that 
  $\tt \frag_1'$ is same as $\tt \frag_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$
    \begin{itemize}
  \item  $\tt \pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_1'.reachfrom(o,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
   and $\tt \frag_2'$ is same as $\tt \frag_2$ except that 
    \begin{itemize}
  \item  $\tt \pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_2'.reachfrom(o,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
     \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\tt \frag_1.private(i) = true$ or $\tt \frag_2.private(i) = true$) then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1', \frag_2'\}$ 
 \end{itemize}
 
 
  \item if $\tt \frag_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_1.greachfrom(o,\{1,2\}) = \emptyset$ and $\tt \frag_2.greachfrom(o,\{1,2\}) = \emptyset$ then 
 \begin{itemize}
 
 
 \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\tt \frag_1.private(i) = false$, $\tt \privateat{\outat{\frag_1}} = false$, $\tt \privateat{\outat{\frag_1}} = false$ and $\tt \privateat{\outat{\frag_2}} = false$ then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2',\frag_{12}\}$ %where $\tt \frag_{12}$ is same as $\tt \frag_1$ except that 
    \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, ($\tt \frag_1.private(i) = true$ or $\tt \frag_2.private(i) = true$) and $\tt \privateat{\outat{\frag_1}} = false$ and $\tt \privateat{\outat{\frag_2}} = false$ then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2'\}$  

  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\tt \privateat{\outat{\frag_1}} = true$ or $\tt \privateat{\outat{\frag_1}} = true$) then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$ 

    \item if $\tt gtag(\frag_1, o) \neq gtag(\frag_2, o)$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$
 \end{itemize}
 
 \end{itemize}



%
