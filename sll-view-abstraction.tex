%% \begin{center}
%% \begin{figure}
%% \input{sll-lazy-list-shape}
%% \caption{Example of Fragment Abstraction}
%% \label{lazylist}
%% \end{figure}
%% \end{center}
\section{Verification using Fragment Abstraction for Skiplists}
\label{sec:fragment-abstraction}
In the previous section, we reduced the problem of verifying linearizability
to the problem of verifying
that, in any execution of the cross-product of a program and an observer, 
the observer cannot reach an accepting location.
We perform this verification by  computing a symbolic representation
of an invariant that is satisfied by all reachable configurations of the cross-product,
using an abstract interpretation-based fixpoint procedure, starting
from a symbolic representation of the set of initial configurations,
thereafter repeatedly performing
symbolic postcondition computations that extend the
symbolic representation by the effect of any execution step of the program,
until convergence.

In Section~\ref{subsect:symbrep}, we
define in more detail our symbolic representation for skiplists,
focusing in particular on the use of fragment abstraction, and thereafter
(in Section~\ref{subsect:postcond})
describe the symbolic postcondition computation.
Since singly-linked lists is a trivial special case of skiplists, we can use
the relevant part of this technique also for programs based on singly-linked
lists.

%% The main novel contribution is our fragment abstraction for
%% representing the possible heap configurations of a concurrent program.
%% In this section, we describe this symbolic representation and our
%% verification technique
%% for programs that operate on singly-linked lists (SLLs). This
%% representation is also the basis for our representation for programs
%% operating on skiplists, described in Section~\ref{subsect:skiplists}
%% and programs operating on arrays of SLLs, in Section~\ref{subsect:skiplists}.

%% We describe our fragment abstractions for three classes of heap structures:
%% in the following subsection, we consider programs operating on singly-linked
%% lists, in Subsection~\ref{subsect:skiplists}, we consider programs operating
%% on skiplists, and in
%% Subsection~\ref{subsect:skiplists}, we consider programs operating
%% arrays of singly linked lists.


%% In the actual verification, we compute a symbolic representation
%% of an invariant that is satisfied by all reachable program configurations (including observer location).
%% This invariant is obtained by an abstract-interpretation-based
%% fixpoint procedure, which starts
%% from a representation of the set of initial configurations, and
%% thereafter repeatedly performs
%% postcondition computations that extend the
%% symbolic representation by the effect of any execution step of the program,
%% until convergence.
%% This analysis needs to deal with the challenges of an unbounded domain of
%% data values, an unbounded number of concurrently executing threads, and an
%% unbounded heap. 

\subsection{Symbolic Representation}
\label{subsect:symbrep}
%% \bjcom{Say that for now, we ignore timers?}
%% \bjcom{Introduce notation for the set of local $\ddomain$-variables?.
%%   Maybe define which threads we talk about?
%%   For now, we skip timestamps.
%% }
%% We assume that we must analyze the product of a program and an observer.
This subsection contains a more detailed description of our symbolic representation for programs that
operate on skiplists, which was introduced in Section~\ref{sec:overview}.
We first describe the data abstraction,
thereafter the fragment abstraction, and finally their combination
into a symbolic representation.

\vspace*{-0.6cm}
\subsubsection{Data Abstraction}
Our data abstraction is defined by assigning a
abstract domain to each concrete domain of data values, as follows.
%% For each thread-local variable, and each non-pointer cell field, which ranges
%% over some concrete domain, we define a corresponding abstract domain,
%% as follows.
\begin{itemize}
\item For small concrete domains (including that of the program counter, and
  of the observer location),
  the abstract domain is the same as the concrete one.
\item
  For locks, the abstract domain is $\set{\mathit{me},\mathit{other},\mathit{free}}$,
  meaning that the lock is held by the concerned thread, held by some other thread, or is
  free, respectively.
\item For the concrete domain $\ddomain$ of data values, the abstract domain
  is the set of mappings from observer registers and local variables
  ranging over $\ddomain$ to subsets of $\set{<,=,>}$.
  An mapping in this abstract domain represents the set of data values $\tt d$
  such that it maps each local variable and observer register with a value ${\tt d'} \in \ddomain$
  to a set which includes a relation $\sim$ such that $\tt d \sim \tt d'$.
\end{itemize}

\vspace*{-0.6cm}
\subsubsection{Fragment Abstraction}
Let us now define our fragment abstraction for skiplists.
For presentation purposes, we assume that each heap cell has at most one
$\ddomain$-field, named ${\tt data}$.
For an observer register $\reg_i$, let a {\em $\reg_i$-cell} be a heap cell whose
${\tt data}$ field has the same value as $\reg_i$.

Since the number of levels is unbounded, we define an abstraction for
levels.
Let $\klevel$ be a level.
Define the abstraction of a pointer variable of form $\tt p[k]$,
denoted $\abstrof{\mathtt{p[k]}}$,
to be $\tt p[1]$ if $\klevel = 1$, and to be  $\tt p[higher]$
if $\klevel \geq 2$.
That is, this abstraction does not distinguish different higher levels.

A {\em tag} is a tuple $\atag = \tagtuple$, where
\begin{inparaenum}[(i)]
\item
  $\vals$ is a mapping from non-pointer fields
  %% at level $\klevel$
  to their corresponding abstract domains;
  if a non-pointer field is an array indexed by levels, then
the abstract domain is that for single elements: e.g., the abstract
domain for the array ${\tt marked}$ in Figure~\ref{sl-code:fig} is simply the
set of booleans,
\item
  $\pvars$ is a set of abstracted pointer variables,
 \item
   $\reachfrom$ and $\reachto$ are sets of global pointer variables and observer registers, and
  \item $\private$ is a boolean value.
\end{inparaenum}

For a heap cell $\cell$ that is accessible to thread $\thread$ 
in a configuration $\sconf$, and a tag $\atag = \tagtuple$,
we let $\cell \lsatfrag{\klevel}{\thread}{\sconf} \atag$ denote that the
$\cell$ satisfies the tag $\atag$ ``at level $\klevel$''.
This means that
array fields of $\cell$ are considered at index $\klevel$. For instance,
for the array $\tt marked$, we consider the element $\tt marked[\klevel]$.
More precisly, this means that
\begin{itemize}
\item
  $\vals$ is an abstraction of the concrete values of the non-pointer fields of $\cell$ (for array fields $\tt f$ we use the concrete value $\tt f[k]$),
%%   is satisfied in the following sense:
%%   \begin{enumerate}[(i)]
%%     \item
%%       $\vals(\field) = \cellval(\cell,\field)$ for each each non-lock
%%       $\mathbb{F}$-field $\field$,
%%   \item
%%       for each lock field $\field$, we have
%%       $\vals(\field) = \mathit{me}$ if $\thread$ holds the lock,
%%       $\vals(\field) = \mathit{other}$ if some other thread holds the lock, and
%%       $\vals(\field) = \mathit{free}$ if the lock is free,
%%   and
%% \item
%%   for each $\intgrs$-field $\field$ and each
%%   observer register $x  \in \ovarset$ we have that
%%   $\vals(\field)(x)$ is $=$ iff $\cellval(\cell,\field)$ is equal to the value
%%   of $x$.
%% \bjcom{Should we also do that for local data and timestamp variables?}
%%   \end{enumerate}
\item
  $\pvars$ is the set of abstractions of pointer variables (global or
  local to $\thread$) that point to $\cell$,
\item
  $\reachfrom$ is the set of
  \begin{inparaenum}[(i)]
  \item abstractions of global pointer variables
    %% and local pointer variables of $\thread$
    from which $\cell$ is reachable via a (possibly empty)
    sequence of $\tt next[1]$ pointers, and
  \item observer registers $\reg_i$ such that $\cell$ is reachable from
    some $\reg_i$-cell (via a sequence of $\tt next[1]$ pointers),
  \end{inparaenum}
\item
  $\reachto$ is the set of
  \begin{inparaenum}[(i)]
  \item abstractions of global pointer variables
    %% and local pointer variables of $\thread$
    pointing to a cell that is reachable (via a sequence of $\tt next[1]$ pointers) from $\cell$, and
  \item observer registers $\reg_i$ such that some $\reg_i$-cell is reachable
    from $\cell$.
  \end{inparaenum}
\item
  $\private$ is $\true$ only if $\cell$ is 
not accessible to any other thread than $\thread$.
  %% $\private$ is $\true$ if
  %%  $\cell$ has never been published (by assigning a heap pointer-field or global pointer variable) by its creating thread $\thread$.
\end{itemize}
Thus, the global information represented by the fields $\reachfrom$ and
$\reachto$ concerns {\em only} reachability via level-1 pointers.

%% \begin{definition}[SLL-fragment]
%% \label{def:sll-fragment}
A {\em skiplist fragment} $\frag$ (or just fragment)
is a triple of form
$\fragtupleat{\frag}$, of form
$\tuple{\inat{\frag},\nullconst}$, or of form
$\tuple{\inat{\frag},\dangconst}$,
where $\inat{\frag}$ and $\outat{\frag}$ are tags
    and $\datarelat{\frag}$ is a subset of $\set{<, =, >}$.
    Each skiplist fragment additionally has a {\em type}, which is
    either {\em level-1} or {\em higher-level} (note that a level-1 fragment
    can otherwise be identical to a higher-level fragment).
For a cell $\cell$ which is accessible to thread $\thread$, and a fragment
$\frag$ of form $\fragtupleat{\frag}$, let $\cell \lsatfrag{\klevel}{\thread}{\sconf}\frag$ denote that
the ${\tt next[k]}$ field of $\cell$ points to a cell $\cell'$ such that
%% \begin{inparaenum}[(i)]
%% \item
  $\cell \lsatfrag{\klevel}{\thread}{\sconf} \inat{\frag}$,
and
%% \item
$\cell' \lsatfrag{\klevel}{\thread}{\sconf} \outat{\frag}$, and 
%% \item
  $\cell.\mathtt{data} \sim \cell'.\mathtt{data}$ for some $\sim \in \datarelat{\frag}$.
%% \end{inparaenum}
The definition of $\cell \lsatfrag{\klevel}{\thread}{\sconf}\frag$
is adapted to fragments of form
$\tuple{\inat{\frag},\nullconst}$ and $\tuple{\inat{\frag},\dangconst}$ in the
obvious way. For a fragment $\frag = \fragtupleat{\frag}$, we often use
$\inof{\frag}$ for $\inat{\frag}$, and
$\outof{\frag}$ for $\outat{\frag}$, etc.

%% For a fragment of form $\frag = \tuple{\inat{\frag},\nullconst}$, let
%% $\cell \satfrag{\thread}{\sconf} \frag$ denote that
%% $\cell \satfrag{\thread}{\sconf} \inat{\frag}$ and $\mathtt{next}(\cell) = \nullconst$.
%% Define $\cell \satfrag{\thread}{\sconf} \frag$ for $\frag$ of form $\tuple{\inat{\frag},\dangconst}$
%% analogously.
%% For $\tuple{\inat{\frag},\dangconst}$, the definition is adapted in the obvious way.

Let $\fragset$ be a set of fragments.
A global configuration $\sconf$ satisfies $\fragset$
wrp.\ to $\thread$, denoted  $\sconf \satfragset{\thread} \fragset$, if
\begin{itemize}
  \item for any cell $\cell$ that is accessible to $\thread$ (different from $\nullconst$ and $\bot$), there is a level-1 fragment
$\frag \in \fragset$ such that $\cell \lsatfrag{1}{{\thread}}{\sconf} \frag$,
    and
  \item
    for all levels $\klevel$ from $2$ up to the height of $\cell$, 
there is a higher-level fragment
$\frag \in \fragset$ such that $\cell \lsatfrag{\klevel}{{\thread}}{\sconf} \frag$.
\end{itemize}
Intuitively, a set of fragment represents the set of heap states, in which
each  pair of cells connected by a $\tt next[1]$ pointer is represented
by a level-1 fragment, and each pair of cells connected by a $\tt next[k]$
pointer for $\klevel \geq 2$ is represented by a higher-level fragment which 
represents array fields of cells at index $\klevel$.
%% Intuitively, a set of heap states is represented by a set of fragments, in which
%% the level-1 fragments represent pairs of cells connected by
%% a $\tt next[1]$ pointer, representing their array fields only at index
%% $\klevel$,
%%  and the higher-level fragments represent pairs of cells connected by
%% a $\tt next[k]$ pointer for some $\klevel \geq 2$, representing their
%% array fields only at index $\klevel$.

\subsubsection{Symbolic Representation}
We are now ready to define our abstract symbolic representation.
%% , which
%% is defined as a partial mapping from local symbolic
%% configurations and observer locations to sets of fragments. 

Define a {\em local symbolic configuration} $\locsymbconf$ to be
a mapping from local non-pointer
variables (including the program counter) to their corresponding abstract
domains.
We let $\sconf \satlocsymbconf{\thread} \locsymbconf$ denote that in the
global configuration $\sconf$, the
local configuration of thread $\thread$ satisfies the local symbolic
configuration $\locsymbconf$, defined in the natural way.
For a local symbolic configuration
$\locsymbconf$, an observer location $\ostate$, a pair
$\fragset$ of fragments and a thread $\thread$, we write
$\sconf \satconf{\thread}
\tuple{\locsymbconf,\ostate,\fragset}$ to denote that
\begin{inparaenum}[(i)]
\item $\sconf \satlocsymbconf{\thread} \locsymbconf$,
\item the observer is in location $\ostate$, and
\item  $\sconf \satfragset{\thread} \fragset$.
\end{inparaenum}
\begin{definition}
  \label{def:symbrep}
    A {\em symbolic representation} $\symbrep$ is a partial mapping from
pairs of local symbolic configurations and observer locations to
sets of fragments.
A system configuration $\sconf$ satisfies a symbolic representation $\symbrep$,
denoted $\sconf \satsymbrep \symbrep$,
if for each thread $\thread$, 
the domain of $\symbrep$ contains a pair
$\tuple{\locsymbconf,\ostate}$ such that
$\sconf \satconf{\thread}
\tuple{\locsymbconf,\ostate,\symbrep(\tuple{\locsymbconf,\ostate})}$.
\end{definition}
%% For a local symbolic  configuration $\locsymbconf$ and set $\fragset$ of
%% fragments, we write
%% $\conf \satconf{\thread} \tuple{\locsymbconf,\fragset}$ to denote that
%% that $\conf \satlocsymbconf{\thread} \locsymbconf$
%% and


%% \begin{itemize}
%% \item
%%   $\pvarsofth{\cell}{\thread} = \pvars$,
%% \item
%%   $\valsofth{\cell}{\thread} = \vals$,
%% \item
%%   $\reachfromofth{\cell}{\thread} = \reachfrom$,
%% \item
%%   $\reachtoofth{\cell}{\thread} = \reachto$,
%%   and
%% \item
%%   if $\private$ is true then $\cell$ is not accessible from any thread other
%%   than $\thread$.
%% \end{itemize}
%% We can now define the notion of fragment.q

%% A {\em symbolic configuration} is a pair
%% $\tuple{\locsymbconf,\fragset}$ consisting of a local symbolic 
%% configuration $\locsymbconf$, and a set $\fragset$ of fragments.
%% A configuration $\conf$ of a program satisfies a symbolic configuration
%% $\tuple{\locsymbconf,\fragset}$ if for each thread $\thread$,
%% \begin{itemize}
%% \item the local configuration of $\thread$ satisfies $\locsymbconf$, in the
%%   natural way, and
%% \item for each $\cell$ that is accessible from $\thread$, there is
%%   a fragment $\frag$ such that $\cell \satfrag{\thread}{\sconf}_{\thread} \frag$.
%% \end{itemize}






%% \todo[inline]{What to replace the below example with?}
%% \paragraph{Example:} Let us show an example of how a singly linked list (SLL) is split into a set of fragments. Fig.~\ref{lazylist}(a) shows an example of a concrete shape of a singly linked list. Each cell contains the values of $\tt val$, $\tt mark$, and $\tt lock$ from top to bottom, where \tick \; denotes $\tt true$, and \cross \; denotes $\tt false$ (or $\tt free$ for $\tt lock$) and the value of $\tt val$ is denoted by a pair of the observer register $\tt z$ and a subset of $\set{<, =, >}$. There are two threads $1$ and $2$ with two local variables $\tt c_1$ and $\tt c_2$. There are two global variables $\tt H$ and $\tt T$ pointing to the head and tail of the list. The observer register $\tt z$ has value 8. Fig.~\ref{lazylist}(b) shows the result of splitting the list in Fig.~\ref{lazylist}(a) into fragments where each heap fragment is a small list of two nodes. Fig.~\ref{lazylist}(c) shows the abstraction of fragments in Fig.~\ref{lazylist}(b) where for each cell $\cell$, the value of $val$ is abstracted to a subset in $\tt \{<z, =z, >z\}$, the reachability relation between $\cell$ and global variables and observer registers is abstracted to the predicate $\tt X \mapsto \tt Y$ where $\tt X$, $\tt Y$ are sets of global variables and observer registers, $\tt i$ or $\tt o$ states that $\cell$ is an input or output cell.


\subsection{Symbolic Postcondition Computation}
\label{subsect:postcond}
%% In the  verification, we must compute an invariant in the form
%% of a symbolic representation
%% which is satisfied by all reachable program configurations.
%% %% (including observer states).
%% Such an invariant is obtained by an abstract interpretation-based
%% fixpoint procedure, which starts
%% from a representation of the set of initial configurations, and
%% thereafter repeatedly performs postcondition computations that extend the
%% symbolic representation by the effect of any execution step of the program,
%% until convergence.
%% We will now describe the symbolic postcondition computation.
%% \bjcom{The following should be included more smoothly, if really needed}
%% Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$.

%% Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
  
%% $\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. 

%% We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments, and any heap is ``broken down into pre-defined fragments''. A fragment retains the information about a particular part of a heap. This choice of fragments defines the level of abstraction that transforms heap into fragments. The abstract function $\alpha_k$ maps a heap into a set of fragments. Whereas, the concretization function $\gamma_k$ inputs a set of fragments, and returns the set of heaps that can be reconstructed from these fragments. 

%% \paragraph{Fragment Definition:} A heap fragment of size $\tt k$ is represented as \begin{center}
%% 	${\tt v} = \viewconf$ where 
%% \end{center} 

%We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments parameterized by a constant $\tt k$, and any heap is “broken down into pieces” of size (at most) k, called fragments. A fragment retains the information about $\tt k$ connected cells from a heap and abstracts away the other cells. This choice defines the level of abstraction that transforms heap into fragments.There is a certain freedom in what information to retain and what to abstract away. The abstract function $\alpha_k$ maps a heap into a set of heap fragments of sizes $\tt k$. The concretization function $\gamma_k$ inputs a set of heap fragments, and returns the set of heaps that can be reconstructed from the these fragments. Let us represent symbolic representations of heap fragments. A heap fragment of size $\tt k$ is represented as ${\tt \Omega} = \viewconf$ where 

%\paragraph{Abstract Configuration}:
%A abstract {\it configuration} of a program $\prog$ in the fragment of a single thread $\thread$
% is a tuple
%$\tuple{\tt c,\lambda, \Omega , S}$ where
%\begin{itemize}
%\item $\tt c$ is an observer configuration, 
%\item $\lambda$ is the label of the program statement, 
%\item $\tt \Omega$ is a tuple $\tt \tuple{\Omega_p, \Omega_l, Val}$ where $\tt \Omega_p$ contains a set ordering constrains between pointer variables, $\tt \Omega_l$ contains a set ordering constrains between data local variables and $\tt Val$ maps each data local variable to its value.
%\item $\tt S$ is a set of fragments.
%\end{itemize}
%
%% We use $\confsetof\prog$ to denote the set of configurations

The symbolic postcondition computation must ensure that the symbolic
representation
of the reachable configurations of a program is closed under execution of a
statement by some thread. That is,
given a symbolic representation $\symbrep$,
the symbolic postcondition operation must produce an extension $\symbrep'$
of $\symbrep$, such that whenever $\sconf \satsymbrep \symbrep$
and $\sconf\movesto{\system}{}\sconf'$ then
${\sconf}' \satsymbrep \symbrep'$.
Let $\thread$ be an arbitrary thread. Then $\sconf \satsymbrep \symbrep$
means that $\domof{\symbrep}$ contains some
pair $\tuple{\locsymbconf,\ostate}$ with
$\sconf \satconf{\thread} \tuple{\locsymbconf,\ostate,\symbrep(\tuple{\locsymbconf,\ostate})}$.
The symbolic postcondition computation must ensure that
%% this property still holds after any execution of a
%% statement by some thread, i.e., that
$\domof{\symbrep'}$ contains a pair
$\tuple{\locsymbconf',\ostate'}$ such that
$\sconf' \satconf{\thread} \tuple{\locsymbconf',\ostate',\symbrep(\tuple{\locsymbconf',\ostate'})}$.
%% from which a step $\sconf \movesto{\system} {\sconf}'$, then ${\sconf}' \satsymbrep \symbrep'$.
%% More precisely, assume that a global configuration $\conf$ satisfies
%% a symbolic representation $\symbrep$. Let $\thread$ be an arbitrary thread.
%% Assume that there is
%% a local symbolic configuration $\locsymbconf \in \domof{\symbrep}$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$.
%% it is still the case that
%% $\domof{\symbrep}$ contains a local symbolic configuration 
%% $\locsymbconf'$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf',\symbrep(\locsymbconf)}$
%% for some thread $\thread$.
In the thread-modular approach, there are two cases to consider, depending
on which thread causes the step from $\sconf$ to ${\sconf}'$.
\begin{itemize}
\item
  {\it Local Steps:} The step
  is caused by $\thread$ itself executing a statement
  which may change its local state, the location of the observer,
  and the state of the heap.
  In this case, we first compute a local symbolic configuration $\locsymbconf'$,
  an observer location $\ostate'$, and a set $\fragset'$ of fragments such that
$\sconf' \satconf{\thread} \tuple{\locsymbconf',\ostate',\fragset'}$,
  and then (if necessary) extend $\symbrep$ so that
  $\tuple{\locsymbconf',\ostate'} \in \domof{\symbrep}$ and
  $ \fragset' \subseteq \symbrep(\tuple{\locsymbconf',\ostate'})$.
\item
  {\it Interference Steps:} The step is caused by another thread $\thread_2$,
  which may change the location of the observer (to $\ostate'$)
  and the state of the heap.
%%   such a way that makes it necessary to extend $\symbrep(\locsymbconf)$.
  By $\sconf \satsymbrep \symbrep$
  there is a local symbolic configuration $\locsymbconf_2$
  with $\tuple{\locsymbconf_2,\ostate} \in \domof{\symbrep}$ such that
  $\sconf \satconf{\thread_2} \tuple{\locsymbconf_2,\ostate,\symbrep(\tuple{\locsymbconf_2,\ostate})}$.
  For any such $\locsymbconf_2$ and statement of $\thread_2$,
  we must compute a set $\fragset'$ of fragments such that
  the resulting configuration ${\sconf}'$ satisfies
  $\sconf' \satfragset{\thread} \fragset'$ and 
  make sure that $\tuple{\locsymbconf,\ostate'} \in \domof{\symbrep}$ and
  $\fragset' \subseteq \symbrep(\tuple{\locsymbconf,\ostate'})$.
  To do this, we first combine the the local symbolic configurations
  $\locsymbconf$ and $\locsymbconf_2$ and the sets of fragments
  $\symbrep(\tuple{\locsymbconf,\ostate})$ and
  $\symbrep(\tuple{\locsymbconf_2,\ostate})$, using an
%%   of $\thread_1$ and $\thread_2$ and then compute a representation of the
%%   the possible heaps whose projection onto $\thread_i$ satisfies
%%   $\symbrep(\locsymbconf_i)$ for $i=1,2$.
%% This is done by performing an
  operation called {\em intersection}, into
  a joint local symbolic configuration of $\thread$ and $\thread_2$ and
  a set $\fragset_{1,2}$ of fragments that represents the cells accessible
  to either $\thread$ or $\thread_2$.
  We thereafter symbolically compute the postcondition of the statement
  executed by $\thread_2$, in the same was as for local steps,
  and finally project the set of resulting fragments back onto $\thread$
  to obtain $\fragset'$.
\end{itemize}
In the following, we first describe the symbolic postcondition computation for
local steps, and thereafter the intersection operation.


\subsubsection{Symbolic Postcondition Computation for Local Steps}
Let $\thread$ be an arbitrary thread, and assume
that $\tuple{\locsymbconf,\ostate} \in \domof{\symbrep}$.
Let $\fragset = \symbrep(\tuple{\locsymbconf,\ostate})$
For each statement that $\thread$ can execute in a configuration $\sconf$
with $\sconf \satconf{\thread} \tuple{\locsymbconf,\ostate,\fragset}$,
we must compute a local symbolic configuration $\locsymbconf'$, a new
observer location $\ostate'$ and a set  $\fragset'$ of fragments
such that the resulting configuration ${\sconf}'$ satisfies
$\sconf' \satconf{\thread} \tuple{\locsymbconf',\ostate',\fragset'}$.
This computation is done differently for
each statement. For statements that do not affect the heap or pointer variables,
this computation is standard, and affects only the local symbolic
configuration, the observer location, and the $\vals$ component of
tags.
We therefore here describe how to compute the effect of statements that update
pointer variables or pointer fields of heap cells,
since these are the most interesting cases.
In this computation, the set $\fragset'$ is constructed in two steps:
\begin{inparaenum}[(1)]
\item First, the level-1 fragments of $\fragset'$ are computed, based on
  the level-1 fragments in $\fragset$.
\item
  Thereafter, the higher-level fragments of $\fragset'$ are computed, based
  on the higher-level fragments in $\fragset$ and
  how fragments in $\fragset$ are transformed
  when entered in to $\fragset'$.
\end{inparaenum}
We first describe the construction of level-1 fragments, and thereafter the
construction of higher-level fragments.

\paragraph{{\bf Construction of level-1 fragments}}
Let us first motivate some techniques used for constructing the level-1 fragments
of $\fragset'$. Consider a statement of form $\gvarof{g} := \lvarof{p}$,
which assigns the value of a local pointer variable $\lvarof{p}$ to a global
pointer variable $\gvarof{g}$. The set $\fragset'$ of fragments is obtained by
modifying fragments in $\fragset$ to reflect the effect of the assignment. 
For any tag in a fragment, the $\vals$ field is not affected.
The $\pvars$ field  is updated to contain the variable $\gvarof{g}$ if and only if it contained the variable $\lvarof{p}$ before the statement. 
The difficulty is to update the reachability information represented
by the fields $\reachfrom$ and $\reachto$,
and in particular to determine whether $\gvarof{g}$ should be in such a
set after the statement
(note that if $\lvarof{p}$ were a global variable, then the corresponding
reachability information for $\lvarof{p}$ would be in the fields
$\reachfrom$ and $\reachto$, and the update would be simple,
reflecting that $\gvarof{g}$ and $\lvarof{p}$ become aliases).
In order to constructe $\fragset'$ with sufficient precision, we
%% However, since the $\reachfrom$ field does not include local variables, we
therefore investigate whether the set of fragments $\fragset$
allows to form a heap in which a $\lvarof{p}$-cell can reach or be
reached from (by a sequence of $\tt next[1]$ pointers)
a particular tag of a fragment.
It also investigates whether a heap can be formed
in which a $p$-cell can {\em not} reach or be reached from a particular tag.
For each successful and each unsuccessful investigation,
the set $\fragset'$ will contain a level-1 fragment with
corresponding contents of its $\reachto$ and $\reachfrom$ fields.

Let us describe how the postcondition computation performs this investigation.
It does so by computing a set of transitive closure-like relations
between level-1 fragments. This computation considers only reachability
using $\tt next[1]$ pointers, since only these are relevant for the
$\reachfrom$ and $\reachto$ tags.
First, say that two tags
$\atag$ and $\atag'$ are {\em consistent}
(wrp.\ to a set of fragments $\fragset$) if the concretizations of their
$\vals$-fields overlap, and if the other fields
$\pvars$, $\reachfrom$, $\reachto$, and $\private$) agree.
Thus, $\atag$ and $\atag'$ are consistent if there can exist a cell
$\cell$ accessible to $\thread$ in some heap,
with $\cell \satfrag{\thread}{\sconf} \atag$
and $\cell \satfrag{\thread}{\sconf} \atag'$.
%% \todo[inline]{To Quy: Can you really require that the data abstrations must
%%   be the same?}
Next, for two level-1 fragments $\frag_1$ and $\frag_2$ in a
set $\fragset$ of fragments,
\begin{itemize}
\item let $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denote that $\outof{\frag_1}$   and $\inof{\frag_2}$ are consistent, and
  %% \todo[inline]{Quy: PLEASE  you provide the precise definition of when
  %%   $\tagat{\outof{\frag_1}}$ and $\tagat{\inof{\frag_2}}$ are consistent?}
  %% \quycom{They are consistent if they have same $\reachfrom$, $\reachto$, $\pvars$, $\private$, $\data$. This is for local thread. When we check for consistent between two tags when doing intersection, we have to define differently.}  
\item let $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denote that $\outof{\frag_1} = \outof{\frag_2}$ are consistent, and that either
  $\pvarsat{\inof{\frag_1}} \cap \pvarsat{\inof{\frag_2}} = \emptyset$ or
  the global variables in  $\reachfromat{\inof{\frag_1}}$ are disjoint from
  those in $\reachfromat{\inof{\frag_2}}$.

%%   \quycom{$\reachfromat{\inof{\frag_1}} \cap \reachfromat{\inof{\frag_2}} = \emptyset$ here is not correct, we only need the global variables of reachfrom and reachto in this case}
%% \quycom{In my definition, the consistent here is defined for two views in the same threads. With the view from other thread, I use the notion of intersection.}
\end{itemize}
Intuitively, $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denotes that it is
possible that  $\cell_1.{\tt next[1]} = \cell_2$ for some cells with
  $\cell_1 \lsatfrag{1}{{\thread}}{\sconf} \frag_1$ and
  $\cell_2 \lsatfrag{1}{{\thread}}{\sconf} \frag_2$.
Intuitively, $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denotes that it is
possible that
  $\cell_1.{\tt next[1]} = \cell_2.{\tt next[1]}$
for different cells  $\cell_1$ and $\cell_2$ with
  $\cell_1 \lsatfrag{1}{{\thread}}{\sconf} \frag_1$ and
  $\cell_2 \lsatfrag{1}{{\thread}}{\sconf} \frag_2$
(Note that these definitions also work for fragments containing
$\nullconst$ or $\dangconst$).
We use these relations to define the following derived relations on level-1 fragments:
%% \bjcom{We could use a common pattern for these and save space in definitions.}
\begin{itemize}
\item $\overset{+}\hookrightarrow_{\fragset}$ denotes the transitive closure,
%%   of   $\hookrightarrow_{\fragset}$,
  and
   $\overset{*}\hookrightarrow_{\fragset}$ the reflexive transitive closure, of
  $\hookrightarrow_{\fragset}$,
\item $\frag_1 \!  \overset{**}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that 
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{*+}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1', \frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{*\circ}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that $\exists \frag_1' \in \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1'$,
\item $\frag_1 \!  \overset{++}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{+*}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{+\circ}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1' \in \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1'$.
\end{itemize}
We say that $\frag_1$ and $\frag_2$ are {\em compatible} if $\frag_x \overset{*}\hookrightarrow \frag_y$, or $\frag_y \overset{*}\hookrightarrow \frag_x$, or $\frag_x \overset{**}\leftrightarrow \frag_y$. Intuitively, if $\frag_1$ and
$\frag_2$ are satisfied by two cells in the same heap state, then they must
be compatible.

\input viewrelations
Figure~\ref{fig:viewrelations} illustrates the above relations for a heap state
with $13$ heap cells. The figure depicts in green
four pairs of heap cells connected by a $\tt next[1]$ pointer, which satisfy
the four fragments $\frag_1$, $\frag_2$, $\frag_3$, and $\frag_4$, respectively.
At the bottom are depicted the transitive-closure like relations that hold
between these fragments.

We can now describe the symbolic postcondition computation for
statements that affect pointer variables or fields. This is a long
case analysis, which is described in full in Appendix~\ref{app:skiplists}.
For space reasons, hwere we only include some representative cases.

First, consider a statement of form
${\tt x := y}$, where $\mathtt{x}$ and $\mathtt{y}$ are local
(to thread $\thread$) or global pointer variables.
We must compute a set $\fragsetpost$ of
fragments which are satisfied by the configuration after the statement.
This modification is first performed for
level-1-fragments and only thereafter for higher-level fragments.
So, let us consider how to generate the level-1 fragments in $\fragset'$. This
means that for any cell $\cell$ which is accessible to $\thread$ after
the statement, there must be some level-1 fragment $\frag'$ in $\fragsetpost$
with $\cell \lsatfrag{1}{\thread}{\sconf} \frag'$
By assumption, $\cell$ satisfies some fragment $\frag$ in $\fragset$
before the statement, and is in the same heap state as the cell pointed to by
$\gvarof{y}$.
This implies that $\frag$ must be compatible with some
fragment $\frag_y\in\fragset$ such that $\abstrof{\mathtt{y}} \in \pvarsat{\inof{\frag_y}}$. This means that we can make a case analysis on the possible relationships
between $\frag$ and any such $\frag_y$.
Thus, for each fragment $\frag_y\in\fragset$ such that
$\abstrof{\mathtt{y}} \in \pvarsat{\inof{\frag_y}}$ we let $\fragsetpost$ contain
the fragments obtained by any of the following transformations on any fragment in
$\fragset$.
\begin{enumerate}
\item
First, for the fragment $\frag_y$ itself, we let $\fragsetpost$ contain
$\frag_y'$, which is the same as $\frag_y$, except that
%% Let $\tt kill(x,v)$ be the procedure to remove $\tt x$ if it exists from
%% $\reachfromat{\inof{\frag}}$,
%% $\reachfromat{\outof{\frag}}$,
%% $\reachtoat{\inof{\frag}}$,
%% $\reachtoat{\outof{\frag}}$,
%% $\pvarsat{\inof{\frag}}$, and
%% $\pvarsat{\outof{\frag}}$.
\begin{itemize}
\item $\pvarsat{\inof{\frag_y'}} = \pvarsat{\inof{\frag_y}} \cup \set{\abstrof{\mathtt{x}}}$ and
  $\pvarsat{\outof{\frag_y'}} = \pvarsat{\outof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$
\end{itemize}
and furthermore, if $\gvarof{x}$ is a global variable, then
{\small
  \begin{itemize}
\item $\reachtoat{\inof{\frag_y'}} = \reachtoat{\inof{\frag_y}} \cup \set{\abstrof{\mathtt{x}}}$ and
$\reachfromat{\inof{\frag_y'}} = \reachfromat{\inof{\frag_y}} \cup \set{\abstrof{\mathtt{x}}}$,
\item $\reachfromat{\outof{\frag_y'}} = \reachfromat{\outof{\frag_y}} \cup \set{\abstrof{\mathtt{x}}}$ and
$\reachtoat{\outof{\frag_y'}} = \reachtoat{\outof{\frag_y}} \setminus \set{\abstrof{\mathtt{x}}}$.
\end{itemize}
}
\item  for each fragment $\frag$ with $\frag \hookrightarrow_{\fragset} \frag_y$, let $\fragsetpost$ contain $\frag'$ which is the same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$,
\item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \cup \set{\abstrof{\mathtt{x}}}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \cup \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \cup \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \cup \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
\end{itemize}
  (Recall that $\abstrof{\mathtt{x}}$ is the abstraction of $\mathtt{x}$, which
  in the case that $\mathtt{x}$ is an array element
  maps higher levels to the same   abstract index $\tt higher$.)
\item We perform analogous inclusions for fragments $\frag$ with
  $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$,
  $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$,
  $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$, and
  $\frag_y \overset{*\circ}\leftrightarrow_{\fragset} \frag$. All of these
  cases are described in Appendix~\ref{app:skiplists}.
Here,
  we show only the case of $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$,
  in which case we let $\fragsetpost$ contain $\frag'$ which is the same as $\frag$ except that $\abstrof{\mathtt{x}}$ is removed from the sets
$\pvarsat{\inof{\frag'}}$,
$\pvarsat{\outof{\frag'}}$,
$\reachfromat{\inof{\frag'}}$,
$\reachtoat{\inof{\frag'}}$,
$\reachfromat{\outof{\frag'}}$, and
$\reachtoat{\outof{\frag'}}$.
 %
 %% \begin{itemize}
%% \item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$,
%% \item $\pvarsat{\outof{\frag'}} = \pvarsat{\outof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$,
%% \item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
%% \item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
%% \item $\reachfromat{\outof{\frag'}} = \reachfromat{\outof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
%% \item $\reachtoat{\outof{\frag'}} = \reachtoat{\outof{\frag}} \setminus \set{\abstrof{\mathtt{x}}}$ if $\tt x$ is a global variable,
%% \end{itemize}
\end{enumerate}
The statement ${\tt x := y.next}$ is handled rather similarly to the 
case ${\tt x := y}$.
Let us therefore describe the postcondition computation for statements of the form
${\tt x.next:= y}$.
This is the most difficult statement, since it is a destructive update of the heap. It affects reachability relations for both $\gvarof{x}$ and $\gvarof{y}$.
The postcondition computation makes a case analysis on how a fragment
in $\fragset$ is related to some pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inof{\frag_x}}$, $\tt y \in \pvarsat{\inof{\frag_y}}$. 
Thus, for each pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inof{\frag_x}}$ and $\tt y \in \pvarsat{\inof{\frag_y}}$, it is first checked whether the statement may form
a cycle in the heap. This may happen if
$\frag_y \overset{*}\hookrightarrow_{\fragset}\frag_x$, in which case the postcondition reports a potential cycle.
Otherwise, we let $\fragsetpost$ contain
the fragments obtained by the following transformations on fragments in
$\fragset$.
\begin{enumerate}
  \item
    First, let $\fragsetpost$ contain a new fragment $\frag_{new}$, representing
    the new pair of neighbours formed by the statement, of form
    $\frag_{new} = \fragtupleat{\frag_{new}}$ such that
    $\tagat{\inof{\frag_{new}}} = \tagat{\inof{\frag_x}}$ and
    $\tagat{\outof{\frag_{new}}} = \tagat{\inof{\frag_y}}$ except that
    $\reachfromat{\outof{\frag_{new}}} = \reachfromat{\inof{\frag_y}} \cup \reachfromat{\inof{\frag_x}}$ and
    $\reachtoat{\inof{\frag_{new}}} = \reachtoat{\inof{\frag_y}} \cup \pvarsat{\inof{\frag_x}}$.
    The possible relations in $\datarelof{\frag_{new}}$ are obtained by
    considering the possible transitive closure-relations between
    $\frag_x$ and $\frag_y$, some of which imply that the data field of
    $\frag_x$ and $\frag_y$ are ordered.
  \item
    Thereafter, we add all possible fragments that can result from a transformation
of some fragment $\frag \in \fragset$. This is done by an exhaustive
case analysis on the possible
relationships between $\frag$, $\frag_x$ and $\frag_y$.
Let us consider an interesting case, in which
$\frag_x \overset{*}\hookrightarrow_{\fragset} \frag$ and either $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*+}\leftrightarrow \frag$.
In this case, 
\begin{itemize}
\item
  for each subset $\regset$ of the observer registers in $\tt \reachfromat{\inof{\frag_x}}$, and for each subset $\regset'$ of the set of observer registers in
  $\reachfromat{\outof{\frag}} \cap \reachfromat{\inof{\frag_x}}$,
  we let $\fragsetpost$ contain a fragment $\frag'$ which is the same as $\frag$
  except that
%%   \bjcom{Don't we have: $\tt \reachfromat{\inof{\frag_x}} \subseteq \reachfromat{\inof{\frag}}$?}
$\reachfromat{\inof{\frag'}} = (\tt \reachfromat{\inof{\frag}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset$ and $\reachfromat{\outof{\frag'}} = (\reachfromat{\outof{\frag}} \setminus \reachfromat{\inof{\frag_x}}) \cup \regset'$. 
\end{itemize}
\end{enumerate}

\paragraph{{\bf Construction of higher-level fragments}}
Based on this construction of level-1 fragments, higher-level fragments
in $\fragset'$ are    constructed as follows.
     For each higher level-fragment $\frag \in \fragset$, let
     $\frag_1$ and $\frag_2$ be level 1-fragments such that
     $\tagat{\inof{\frag_1}} = \tagat{\inof{\frag}}$ and
     $\tagat{\inof{\frag_2}} = \tagat{\outof{\frag}}$.
     For any fragments $\frag_1'$ and $\frag_2'$ that are derived from
     $\frag_1$ and $\frag_2$, respectively, we add a higher-level
     fragment $\frag'$ to $\fragset_{post}$
     which is the same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inof{\frag'}} = \pvarsat{\inof{\frag_1'}}$ and
$\pvarsat{\outof{\frag'}} = \pvarsat{\inof{\frag_2'}}$,
\item $\reachfromat{\inof{\frag'}} = \reachfromat{\inof{\frag_1'}}$ and
$\reachfromat{\outof{\frag'}} = \reachfromat{\inof{\frag_2'}}$,
\item $\reachtoat{\inof{\frag'}} = \reachtoat{\inof{\frag_1'}}$ and
$\reachtoat{\outof{\frag'}} =  \reachtoat{\inof{\frag_2'}}$.
\end{itemize}



\subsubsection{Symbolic Postcondition Computation for Interference Steps} 
Here, the key step is the {\em intersection} operation, which
takes two sets of fragments
$\fragset_1$ and $\fragset_2$, and produces a set of joint fragments
$\fragset_{1,2}$, such that
$\sconf \satfragset{\thread_1,\thread_2} \fragset_{1,2}$ for any configuration
such that
$\sconf \satfragset{\thread_i} \fragset_i$ for $i=1,2$.
This means that for each heap cell accessible to either
$\thread_1$ or $\thread_2$, the set $\fragset_{1,2}$ 
contains a fragment $\frag$ with $\cell \lsatfrag{\klevel}{\{\thread_1,\thread_2\}}{\sconf} \frag$ for each $\klevel$ which is at most the height of $\cell$
(generalizing the notation  $\lsatfrag{\klevel}{\thread}{\sconf}$ to several
threads).
Note that a joint fragment represents local pointer variables of
both $\thread_1$ and $\thread_2$. In order to distinguish
between local variables of $\thread_1$ and $\thread_2$, one can, e.g.,
use a notation of form
$\lvarof{x[i]}$ for a local variable $\lvarof{x}$ of thread $\thread_i$.
Here, we describe the intersection operation for level-1 fragments. The
intersection operation is analogous for higher-level fragments.

For a fragment $\frag$, define
$\greachfromat{\inof{\frag}}$ as the set of global variables in
$\reachfromat{\inof{\frag}}$. Define
$\greachtoat{\inof{\frag}}$,
$\greachfromat{\outof{\frag}}$,
$\greachtoat{\outof{\frag}}$,
$\gpvarsat{\inof{\frag}}$, and
$\gpvarsat{\outof{\frag}}$
analogously.
Define $\gtagat{\inof{\frag}}$ as the tuple
$\tuple{\valsat{\inof{\frag}},\gpvarsat{\inof{\frag}},\greachfromat{\inof{\frag}},\greachtoat{\inof{\frag}}}$, and define
$\gtagat{\outof{\frag}}$ analogously.
%% \todo[inline]{Question to Quy: You have also used the notation
%%   $\gvalsat{\inof{\frag}}$. Will you need it, and if so what does it mean?} \quycom{Because in the data, I add data constraint between data fields and local data variable. When we do intersection, we do not need to care about this constraint because its local constraint}
We must distinguish the following possibilities.
\begin{itemize}
\item If $\cell$ is accessible to both $\thread_1$ and $\thread_2$, then
  there are fragments $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$
  such that $\cell \lsatfrag{1}{\thread_1}{\sconf} \frag_1$ and $\cell \lsatfrag{1}{\thread_2}{\sconf} \frag_2$.
  This can happen only if
 %% $\greachfromat{\inof{\frag_1}} \neq \emptyset$ and $\greachfromat{\inof{\frag_2}} \neq \emptyset$ then the global information in $\frag_1$ and $\frag_2$ must coincide. This means that we must have
  $\gtagat{\inof{\frag_1}} = \gtagat{\inof{\frag_2}}$,
  and $\gtagat{\outof{\frag_1}} = \gtagat{\outof{\frag_2}}$,
  and $\privateat{\inof{\frag_1}} = \privateat{\inof{\frag_2}} = \false$.
  Thus, for any such pair of fragments
  $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$, we let
  $\fragset_{1,2}$ contain a fragment
 $\frag_{12}$ which is identical to $\frag_1$ except that
  \begin{itemize}
  \item $\pvarsat{\inof{\frag_{12}}} = \pvarsat{\inof{\frag_1}} \cup \pvarsat{\inof{\frag_2}}$, 
  \item  $\pvarsat{\outof{\frag_{12}}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$,
  \item $\reachfromat{\inof{\frag_{12}}} = \reachfromat{\inof{\frag_{1}}} \cup \reachfromat{\inof{\frag_{2}}}$, and
   \item $\reachfromat{\outof{\frag_{12}}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$.
    \end{itemize}
\item If $\cell$ is accessible to $\thread_1$, but not to $\thread_2$, and
  $\cell.{\tt next[1]}$ is accessible also to $\thread_2$, then
  there are fragments $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$
  such that $\cell \lsatfrag{1}{\thread_1}{\sconf} \frag_1$ and
  $\cell.{\tt next[1]} \lsatfrag{1}{\thread_2}{\sconf} \outof{\frag_2}$.
  This can happen only if
  $\greachfromat{\inof{\frag_1}} =  \emptyset$,
  and $\gtagat{\outof{\frag_1}} = \gtagat{\outof{\frag_2}}$,
  and $\privateat{\outof{\frag_1}} = \privateat{\outof{\frag_2}} = \false$.
  Thus, for any such pair of fragments
  $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$, we let
  $\fragset_{1,2}$ contain a fragment
 $\frag_{1}'$ which is identical to $\frag_1$ except that
    \begin{itemize}
  \item  $\pvarsat{\outof{\frag_1'}} = \pvarsat{\outof{\frag_1}} \cup \pvarsat{\outof{\frag_2}}$, and
  \item $\reachfromat{\outof{\frag_1'}} = \reachfromat{\outof{\frag_{1}}} \cup \reachfromat{\outof{\frag_{2}}}$.
    \end{itemize}
\item
  If neither $\cell$ nor
  $\cell.{\tt next[1]}$  is accessible  $\thread_2$, then
  there is a  fragment $\frag_1 \in \fragset_1$
  such that $\cell \lsatfrag{1}{\thread_1}{\sconf} \frag_1$.
  This can happen only if
  $\greachfromat{\outof{\frag_1}} = \emptyset$,
  in which case we let  $\fragset_{1,2}$ contain the fragment
  $\frag_1$.
\item
  For each of the two last cases, there is also a symmetric case with the
  roles of $\thread_1$ and $\thread_2$ reversed.
\end{itemize}



