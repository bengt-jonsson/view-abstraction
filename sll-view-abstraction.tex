%% \begin{center}
%% \begin{figure}
%% \input{sll-lazy-list-shape}
%% \caption{Example of Fragment Abstraction}
%% \label{lazylist}
%% \end{figure}
%% \end{center}
\section{Fragment Abstraction: Singly Linked Lists}
\label{sec:fragment-abstraction}
In this section, we describe in more detail our fragment abstraction for
concurrent programs that operate on a shared heap.
We consider a program with global variables $\glvarset$ and
thread-local variables $\locvarset$.
We assume that all global variables are pointer variables.
We describe our fragment abstractions for three classes of heap structures:
in the following subsection, we consider programs operating on singly-linked
lists, in Subsection~\ref{subsect:skiplists}, we consider programs operating
on skiplists, and in
Subsection~\ref{subsect:skiplists}, we consider programs operating
arrays of singly linked lists.


%% In the actual verification, we compute a symbolic representation
%% of an invariant that is satisfied by all reachable program configurations (including observer states).
%% This invariant is obtained by an abstract-interpretation-based
%% fixpoint procedure, which starts
%% from a representation of the set of initial configurations, and
%% thereafter repeatedly performs
%% postcondition computations that extend the
%% symbolic representation by the effect of any execution step of the program,
%% until convergence.
%% This analysis needs to deal with the challenges of an unbounded domain of
%% data values, an unbounded number of concurrently executing threads, and an
%% unbounded heap. 

\subsection{Fragment Abstraction for Singly-Linked List-Based Programs}
\label{subsec:frag-sll}
In this subsection, we describe our symbolic representation, using fragment
abstraction, for programs that operate on singly-linked lists (SLLs). This
representation is also the basis for our representation for programs
operating on skiplists, described in Subsection~\ref{subsect:skiplists}
and programs operating on arrays of SLLs, in Subsection~\ref{subsect:skiplists}.

\bjcom{Say that for now, we ignore timers?}

We assume that we must analyze the product of a program and an observer.
The program operates on a heap, where each cell has exactly one
pointer field, named {\tt next}, and at most one {\tt data} field, which
assumes values from the same domain $\ddomain$ as observer registers.

\bjcom{Introduce notation for the set of local $\ddomain$-variables?.
  Maybe defined which threads we talk about?
  For now, we skip timestamps.
}

We first define our {\em data abstraction}.
For each thread-local variable, and each non-pointer cell field, which ranges
over some concrete domain, we define a corresponding abstract domain,
as follows.
\begin{itemize}
\item For small concrete domains (including that of the program counter),
  the abstract domain is the same as the concrete one.
\item
  For locks variables and lock fields, the abstract domain is $\set{\mathit{me},\mathit{other},\mathit{free}}$.
\bjcom{Should we explain?}
\item For the concrete domain $\ddomain$ of data values, the abstract domain
  is the set of mappings from local variables ranging over $\ddomain$ and
  observer registers to the set $\set{<,=,>}$.
  An element in the abstract domain represents a concrete data value $\tt d$
  if
    it maps each local variable and observer register with value $\tt d'$
    to a set which includes a relation
    $\sim$ such that $\tt d \sim \tt d'$.
\end{itemize}
Define a {\em local symbolic configuration} as a mapping from local
variables (including the program counter) to their corresponding abstract
domains.
We use $\conf \satlocsymbconf{\thread} \locsymbconf$ to denote that in the
global configuration $\conf$, the
local configuration of thread $\thread$ satisfies the local symbolic
configuration $\locsymbconf$, defined in the natural way.

As partial motivation for the definition of tags, we
observe that in order to verify ordering properties represented by the
observer, e.g., that data elements are popped in LIFO order, it is necessary to
track the relative positions of heap cells whose {\tt data} field has the same
value as some observer register. Thus,   in a given configuration,
for an observer register $\reg_i$,  define a
{\em $\reg_i$-cell} to be a heap cell whose
${\tt data}$ has the same value as $\reg_i$.
\bjcom{Move this paragraph?}

Next, define a {\em tag} as a tuple
$\atag = \tagtuple$, where
\begin{itemize}
\item
  $\vals$ is a mapping from non-pointer fields to their corresponding abstract
  domains,
\item
  $\pvars$ is a set of (global or local) pointer variables,
 \item
   $\reachfrom$ and $\reachto$ are sets of global pointer variables and observer registers, and
  \item $\private$ is a boolean value.
\end{itemize}
Assume some global configuration $\conf$.
We say that a heap cell $\cell$ be {\em accessible} to a thread $\thread$
%% in a configuration $\conf$
if $\cell$ is reachable (directly or via sequence of
next-pointers) from a global pointer variable or local pointer
variable of $\thread$.
For a cell $\cell$ which is accessible to thread $\thread$, and a tag
$\atag = \tagtuple$, we write $\cell \satfrag{\thread} \atag$ to denote that
\begin{itemize}
\item
  $\vals$ represents the concrete values of the non-pointer fields of $\cell$,
%%   is satisfied in the following sense:
%%   \begin{enumerate}[(i)]
%%     \item
%%       $\vals(\field) = \cellval(\cell,\field)$ for each each non-lock
%%       $\mathbb{F}$-field $\field$,
%%   \item
%%       for each lock field $\field$, we have
%%       $\vals(\field) = \mathit{me}$ if $\thread$ holds the lock,
%%       $\vals(\field) = \mathit{other}$ if some other thread holds the lock, and
%%       $\vals(\field) = \mathit{free}$ if the lock is free,
%%   and
%% \item
%%   for each $\intgrs$-field $\field$ and each
%%   observer register $x  \in \ovarset$ we have that
%%   $\vals(\field)(x)$ is $=$ iff $\cellval(\cell,\field)$ is equal to the value
%%   of $x$.
%% \bjcom{Should we also do that for local data and timestamp variables?}
%%   \end{enumerate}
\item
  $\pvars$ is the set of global pointer variables and
  local pointer variables of $\thread$ that point to $\cell$,
\item
  $\reachfrom$ is the set of
  \begin{inparaenum}[(i)]
  \item global pointer variables
    %% and local pointer variables of $\thread$
    from which $\cell$ is reachable via a (possibly empty)
    sequence of {\tt next} pointers, and
  \item observer registers $\reg_i$ such that $\cell$ is reachable from
    some $\reg_i$-cell.
  \end{inparaenum}
\item
  $\reachto$ is the set of
  \begin{inparaenum}[(i)]
  \item global pointer variables
    %% and local pointer variables of $\thread$
    that point to a cell which is reachable from $\cell$, and
  \item observer registers $\reg_i$ such that some $\reg_i$-cell is reachable
    from $\cell$.
  \end{inparaenum}
\item
  $\private$ is $\true$ if
   $\cell$ has never been published (by assigning a heap pointer-field or global pointer variable) by its creating thread $\thread$.
\end{itemize}


\begin{definition}[SLL-fragment]
\label{def:sll-fragment}
An {\em SLL-fragment} $\frag$ (or just fragment)
is a tuple of of form
$\fragtupleat{\frag}$, of form
$\tuple{\inat{\frag},\nullconst}$, or of form
$\tuple{\inat{\frag},\dangconst}$,
where $\inat{\frag}$ and $\outat{\frag}$ are tags,
    and where $\datarelat{\frag}$ is a subset of $\set{<, =, >}$.
\end{definition}

For a cell $\cell$ which is accessible to thread $\thread$, and a fragment
$\frag$ of form $\fragtupleat{\frag}$, we write $\cell \satfrag{\thread}\frag$ to denote that
the ${\tt next}$ field of $\cell$ points to a cell $\cell'$ such that
$\cell \satfrag{\thread} \inat{\frag}$, and
$\cell' \satfrag{\thread} \outat{\frag}$, and
$\cell.\mathtt{data} \sim \cell'.\mathtt{data}$ for some $\sim \in \datarel$.
For a fragment $\frag = \tuple{\inat{\frag},\nullconst}$, let
$\cell \lhd \frag$ denote that
$\cell \lhd \inat{\frag}$ and $\mathtt{next}(\cell) = \nullconst$.
Define $\cell \lhd \frag$ for $\frag$ of form $\tuple{\inat{\frag},\dangconst}$
analogously.
%% For $\tuple{\inat{\frag},\dangconst}$, the definition is adapted in the obvious way.

Let $\fragset$ be a set of fragments.
A global configuration satisfies a set $\fragset$ of fragments wrp.\ to $\thread$,
denoted  $\conf \satfragset{\thread} \fragset$,
if
for any cell $\cell$ that is accessible to $\thread$, there is a fragment
$\frag \in \fragset$ such that $\cell \satfrag{{\thread}} \frag$.
For a local symbolic  configuration $\locsymbconf$ and set $\fragset$ of
fragments, we write
$\conf \satconf{\thread} \tuple{\locsymbconf,\fragset}$ to denote that
that $\conf \satlocsymbconf{\thread} \locsymbconf$
and $\conf \satfragset{\thread} \fragset$.

%% \begin{itemize}
%% \item
%%   $\pvarsofth{\cell}{\thread} = \pvars$,
%% \item
%%   $\valsofth{\cell}{\thread} = \vals$,
%% \item
%%   $\reachfromofth{\cell}{\thread} = \reachfrom$,
%% \item
%%   $\reachtoofth{\cell}{\thread} = \reachto$,
%%   and
%% \item
%%   if $\private$ is true then $\cell$ is not accessible from any thread other
%%   than $\thread$.
%% \end{itemize}
%% We can now define the notion of fragment.q

%% A {\em symbolic configuration} is a pair
%% $\tuple{\locsymbconf,\fragset}$ consisting of a local symbolic 
%% configuration $\locsymbconf$, and a set $\fragset$ of fragments.
%% A configuration $\conf$ of a program satisfies a symbolic configuration
%% $\tuple{\locsymbconf,\fragset}$ if for each thread $\thread$,
%% \begin{itemize}
%% \item the local configuration of $\thread$ satisfies $\locsymbconf$, in the
%%   natural way, and
%% \item for each $\cell$ that is accessible from $\thread$, there is
%%   a fragment $\frag$ such that $\cell \lhd_{\thread} \frag$.
%% \end{itemize}
A {\em symbolic representation} $\symbrep$ is a mapping from
local symbolic  configurations to sets of fragments.
A configuration $\conf$ of a program satisfies a symbolic representation
if for each thread $\thread$, 
the domain of $\symbrep$ contains a local symbolic configuration
$\locsymbconf$ such that $\conf \satconf{\thread}
\tuple{\locsymbconf,\symbrep(\locsymbconf)}$.

\todo[inline]{Skip the following example. Do we need one?}
\paragraph{Example:} Let us show an example of how a singly linked list (SLL) is split into a set of fragments. Fig.~\ref{lazylist}(a) shows an example of a concrete shape of a singly linked list. Each cell contains the values of $\tt val$, $\tt mark$, and $\tt lock$ from top to bottom, where \tick \; denotes $\tt true$, and \cross \; denotes $\tt false$ (or $\tt free$ for $\tt lock$) and the value of $\tt val$ is denoted by a pair of the observer register $\tt z$ and a subset of $\set{<, =, >}$. There are two threads $1$ and $2$ with two local variables $\tt c_1$ and $\tt c_2$. There are two global variables $\tt H$ and $\tt T$ pointing to the head and tail of the list. The observer register $\tt z$ has value 8. Fig.~\ref{lazylist}(b) shows the result of splitting the list in Fig.~\ref{lazylist}(a) into fragments where each heap fragment is a small list of two nodes. Fig.~\ref{lazylist}(c) shows the abstraction of fragments in Fig.~\ref{lazylist}(b) where for each cell $\cell$, the value of $val$ is abstracted to a subset in $\tt \{<z, =z, >z\}$, the reachability relation between $\cell$ and global variables and observer registers is abstracted to the predicate $\tt X \mapsto \tt Y$ where $\tt X$, $\tt Y$ are sets of global variables and observer registers, $\tt i$ or $\tt o$ states that $\cell$ is an input or output cell.

\subsubsection{Computing Postconditions}
\label{subsect:postcond}
In the  verification, we must compute a symbolic representation
that is satisfied by all reachable program configurations.
%% (including observer states).
This invariant is obtained by an abstract-interpretation-based
fixpoint procedure, which starts
from a representation of the set of initial configurations, and
thereafter repeatedly performs
postcondition computations that extend the
symbolic representation by the effect of any execution step of the program,
until convergence.
In this subsection, we describe the symbolic postcondition computation, which
is the key step in this procedure.
%% \bjcom{The following should be included more smoothly, if really needed}
%% Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$.

%% Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
  
%% $\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. 

%% We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments, and any heap is ``broken down into pre-defined fragments''. A fragment retains the information about a particular part of a heap. This choice of fragments defines the level of abstraction that transforms heap into fragments. The abstract function $\alpha_k$ maps a heap into a set of fragments. Whereas, the concretization function $\gamma_k$ inputs a set of fragments, and returns the set of heaps that can be reconstructed from these fragments. 

%% \paragraph{Fragment Definition:} A heap fragment of size $\tt k$ is represented as \begin{center}
%% 	${\tt v} = \viewconf$ where 
%% \end{center} 

%We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments parameterized by a constant $\tt k$, and any heap is “broken down into pieces” of size (at most) k, called fragments. A fragment retains the information about $\tt k$ connected cells from a heap and abstracts away the other cells. This choice defines the level of abstraction that transforms heap into fragments.There is a certain freedom in what information to retain and what to abstract away. The abstract function $\alpha_k$ maps a heap into a set of heap fragments of sizes $\tt k$. The concretization function $\gamma_k$ inputs a set of heap fragments, and returns the set of heaps that can be reconstructed from the these fragments. Let us represent symbolic representations of heap fragments. A heap fragment of size $\tt k$ is represented as ${\tt \Omega} = \viewconf$ where 

%\paragraph{Abstract Configuration}:
%A abstract {\it configuration} of a program $\prog$ in the fragment of a single thread $\thread$
% is a tuple
%$\tuple{\tt c,\lambda, \Omega , S}$ where
%\begin{itemize}
%\item $\tt c$ is an observer configuration, 
%\item $\lambda$ is the label of the program statement, 
%\item $\tt \Omega$ is a tuple $\tt \tuple{\Omega_p, \Omega_l, Val}$ where $\tt \Omega_p$ contains a set ordering constrains between pointer variables, $\tt \Omega_l$ contains a set ordering constrains between data local variables and $\tt Val$ maps each data local variable to its value.
%\item $\tt S$ is a set of fragments.
%\end{itemize}
%
%% We use $\confsetof\prog$ to denote the set of configurations

%% In this subsection, we describe how to perform the abstract postcondition computation on our symbolic representation for singly linked lists.
The symbolic postcondition computation must ensure that the symbolic representation
of the reachable configurations of a program is closed under execution of a
statement by some thread.
More precisely, assume that a global configuration $\conf$ satisfies
a symbolic representation $\symbrep$. Let $\thread$ be an arbitrary thread.
Assume that there is
a local symbolic configuration $\locsymbconf \in \domof{\symbrep}$ such that
$\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$.
We must ensure that this property still hols after any execution of a
statement by some thread.
%% it is still the case that
%% $\domof{\symbrep}$ contains a local symbolic configuration 
%% $\locsymbconf'$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf',\symbrep(\locsymbconf)}$
%% for some thread $\thread$.
In the thread-modular approach, we must consider two cases:
\begin{itemize}
\item
  {\it Local Steps:} The thread $\thread$ itself executes some statement,
  which may change its local state and the state of the heap.
  In this case, we compute a local symbolic configuration $\locsymbconf'$ and
  set $\fragset'$ such that the resulting configuration $\conf'$ satisfies
  $\conf' \satconf{\thread} \tuple{\locsymbconf',\fragset'}$, and (if necessary)
  extend $\symbrep$ so that $\locsymbconf' \in \domof{\symbrep}$ and
  $\fragset' \in \symbrep(\locsymbconf')$.
\item
  {\it Interference Steps:} Another thread $\thread_2$, which 
  satisfies a local symbolic configuration $\locsymbconf_2$
  in $\domof{\symbrep}$ with
  $\conf \satconf{\thread_2} \tuple{\locsymbconf_2,\symbrep(\locsymbconf_2)}$
  performs a computation step,  which affects the state of the heap in
  such a way that makes it necessary to extend $\symbrep(\locsymbconf)$.
  We must then compute a set $\fragset'$ of fragments such that
  the resulting configuration $\conf'$ satisfies
  $\conf' \satfragset{\thread} \fragset'$ and 
  make sure that $\fragset' \in \symbrep(\locsymbconf)$.
  To do this, we first combine the the local symbolic configurations
  $\locsymbconf$ and $\locsymbconf_2$ and the sets of fragments
  $\symbrep(\locsymbconf)$ and $\symbrep(\locsymbconf_2)$, using an
%%   of $\thread_1$ and $\thread_2$ and then compute a representation of the
%%   the possible heaps whose projection onto $\thread_i$ satisfies
%%   $\symbrep(\locsymbconf_i)$ for $i=1,2$.
%% This is done by performing an
  operation, called {\em intersection}, into
  a joint local symbolic configuration of $\thread$ and $\thread_2$ and
  a set $\fragset_{1,2}$ of fragments that represents the cells accessible
  to either $\thread$ or $\thread_2$.
  We thereafter symbolically compute the postcondition of the statement
  execution of $\thread_2$, as in the local case, finally project back the
  set of fragments onto $\thread$ in the natural way, to obtain $\fragset'$.
\end{itemize}
In the following, we first describe the symbolic postcondition computation for
local steps, and thereafter the intersection operation.


\paragraph{Symbolic Postcondition Computation for Local Steps}
Let $\thread$ be an arbitrary thread, and assume 
that $\locsymbconf \in \domof{\symbrep}$ with
For each statement that $\thread$ can execute in a configuration $\conf$
with $\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$,
we must compute a local symbolic configuration $\locsymbconf'$ and
a set  $\fragset'$ of fragments such that
such that the resulting configuration $\conf'$ satisfies
  $\conf' \satconf{\thread} \tuple{\locsymbconf',\fragset'}$.
This computation has do be done differently for
each statement. For statements that do not affect the heap or pointer variables,
this computation is standard, and affects only the local symbolic
configuration and data abstraction part of fragments.
We therefore here describe how to compute the effect of statements that update
pointer variables or the heap, since these are the most interesting cases.


The main difficulty in the
postcondition computation is to update the reachability information provided
in the fields $\reachfrom$ and $\reachto$ in each tag of a 
fragment. For instance, consider that a statement $\gvarof{g} := \lvarof{p}$,
which assigns the value of a local pointer variable $\lvarof{p}$ to a global
pointer variable $\gvarof{g}$.
In the postcondition computation, we must for each fragment
determine how to update the field $\reachfrom$ in its tags, and in particular
whether $\gvarof{g}$ should be in this set after the statement
(the same problem occurs for the set $\reachto$),
If $\lvarof{v}$ would have been a global variable, this information could
be obtained by checking whether $\lvarof{v}$ is in the set before the operation.
However, since the $\reachfrom$ field does not include local variables, we
start the postcondition computation by computing a number of
transitive-closure-like relations between fragments, which will allow
to determine whether $\gvarof{g}$ should be in the $\reachfrom$ field after
the statement with rather good accuracy. Note that if our procedure can not
determine whether $\gvarof{g}$ should be in  a $\reachfrom$ field, then it
generates fragments for both possibilities.

First, we say that two tags
$\atag = \tagtuple$ and $\atag' = \tagtupleprime$ are {\em consistent} if
if there is some concrete valuation of non-pointer fields represented by both
$\vals$ and $\vals'$, and if
$\pvars = \pvars'$, $\reachfrom = \reachfrom'$, $\reachto = \reachto'$, and
$\private = \private'$.
Intuitively, $\atag$ and $\atag'$ are consistent if there can exist a cell
$\cell$ accessible to $\thread$ with $\cell \satfrag{\thread} \atag$
and $\cell \satfrag{\thread} \atag'$.
\todo[inline]{To Quy: Can you really require that the data abstractions must
  be the same?}

Let $\frag_1$ and $\frag_2$ be two fragments in a set $\fragset$ of fragments.
\begin{itemize}
\item  Let $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denote that $\outat{\frag_1}$   and $\inat{\frag_2}$ are consistent.
  %% \todo[inline]{Quy: PLEASE  you provide the precise definition of when
  %%   $\tagat{\outat{\frag_1}}$ and $\tagat{\inat{\frag_2}}$ are consistent?}
  %% \quycom{They are consistent if they have same $\reachfrom$, $\reachto$, $\pvars$, $\private$, $\data$. This is for local thread. When we check for consistent between two tags when doing intersection, we have to define differently.}  
\item  Let $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denote that $\outat{\frag_1} = \outat{\frag_2}$ are consistent, and that either
  $\pvarsat{\inat{\frag_1}} \cap \pvarsat{\inat{\frag_2}} = \emptyset$ or that
  the global variables in  $\reachfromat{\inat{\frag_1}}$ are disjoint from
  those in $\reachfromat{\inat{\frag_2}}$.
%%   \quycom{$\reachfromat{\inat{\frag_1}} \cap \reachfromat{\inat{\frag_2}} = \emptyset$ here is not correct, we only need the global variables of reachfrom and reachto in this case}
%% \quycom{In my definition, the consistent here is defined for two views in the same threads. With the view from other thread, I use the notion of intersection.}
\end{itemize}
Intuitively, $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denotes that it is
possible that  $\mathtt{next}(\cell_1) = \cell_2$ for some cells with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Intuitively, $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denotes that it is
possible that
  $\mathtt{next}(\cell_1) = \mathtt{next}(\cell_2)$.
for different cells  $\cell_1$ and $\cell_2$ with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Note that the above definitions also work for the cases that the output tag is
$\nullconst$ or $\dangconst$.

We use the above relations to define several derived relations:
%% \bjcom{We could use a common pattern for these and save space in definitions.}
\begin{itemize}
\item Let $\overset{+}\hookrightarrow_{\fragset}$ denote the transitive closure of
  $\hookrightarrow_{\fragset}$, and
   $\overset{*}\hookrightarrow_{\fragset}$ the reflexive transitive closure of
$\hookrightarrow_{\fragset}$.
\item Let $\frag_1  \overset{**}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1',\frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{*}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{*+}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1', \frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{*}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{*\circ}\leftrightarrow_{\fragset}  \frag_2$ denote that is a
  $\frag_1' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2$ such that
  $\frag_1  \overset{*}\hookrightarrow_{\fragset} \frag_1'$.
\item Let $\frag_1  \overset{++}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1',\frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{+}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{+*}\leftrightarrow_{\fragset}  \frag_2$ denote that there are
  $\frag_1', \frag_2' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2'$ such that
  $\frag_1  \overset{+}\hookrightarrow_{\fragset} \frag_1'$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \frag_2'$.
\item Let $\frag_1  \overset{+\circ}\leftrightarrow_{\fragset}  \frag_2$ denote that is a
  $\frag_1' \in \fragset$ with $\frag_1' \leftrightarrow_{\fragset} \frag_2$ such that
  $\frag_1  \overset{+}\hookrightarrow_{\fragset} \frag_1'$.
\end{itemize}
We say that $\frag_1$ and $\frag_2$ are {\em compatible} if $\frag_x \overset{*}\hookrightarrow \frag_y$ or $\frag_y \overset{*}\hookrightarrow \frag_x$ or $\frag_x \overset{**}\leftrightarrow \frag_y$. Intuitively, this means that $\frag_1$ and
$\frag_2$ can be satisfied by two cells in the same heap state.
\input viewrelations
Figure~\ref{fig:viewrelations} illustrates the above relations for a heap state
with $13$ heap cells. The figure shows 4 fragments that are satisfied by heap
cells, as denoted by green boxes, and how the relationship between heap cells
is reflect by relations between the corresponding fragments.

We can now describe how to perform the symbolic postcondition computations for
statements that assign to a pointer variable.

Consider a statement of form
${\tt x := y}$, where $\mathtt{x}$ and $\mathtt{y}$ are global or local
(to thread $\thread$) pointer variables. We must compute a set $\fragsetpost$ of
fragments which are satisfied by the configuration after the statement.
We must ensure that any cell $\cell$ which is accessible to $\thread$ after
the statement satisfies some fragment in $\fragsetpost$.
The cell $\cell$ must satisfy some
fragment $\frag$ in $\fragset$, and must be in the same heap state as
the cell pointed to by $\gvarof{y}$. 
This means that we can make a case analysis on the possible relationships
between $\frag$ and any fragment $\frag_y\in\fragset$ such that
$\mathtt{y} \in \pvarsat{\inat{\frag_y}}$.
Thus, for each fragment $\frag_y\in\fragset$ such that
$\mathtt{y} \in \pvarsat{\inat{\frag_y}}$ we let $\fragsetpost$ contain
the fragments obtained by the following transformations on fragments in
$\fragset$.
\begin{enumerate}
  \item
First, for the fragment $\frag_y$ itself, we let $\fragsetpost$ contain
$\frag'$, which is the same as $\frag_y$, except that
%% Let $\tt kill(x,v)$ be the procedure to remove $\tt x$ if it exists from
%% $\reachfromat{\inat{\frag}}$,
%% $\reachfromat{\outat{\frag}}$,
%% $\reachtoat{\inat{\frag}}$,
%% $\reachtoat{\outat{\frag}}$,
%% $\pvarsat{\inat{\frag}}$, and
%% $\pvarsat{\outat{\frag}}$.
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag_y}} \cup \set{x}$ and
  $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$
\end{itemize}
and furthermore, if $\gvarof{x}$ is a global variable, then
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ and
$\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ and
$\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$.
\end{itemize}
\item  for each fragment $\frag$ with $\frag \hookrightarrow_{\fragset} \frag_y$, let $\fragsetpost$ contain $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
\item We perform analogous inclusions for fragments $\frag$ with
  $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$,
  $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$,
  $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$, and
  $\frag_y \overset{*\circ}\leftrightarrow_{\fragset} \frag$. For space reasons,
  we show only the case of $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$,
  in which case we let $\fragsetpost$ contain $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
\end{enumerate}
The statement ${\tt x := y.next}$ is handled rather similarly to the preceding
case. Let us therefore describe the computation for statements of the form
${\tt x.next:= y}$.
This is the most difficult statement, since it is a destructive update of the heap. The statement affects reachability relations for both $\gvarof{x}$ and
$\gvarof{y}$. This means that we can make a case analysis on how a fragment
in $\fragset$ is related to some pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inat{\frag_x}}$, $\tt y \in \pvarsat{\inat{\frag_y}}$. 
Thus, for each pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inat{\frag_x}}$, $\tt y \in \pvarsat{\inat{\frag_y}}$, 
we let $\fragsetpost$ contain
the fragments obtained by the following transformations on fragments in
$\fragset$.
\begin{enumerate}
  \item
    First, let $\fragsetpost$ contain a new fragment $\frag_{new}$ of form
    $\fragtupleat{\frag_{new}}$
    $\tagat{\inat{\frag_{new}}} = \tagat{\inat{\frag_x}}$ and $\tagat{\outat{\frag_{new}}} = \tagat{\inat{\frag_y}}$ except that $\reachfromat{\outat{\frag_{new}}} = \reachfromat{\inat{\frag_y}} \cup \reachfromat{\inat{\frag_x}}$,
    and $\datarelat{\frag_{new}} = \set{<,=,>}$.
Thereafter, we add all possible fragments that can result from a transformation
of some fragment $\frag$ which is in $\frag$. This is done by an exhaustive
case analysis on the possible
relationship between $\frag$, $\frag_x$ and $\frag_y$.
Let us consider an interesting case, in which
$\frag_x \overset{*}\hookrightarrow_{\fragset} \frag$ and either $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*+}\leftrightarrow \frag$.
In this case,
\begin{enumerate}
\item
  for each subset $\regset$ of observer registers in $\tt \reachfromat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$, we first create
  a fragment $\frag'$ which is same as $\frag$, except that $\reachfromat{\inat{\frag'}} = (\tt \reachfromat{\inat{\frag}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$.
\item
  Thereafter, 
for each set $\regset'$ of observer registers in $\reachfromat{\outat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$,  we let $\fragsetpost$ contain a fragment
$\frag''$ which is same as $\frag'$, except that $\reachfromat{\outat{\frag''}} = (\reachfromat{\outat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset'$. 
\end{enumerate}
\end{enumerate}
\todo[inline]{We should include an argument why the last case above is correct.
  Quy, could you produce one?}

\paragraph{Symbolic Postcondition Computation for Interference Steps.} 
The key operation in this computation, called {\em intersection}
is to combine two (not necessarily different) local symbolic configurations
$\locsymbconf_1$ and $\locsymbconf_2$ and sets of fragments
$\fragset_1$ and $\fragset_2$ into a
a {\em joint local symbolic configuration} $\locsymbconf_{1,2}$ of
$\thread_1$ and $\thread_2$ and a set $\fragset_{1,2}$ of fragments such that
for each configuration $\conf$ with
$\conf \satconf{\thread_i} \tuple{\locsymbconf_1,\fragset_i}$ for $i=1,2$ we have
$\conf \satconf{(\thread_1,\thread_2)} \tuple{\locsymbconf_{1,2},\fragset_{1,2}}$. Here,we have abused the notation, using
$\satconf{(\thread_1,\thread_2)}$ to denote satisfaction of the local states of
two threads, $\thread_1$ and $\thread_2$, and the set of heap cells accessible to
either $\thread_1$ or $\thread_2$.
In order to distinguish
between local variables of $\thread_1$ and $\thread_2$, we let local variable
$\lvarof{x}$ of thread $\thread_i$ be named as $\lvarof{x[i]}$.

The construction of a joint local symbolic configuration $\locsymbconf_{1,2}$ from
local symbolic configurations 
$\locsymbconf_1$ and $\locsymbconf_2$ for $\thread_1$ and $\thread_2$,
respectively, is straight-forward.
Let us then outline how the joint set $\fragset_{1,2}$ is constructed.
This set must for each
heap cell $\cell$ accessible to either $\thread_1$ or $\thread_2$ 
contain a fragment $\frag$ with $\cell \satfrag{(\thread_1,\thread_2)} \frag$.
This criterion suggests that $\fragset_{1,2}$ should contain fragments for
three classes of cells:
\begin{inparaenum}[(1)]
\item cells accessible to both $\thread_1$ and $\thread_2$,
\item cells $\cell$ accessible to only $\thread_1$, but where
  $\tt next(\cell)$ is accessible also to $\thread_2$
  (or vice versa), and
\item cells for which $\tt next(\cell)$ is accessible only to $\thread_1$
  (or vice versa).
\end{inparaenum}
For each class of cells, we combine all relevant combinations of
fragments from $\fragset_1$ and $\fragset_2$ into fragments of $\fragset_{1,2}$.
For lack of space, let us show only case (1).
In this case we combine all pairs of
fragments $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$
that can represent the same cell.
This can happen if their
tags agree on the data abstraction (in the natural way)
and information about reachability of global variables,
and all their $\private$ fields are $\false$. For such pairs,
we form their combination $\frag_{12}$,
which is identical to $\frag_1$ except that 
\begin{itemize}
  \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$,
  \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$,
  \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$, and
  \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$.
\end{itemize}
  %% The cell $\cell$ is accessible to only $\thread_1$, but
  %% $\tt next(\cell)$ is accessible also to $\thread_2$. This can 
  %% happen if $\reachfromat{\intagat{\frag_1}}$ contains no global variables.

%% There are  here two possibilities.
%% \begin{itemize}
%% \item If $\cell$ is accessible to both $\thread_1$ and $\thread_2$, then
%%   We use the notation $\frag_1 \sqcap \frag_2$ to denote a set of views such that
%%   whenever $\cell \satfrag{1} \frag_1$ and $\cell \satfrag{2} \frag_2$ then
%%   $\cell \satfrag{1,2} \frag$ for some $\frag \in (\frag_1 \sqcap \frag_2)$.
%% \item If $\cell$ is accessible to only one of $\thread_1$ and $\thread_2$,
%%   say $\thread_1$, then $\fragset$ should contain some fragment
%%   $\frag_1 \in \fragset_1$ with $\cell \satfrag{1,2} \frag_1$
%%   \bjcom{Check that we need not change $\frag_1$}
%% \end{itemize}
%% For a fragment $\frag$, define
%% $\greachfromat{\inat{\frag}}$ as the set of global variables in
%% $\reachfromat{\inat{\frag}}$. Define
%% $\greachtoat{\inat{\frag}}$,
%% $\greachfromat{\outat{\frag}}$,
%% $\greachtoat{\outat{\frag}}$,
%% $\gpvarsat{\inat{\frag}}$, and
%% $\gpvarsat{\outat{\frag}}$
%% analogously.
%% Define $\gtagat{\outat{\frag}}$ as the tuple
%% $\tuple{\gpvarsat{\outat{\frag}},\valsat{\outat{\frag}},\greachfromat{\outat{\frag}},\greachtoat{\outat{\frag}},\privateat{\outat{\frag}}}$.

\todo[inline]{Question to Quy: You have also used the notation
  $\gvalsat{\inat{\frag}}$. Will you need it, and if so what does it mean?}
\quycom{Because in the data, I add data constraint between data fields and local data variable. When we do intersection, we do not need to care about this constraint because its local constraint}
\todo[inline]{New Question to Quy. BUT some of the data abstraction is
  about observer registers. Mustn't this Agree?}

\subsection{Fragment Abstraction for Skiplists}
\input skipcode
%\todo[inline]{Here goes a description of the fragment abstraction for
%   skip lists}
\todo[inline]{for Quy: in the Code, you use sometimes ``snip'', sometimes ``s''.
  Line 12 and 17 is strange:
  Please adapt the syntax (now marked[0] is never assigned).
  You might shorten by omitting the unlinking of marked nodes (lines 13 - 17)
  to make it simple.
It is a bit strange that marked[] is defined up to MAXLEVEL but only marked[0] is used}

In this section, we describe the application of our fragment abstraction to concurrent programs that operate on skiplists. Let us first briefly introduce skiplists. Skiplists are a popular structure used in concurrent data structures
implementing sets and other collections.
\bjinsert{REFERENCES}
Heap cells have an array of $\tt next$ pointer, indexed by a level that ranges
from $0$ and upwards. The pointer arrays of Head and Tail cells always have
a maximum height, whereas the height of arrays at other nodes vary between $1$
(only a $\tt next[0]$-pointer) and the maximum. The cells and $\tt next[0]$-pointers form a singly-linked
list. Higher-level $\tt next$ pointers act as shortcuts in this list, so that
for each $i$, the $\tt next[i]$-pointers form a sublist of the level-$0$ list.
Because there are fewer nodes higher levels, one can find a given key quickly,
by searching first through the list at higher levels,
progressively working downward until the desired key is found.
An initial empty skiplist has only a Head and a Tail cell with minimal and
maximal keys, where 
the Tail cell is the $\tt next[i]$-successor of the Head cell for each $i$.

Figure~\ref{fig:lockfreeskiplistfind} shows a find method for locating
a cell with a given key $\tt key$, which is part of a lock-free skiplist-based concurrent set algorithm described in~\cite{ArtOfMpP}.
The method traverses the skiplist at decreasing levels, starting from
level $\tt MAXLEVEL$ down until the bottom level $0$, using the pointers
$\tt curr$ and $\tt pred$ in the standard way.
%% It then proceeds in each level down the list, filling in $\tt preds$
%% and $\tt succs$ nodes that are repeatedly advanced until $\tt pred$ refers to a node with
%% the largest value on that level that is strictly less than the target key $\tt key$.
During the traversal, the method also unlinks (i.e., physically removes)
marked (i.e., logically removed) nodes (lines XX -- YY).
At each level, the traversal continues until $\tt curr$ points to a node
with a key larger than the desired key: then the $\tt pred$ and $\tt curr$ pointers are saved in the arrays $\tt preds$ and $\tt succs$ at the current level.
 \begin{figure}  
 \input skiplistshape  
 \caption{An example heap state of the $\tt find$ method for a skiplist with 3 levels.}
 \label{skiplistshape}
\end{figure}
Figure ~\ref{skiplistshape} shows an example heap state during this method, for
a skiplist with 3 levels. We show each heap cell as a vertical array of
boxes, one for each level of this cell. At each level $i$, the $\tt data$,
$\tt mark[i]$ and $\tt next[i]$ fields are shown, using the layout shown at the top right (there is only one $\tt data$ field, but we show it at each level).
Each cell is labeled by the pointer variables that point to it.
In the heap state of Figure ~\ref{skiplistshape}, the thread is trying to find a target key $8$ and has reached line 24, discovering that key $8$ is not in the list.
For each $i$, the variables $\tt preds[i]$ and $\tt succs[i]$ point to the nearest cells at level $i$.

\subsubsection{Fragment Abstraction for Skiplists}
We can now describe our fragment abstraction for skiplist-based programs.
It is based on the fragment abstraction for SLLs, described in
Section~\ref{subsec:frag-sll}. The main difference is that we define two
kinds of fragments: one for level-$0$ pointers, and one for higher-level
pointers. Thus, our abstraction does not distinguish between the different
higher levels of a skiplist. This also applies to names of pointer
variables in  tags: we use the abstraction $\gvarof{p[h]}$ to denote a
pointer variable $\gvarof{p[i]}$ for any $i \geq 1$.

In cells of typical skiplist algorithms, both pointer and data fields
are arrays indexed from $0$ to the height of the cell. An exception is
the $\tt data$ field (typically containing a key value), which occurs once
in each cell. Our fragments at level $i$ will represent the next pointer
and data fields at level $i$, but global information (in the
$\reachfrom$ and $\reachto$ fields of tags) is based on
the underlying SLL structure at level $0$.


Define a {\em tag} as a tuple $\atag = \tagtuple$, which the same
structure as for singly linked lists, defined in Section~\ref{subsec:frag-sll}.
For a cell $\cell$ which is accessible to thread $\thread$, and a tag
$\atag = \tagtuple$, we say that
the cell $\cell$ satisfies tag $\atag$ at level $0$, denoted
$\cell \satslfrag{\thread}{0} \atag$ in the same way as for SLLs, except that
\begin{itemize}
\item
  $\vals$ represents the concrete values of the non-pointer fields
  at level $0$ of $\cell$,
\item
  in $\pvars$, $\reachfrom$, and $\reachto$ we let 
  $\gvarof{p[h]}$ stand for any
  pointer variable $\gvarof{p[i]}$ for any $i \geq 1$
  (pointer variables $\gvarof{p[0]}$ are represented as such)
\item
  in $\reachfrom$ and $\reachto$ we consider reachability
  wrp.\ to the pointer $\tt next[0]$.
\end{itemize}
We say that the cell $\cell$ satisfies tag $\atag$ at level $i$, denoted
$\cell \satslfrag{\thread}{i} \atag$ in the same way, except that
\begin{itemize}
\item
  $\vals$ represents the concrete values of the non-pointer fields
  at level $i$ of $\cell$,
\item
  in $\reachfrom$ and $\reachto$ we consider reachability
  wrp.\ to the pointer $\tt next[0]$.
\end{itemize}

\begin{definition}[Skiplist-fragment]
\label{def:sll-fragment}
A {\em Skiplist-fragment} $\frag$
is a tuple of form
$\slfragtupleat{\frag}$, of form
$\tuple{\inat{\frag},\nullconst,\sklevel}$, or of form
$\tuple{\inat{\frag},\dangconst,\sklevel}$,
which extends an SLL-fragment by a level $\sklevelat{\frag}$ which is either $0$ or $h$.
\end{definition}
For a cell $\cell$ which is accessible to thread $\thread$, and a fragment
$\frag$ of form $\slfragtupleat{\frag}$,
we write $\cell \satfrag{\thread}\frag$ to denote that
there is an $i$ with $i= 0$ iff $\sklevelat{\frag} = 0$ such that
the ${\tt next[i]}$ field of $\cell$ exists and points to a cell $\cell'$ such that
$\cell \satslfrag{\thread}{i} \inat{\frag}$, and
$\cell' \satslfrag{\thread}{i} \outat{\frag}$, and
$\cell.\mathtt{data} \sim \cell'.\mathtt{data}$ for some $\sim \in \datarelat{\frag}$.
 \begin{figure}  
 \input skiplistabs 
 \caption{Skipl-List fragments}
 \label{skiplistabs}
\end{figure}
Figure ~\ref{skiplistabs} illustrates the definition of skiplist-fragments
which represent cells in the skiplist heap state of Figure~\ref{skiplistshape}.
We assume that the program configuration includes an observer with one
register $\reg_1$, which is assigned the value 12.
Fragments $\tt v_1$, $\tt v_2$,$\tt v_3$, and $\tt v_4$ are higher-level
fragments, whereas fragments $\tt v_5$, $\tt v_6$,$\tt v_7$, and $\tt v_8$ are
fragments at level $0$.
\todo[inline]{to Quy: could you illustrate how the fragments represent cells,
  in the same way as in Figure~\ref{fig:viewrelations}?}
 
\subsubsection{Computing Postconditions for Skiplists}
\label{subsect:postcond-skiplists}
The symbolic postcondition computation for skiplists is based on that for
singly linked lists, described in Section~\ref{subsect:postcond}, with the
same separation into local steps and interference steps.
For the local steps, statements that do not affect the heap or pointer
variables can be handled in a straight-forward manner.
For statements that update the global heap or assign to pointer variables,
we must correctly update the global information in tags.
Since this global information is based on the $\tt next[0]$ pointers,
we first perform the postcondition computation on the set of
level-0 fragments, as for SLLs. Thereafter, we compute the possible
effect of the level-0 postcondition computation  on higher-level fragments.
For this, we define two tags (of the same or different levels)
to be {\em consistent} if they can possibly be satisfied by the same
cell in some configuration.

To make this more concrete, consider as an example an assignment
${\tt x := y}$, where $\mathtt{x}$ and $\mathtt{y}$ are global or local
(to thread $\thread$) pointer variables.
\begin{enumerate}
  \item
The postcondition computation first computes a set of level-$0$ fragments,
in the same way as for SLLs: this involves to compute
the analogues of the transitive-closure relations that were used
for singly-linked lists. We monitor this computation by means of a relation
$R$ between level-$0$ fragments  in the set representing the heap before the
statement and level-$0$ fragments in the set representing the heap after the
statement. We let $\frag \ R \ \frag'$ if the fragment $\frag$ can be
transformed into the fragment $\frag'$ by the postcondition operation.
This means that for each cell $\cell$ there are fragments $\frag$ and $\frag'$
such that $\cell \satslfrag{\thread}{0} \frag$ in the configuration before
the statement, and $\cell \satslfrag{\thread}{0} \frag'$ in the configuration
after the statement.
\item
  Thereafter, tags of higher-level fragments are updated in the following way
  For each higher-level fragment $\frag_h$, each pair of
  level-$0$-fragments $\frag_1$ and $\frag_2$ in the set of fragments
  before the statement, such that
  $\inat{\frag_h}$ and $\inat{\frag_1}$ are consistent and
  $\outat{\frag_h}$ and $\inat{\frag_2}$ are consistent, we let for
  each pair of fragments $\frag_1'$ and $\frag_2'$ such that
  $\frag_1 \ R \frag_1'$ and $\frag_2 \ R \frag_2'$ the set of fragments
  after the statement contain all higher-level fragments
  $\frag_h'$ with $\datarelat{\frag_h'} = \datarelat{\frag_h}$ such that
  $\inat{\frag_h}$ and $\inat{\frag_1}$ are consistent and
  $\outat{\frag_h}$ and $\inat{\frag_2}$ are consistent.
  \todo[inline]{Quy: Could you make a simple diagram which illustrates all the
    relations between different fragments in this case?}
\end{enumerate}
The same principle for postcondition computation is applied to updates of
$\tt next[0]$-pointers.

The postcondition computation for updates of higher-level pointers, e.g.,
of form $\tt x.next[2] := y$ are done by:
\todo[inline]{Quy: Can you explain how to do in this case?}


  




%
