\begin{center}
\begin{figure}
\input{sll-lazy-list-shape}
\caption{Example of Fragment Abstraction}
\label{lazylist}
\end{figure}
\end{center}
\section{Fragment Abstraction: Singly Linked Lists}
\label{sec:fragment-abstraction}
In the previous section, we reduced the problem of verifying linearizability
to the problem of verifying
that, in any execution of the cross-product of a program and an observer, 
the observer cannot reach an accepting state.
In this section, we describe our technique for performing this verification.
The main novel contribution is our fragment abstraction for
representing the possible heap configurations of a concurrent program.
In the following subsection, we describe our symbolic representation and
verification technique, using fragment
abstraction, for programs that operate on singly-linked lists (SLLs). This
representation is also the basis for our representation for programs
operating on skiplists, described in Subsection~\ref{subsect:skiplists}
and programs operating on arrays of SLLs, in Subsection~\ref{subsect:skiplists}.

\bjcom{Where to put this paragraph?}
We consider a program with global variables $\glvarset$ and
thread-local variables $\locvarset$.
We assume that all global variables are pointer variables.
%% We describe our fragment abstractions for three classes of heap structures:
%% in the following subsection, we consider programs operating on singly-linked
%% lists, in Subsection~\ref{subsect:skiplists}, we consider programs operating
%% on skiplists, and in
%% Subsection~\ref{subsect:skiplists}, we consider programs operating
%% arrays of singly linked lists.


%% In the actual verification, we compute a symbolic representation
%% of an invariant that is satisfied by all reachable program configurations (including observer states).
%% This invariant is obtained by an abstract-interpretation-based
%% fixpoint procedure, which starts
%% from a representation of the set of initial configurations, and
%% thereafter repeatedly performs
%% postcondition computations that extend the
%% symbolic representation by the effect of any execution step of the program,
%% until convergence.
%% This analysis needs to deal with the challenges of an unbounded domain of
%% data values, an unbounded number of concurrently executing threads, and an
%% unbounded heap. 

\subsection{Fragment Abstraction for Singly-Linked List-Based Programs}

\bjcom{Say that for now, we ignore timers?}
\bjcom{Introduce notation for the set of local $\ddomain$-variables?.
  Maybe define which threads we talk about?
  For now, we skip timestamps.
}

%% We assume that we must analyze the product of a program and an observer.
In this subsection, we present our fragment abstraction for programs that
operate on singly-linked lists. This means that
each cell has exactly one pointer field, named {\tt next}.
In order to simplify the presentation in this section, we assume that
each heap cell has at most one $\ddomain$-field, named  {\tt data}.
Our verification technique is based on a combination of a thread abstraction, a
shape  abstraction, and a data abstraction.

Assume a configuration $\sconf$ of $\system=\prog\compose\observer$
and thread $\thread$.
We say that a heap cell $\cell$ is {\em accessible} to a thread $\thread$
in $\sconf$,
if $\cell$ is reachable (directly or via sequence of
{\tt next}-pointers) from a global pointer variable or local pointer
variable of $\thread$.
%% In a given configuration,
For a pointer variable $p$, let a $p$-cell be the cell to which $p$ points.
For an observer register $\reg_i$,  define a
{\em $\reg_i$-cell} to be a heap cell whose
${\tt data}$ field has the same value as $\reg_i$.
\bjcom{Maybe skip the following}
A heap cell is {\em globally significant} if it is either a $p$-cell for
a global pointer variable $p$, or a $\reg_i$-cell for some
observer register $\reg_i$.
\begin{itemize}
  \item
Our {\em thread abstraction}
adapts the thread-modular approach by representing only the view of a single, but arbitrary, thread $\thread$. Such a view consists of
\begin{inparaenum}[(i)]
\item the local state of thread $\thread$,
\item the state of the observer,
\item the part of the heap (including global variables) that is accessible to thread $\thread$, and
\item a predicate, which for each heap cell accessible to $\thread$ says
  whether it is {\em private} to $\thread$, i.e.,
  not accessible to any other thread.
\end{inparaenum}
\item
We use a novel {\em shape abstraction}, which represents the part of the heap
that is accessible to $\thread$ by a set of {\em fragments}. 
A fragment consists of a pair of heap cells that are connected by a pointer.
For each of these cells, the fragment represents
\begin{inparaenum}[(i)]
\item the values of its data fields,
\item the pointer variables (either local to $\thread$ or global) that point
  to it, and
\item global pointer variables $p$ and observer registers $\reg_i$ such that
   the cell can either reach to or be reached from
 (by a chain of {\tt next}-pointers) a $p$-cell or a $\reg_i$-cell, respectively.
\end{inparaenum}
A set of fragments represents the set of heaps 
in which each pair of pointer-connected nodes is represented by some
fragment in the set.
Thus, a set of fragments describes the set of heaps
that can be formed by ``piecing together'' fragments, in a way that is
locally consistent (connecting only fragments that agree on their
common node) and globally consistent (respecting the reachability
information wrp.\ to global pointer variables and observer registers).
%% globally significant cells).
\item
We apply a natural {\em data abstraction} to the local state of a thread, the
state of the observer, and to each fragment. This abstraction
represents small finite domains exactly, and abstracts a set of
data values in $\ddomain$ by their relative ordering.
\end{itemize}
Let us now describe our symbolic representation in concrete detail.
Our data abstraction is conveniently represented by defining an
abstract domain for each concrete domain of data values.
%% For each thread-local variable, and each non-pointer cell field, which ranges
%% over some concrete domain, we define a corresponding abstract domain,
%% as follows.
\begin{itemize}
\item For small concrete domains (including that of the program counter, and
  of the observer location),
  the abstract domain is the same as the concrete one.
\item
  For locks, the abstract domain is $\set{\mathit{me},\mathit{other},\mathit{free}}$,
  mening that the lock is held by $\thread$,  held by some other thread, or is
  free, respectively.
\item For the concrete domain $\ddomain$ of data values, the abstract domain
  is the set of mappings from observer registers and local variables
  ranging over $\ddomain$ to subsets of $\set{<,=,>}$.
  An element in this abstract domain represents a concrete data value $\tt d$
  if it maps each local variable and observer register with a value ${\tt d'} \in \ddomain$
  to a set which includes a relation $\sim$ such that $\tt d \sim \tt d'$.
\end{itemize}
In our shape abstration, we represent each fragment by a pair of
{\em tags}. A {\em tag} is a tuple $\atag = \tagtuple$, where
\begin{itemize}
\item
  $\vals$ is a mapping from non-pointer fields to their corresponding abstract
  domains,
\item
  $\pvars$ is a set of (global or local) pointer variables,
 \item
   $\reachfrom$ and $\reachto$ are sets of global pointer variables and observer registers,
  \item $\private$ is a boolean value.
\end{itemize}
For a heap cell $\cell$ that is accessible to thread $\thread$ 
in a configuration $\sconf$, and a tag
$\atag = \tagtuple$, we write $\cell \satfrag{\thread}{\sconf} \atag$ to denote that
\begin{itemize}
\item
  $\vals$ is an abstraction of the concrete values of the non-pointer fields of $\cell$,
%%   is satisfied in the following sense:
%%   \begin{enumerate}[(i)]
%%     \item
%%       $\vals(\field) = \cellval(\cell,\field)$ for each each non-lock
%%       $\mathbb{F}$-field $\field$,
%%   \item
%%       for each lock field $\field$, we have
%%       $\vals(\field) = \mathit{me}$ if $\thread$ holds the lock,
%%       $\vals(\field) = \mathit{other}$ if some other thread holds the lock, and
%%       $\vals(\field) = \mathit{free}$ if the lock is free,
%%   and
%% \item
%%   for each $\intgrs$-field $\field$ and each
%%   observer register $x  \in \ovarset$ we have that
%%   $\vals(\field)(x)$ is $=$ iff $\cellval(\cell,\field)$ is equal to the value
%%   of $x$.
%% \bjcom{Should we also do that for local data and timestamp variables?}
%%   \end{enumerate}
\item
  $\pvars$ is the set of pointer variables (global or
  local to $\thread$) that point to $\cell$,
\item
  $\reachfrom$ is the set of
  \begin{inparaenum}[(i)]
  \item global pointer variables
    %% and local pointer variables of $\thread$
    from which $\cell$ is reachable via a (possibly empty)
    sequence of {\tt next} pointers, and
  \item observer registers $\reg_i$ such that $\cell$ is reachable from
    some $\reg_i$-cell.
  \end{inparaenum}
\item
  $\reachto$ is the set of
  \begin{inparaenum}[(i)]
  \item global pointer variables
    %% and local pointer variables of $\thread$
    pointing to a cell that is reachable from $\cell$, and
  \item observer registers $\reg_i$ such that some $\reg_i$-cell is reachable
    from $\cell$.
  \end{inparaenum}
\item
  $\private$ is $\true$ only if $\cell$ is private to $\thread$ in $\sconf$
  \bjcom{Should we add: ``is not accessible to any other thread than $\thread$''}
  %% $\private$ is $\true$ if
  %%  $\cell$ has never been published (by assigning a heap pointer-field or global pointer variable) by its creating thread $\thread$.
\end{itemize}


\begin{definition}[SLL-fragment]
\label{def:sll-fragment}
An {\em SLL-fragment} $\frag$ (or just fragment)
is a triple of form
$\fragtupleat{\frag}$, of form
$\tuple{\inat{\frag},\nullconst}$, or of form
$\tuple{\inat{\frag},\dangconst}$,
where $\inat{\frag}$ and $\outat{\frag}$ are tags
    and $\datarelat{\frag}$ is a subset of $\set{<, =, >}$.
\end{definition}

For a cell $\cell$ which is accessible to thread $\thread$, and a fragment
$\frag$ of form $\fragtupleat{\frag}$, let $\cell \satfrag{\thread}{\sconf}\frag$ denote that
the ${\tt next}$ field of $\cell$ points to a cell $\cell'$ such that
\begin{inparaenum}[(i)]
\item
  $\cell \satfrag{\thread}{\sconf} \inat{\frag}$,
\item
$\cell' \satfrag{\thread}{\sconf} \outat{\frag}$, and
\item $\cell.\mathtt{data} \sim \cell'.\mathtt{data}$ for some $\sim \in \datarelat{\frag}$.
\end{inparaenum}
For a fragment of form $\frag = \tuple{\inat{\frag},\nullconst}$, let
$\cell \lhd \frag$ denote that
$\cell \lhd \inat{\frag}$ and $\mathtt{next}(\cell) = \nullconst$.
Define $\cell \lhd \frag$ for $\frag$ of form $\tuple{\inat{\frag},\dangconst}$
analogously.
%% For $\tuple{\inat{\frag},\dangconst}$, the definition is adapted in the obvious way.

Let $\fragset$ be a set of fragments.
A global configuration $\sconf$ satisfies a set $\fragset$ of fragments
wrp.\ to $\thread$, denoted  $\sconf \satfragset{\thread} \fragset$,
if
for any cell $\cell$ that is accessible to $\thread$, there is a fragment
$\frag \in \fragset$ such that $\cell \satfrag{{\thread}}{\sconf} \frag$.



%% \begin{itemize}
%% \item
%%   $\pvarsofth{\cell}{\thread} = \pvars$,
%% \item
%%   $\valsofth{\cell}{\thread} = \vals$,
%% \item
%%   $\reachfromofth{\cell}{\thread} = \reachfrom$,
%% \item
%%   $\reachtoofth{\cell}{\thread} = \reachto$,
%%   and
%% \item
%%   if $\private$ is true then $\cell$ is not accessible from any thread other
%%   than $\thread$.
%% \end{itemize}
%% We can now define the notion of fragment.q

%% A {\em symbolic configuration} is a pair
%% $\tuple{\locsymbconf,\fragset}$ consisting of a local symbolic 
%% configuration $\locsymbconf$, and a set $\fragset$ of fragments.
%% A configuration $\conf$ of a program satisfies a symbolic configuration
%% $\tuple{\locsymbconf,\fragset}$ if for each thread $\thread$,
%% \begin{itemize}
%% \item the local configuration of $\thread$ satisfies $\locsymbconf$, in the
%%   natural way, and
%% \item for each $\cell$ that is accessible from $\thread$, there is
%%   a fragment $\frag$ such that $\cell \lhd_{\thread} \frag$.
%% \end{itemize}
We are now ready to define our abstract symbolic representation, which
is defined as a partial mapping from combinations of abstract observer
and local thread states to sets of fragments. 

Define a {\em local symbolic configuration} as a mapping from local
variables (including the program counter) to their corresponding abstract
domains.
We let $\sconf \satlocsymbconf{\thread} \locsymbconf$ denote that in the
global configuration $\sconf$, the
local configuration of thread $\thread$ satisfies the local symbolic
configuration $\locsymbconf$, defined in the natural way.
For an observer location $\ostate$,
we let $\sconf \satlocsymbconf{\thread} \tuple{\locsymbconf,\ostate}$ denote
that $\sconf \satlocsymbconf{\thread} \locsymbconf$
and that the observer location of $\sconf$ is $\ostate$.

\begin{definition}
  \label{def:symbrep}
    A {\em symbolic representation} $\symbrep$ is a partial mapping from
pairs of local symbolic configurations and observer locations
to sets of fragments.
A system configuration $\sconf$ satisfies a symbolic representation $\symbrep$,
denoted $\sconf \satsymbrep \symbrep$,
if for each thread $\thread$, 
the domain of $\symbrep$ contains a pair
$\tuple{\locsymbconf,\ostate}$ such that
\begin{inparaenum}[(i)]
\item $\sconf \satlocsymbconf{\thread} \tuple{\locsymbconf,\ostate}$, and
%%   \item the observer is in location $\ostate$, and
\item  $\sconf \satfragset{\thread} \symbrep(\tuple{\locsymbconf,\ostate})$.
\end{inparaenum}
\end{definition}
%% For a local symbolic  configuration $\locsymbconf$ and set $\fragset$ of
%% fragments, we write
%% $\conf \satconf{\thread} \tuple{\locsymbconf,\fragset}$ to denote that
%% that $\conf \satlocsymbconf{\thread} \locsymbconf$
%% and




\todo[inline]{Do we need an example here?}
\paragraph{Example:} Let us show an example of how a singly linked list (SLL) is split into a set of fragments. Fig.~\ref{lazylist}(a) shows an example of a concrete shape of a singly linked list. Each cell contains the values of $\tt val$, $\tt mark$, and $\tt lock$ from top to bottom, where \tick \; denotes $\tt true$, and \cross \; denotes $\tt false$ (or $\tt free$ for $\tt lock$) and the value of $\tt val$ is denoted by a pair of the observer register $\tt z$ and a subset of $\set{<, =, >}$. There are two threads $1$ and $2$ with two local variables $\tt c_1$ and $\tt c_2$. There are two global variables $\tt H$ and $\tt T$ pointing to the head and tail of the list. The observer register $\tt z$ has value 8. Fig.~\ref{lazylist}(b) shows the result of splitting the list in Fig.~\ref{lazylist}(a) into fragments where each heap fragment is a small list of two nodes. Fig.~\ref{lazylist}(c) shows the abstraction of fragments in Fig.~\ref{lazylist}(b) where for each cell $\cell$, the value of $val$ is abstracted to a subset in $\tt \{<z, =z, >z\}$, the reachability relation between $\cell$ and global variables and observer registers is abstracted to the predicate $\tt X \mapsto \tt Y$ where $\tt X$, $\tt Y$ are sets of global variables and observer registers, $\tt i$ or $\tt o$ states that $\cell$ is an input or output cell.

\todo[inline]{We ust always say that we consider the cross-product of a program
  and an observer}

\subsubsection{Symbolic Postcondition Computation}
\label{subsect:postcond}
In the  verification, we must compute an invariant in the form
of a symbolic representation
which is satisfied by all reachable program configurations.
%% (including observer states).
Such an invariant is obtained by an abstract interpretation-based
fixpoint procedure, which starts
from a representation of the set of initial configurations, and
thereafter repeatedly performs postcondition computations that extend the
symbolic representation by the effect of any execution step of the program,
until convergence.
In this subsection, we describe the symbolic postcondition computation.
%% \bjcom{The following should be included more smoothly, if really needed}
%% Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$.

%% Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
  
%% $\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. 

%% We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments, and any heap is ``broken down into pre-defined fragments''. A fragment retains the information about a particular part of a heap. This choice of fragments defines the level of abstraction that transforms heap into fragments. The abstract function $\alpha_k$ maps a heap into a set of fragments. Whereas, the concretization function $\gamma_k$ inputs a set of fragments, and returns the set of heaps that can be reconstructed from these fragments. 

%% \paragraph{Fragment Definition:} A heap fragment of size $\tt k$ is represented as \begin{center}
%% 	${\tt v} = \viewconf$ where 
%% \end{center} 

%We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments parameterized by a constant $\tt k$, and any heap is “broken down into pieces” of size (at most) k, called fragments. A fragment retains the information about $\tt k$ connected cells from a heap and abstracts away the other cells. This choice defines the level of abstraction that transforms heap into fragments.There is a certain freedom in what information to retain and what to abstract away. The abstract function $\alpha_k$ maps a heap into a set of heap fragments of sizes $\tt k$. The concretization function $\gamma_k$ inputs a set of heap fragments, and returns the set of heaps that can be reconstructed from the these fragments. Let us represent symbolic representations of heap fragments. A heap fragment of size $\tt k$ is represented as ${\tt \Omega} = \viewconf$ where 

%\paragraph{Abstract Configuration}:
%A abstract {\it configuration} of a program $\prog$ in the fragment of a single thread $\thread$
% is a tuple
%$\tuple{\tt c,\lambda, \Omega , S}$ where
%\begin{itemize}
%\item $\tt c$ is an observer configuration, 
%\item $\lambda$ is the label of the program statement, 
%\item $\tt \Omega$ is a tuple $\tt \tuple{\Omega_p, \Omega_l, Val}$ where $\tt \Omega_p$ contains a set ordering constrains between pointer variables, $\tt \Omega_l$ contains a set ordering constrains between data local variables and $\tt Val$ maps each data local variable to its value.
%\item $\tt S$ is a set of fragments.
%\end{itemize}
%
%% We use $\confsetof\prog$ to denote the set of configurations

\todo[inline]{Polish the inclusion of the observer!}

The symbolic postcondition computation must ensure that the symbolic
representation
of the reachable configurations of a program is closed under execution of a
statement by some thread.
So, assume a symbolic representation $\symbrep$. The symbolic
postcondition operation on $\symbrep$ produces an extension $\symbrep'$
of $\symbrep$, such that whenever $\sconf$ is a configuration with
$\sconf \satsymbrep \symbrep$, then any step from $\sconf$ must
lead to a configuration ${\sconf}'$ with ${\sconf}' \satsymbrep \symbrep'$.
Let $\thread$ be an arbitrary thread. Then $\sconf \satsymbrep \symbrep$
implies that $\domof{\symbrep}$ contains a pair
$\tuple{\locsymbconf,\ostate}$ such that
$\sconf \satlocsymbconf{\thread} \tuple{\locsymbconf,\ostate}$ and
$\sconf \satfragset{\thread} \symbrep(\tuple{\locsymbconf,\ostate})$. Our
symbolic postcondition computation must ensure that
%% this property still holds after any execution of a
%% statement by some thread, i.e., that
$\domof{\symbrep'}$ contains a pair
$\tuple{\locsymbconf',\ostate'}$ such that
${\sconf}' \satlocsymbconf{\thread} \tuple{\locsymbconf',\ostate'}$ and
${\sconf}' \satfragset{\thread} \symbrep(\tuple{\locsymbconf',\ostate'})$.
%% from which a step $\sconf \movesto{\system} {\sconf}'$, then ${\sconf}' \satsymbrep \symbrep'$.
%% More precisely, assume that a global configuration $\conf$ satisfies
%% a symbolic representation $\symbrep$. Let $\thread$ be an arbitrary thread.
%% Assume that there is
%% a local symbolic configuration $\locsymbconf \in \domof{\symbrep}$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf,\symbrep(\locsymbconf)}$.
%% it is still the case that
%% $\domof{\symbrep}$ contains a local symbolic configuration 
%% $\locsymbconf'$ such that
%% $\conf \satconf{\thread} \tuple{\locsymbconf',\symbrep(\locsymbconf)}$
%% for some thread $\thread$.
In the thread-modular approach, there are two cases to consider, depending
on which thread causes the step from $\sconf$ to ${\sconf}'$.
\begin{itemize}
\item
  {\it Local Steps:} The step
  is caused by $\thread$ itself executing a statement
  which may change its local state, the location of the observer,
  and the state of the heap.
  In this case, we first compute a local symbolic configuration $\locsymbconf'$ and
  observer location $\ostate'$, and a set $\fragset'$ of fragments such that
  ${\sconf}' \satlocsymbconf{\thread} \tuple{\locsymbconf',\ostate'}$ and
  ${\sconf}' \satfragset{\thread} \fragset'$,
  and then (if necessary) extend $\symbrep$ so that
  $\tuple{\locsymbconf',\ostate'} \in \domof{\symbrep}$ and
  $\fragset' \subseteq \symbrep(\tuple{\locsymbconf',\ostate'})$.
\item
  {\it Interference Steps:} The step is caseud by Another thread $\thread_2$,
  which may change the location of the observer (to $\ostate'$)
  and the state of the heap.
%%   such a way that makes it necessary to extend $\symbrep(\locsymbconf)$.
  By assumption, there is a local symbolic configuration $\locsymbconf_2$
  with $\tuple{\locsymbconf_2,\ostate} \in \domof{\symbrep}$ such that
  $\sconf \satconf{\thread_2} \tuple{\locsymbconf_2,\ostate,\symbrep(\locsymbconf_2)}$.
  We then compute a set $\fragset'$ of fragments such that
  the resulting configuration ${\sconf}'$ satisfies
  ${\sconf}' \satfragset{\thread} \fragset'$ and 
  make sure that $\fragset' \in \symbrep(\tuple{\locsymbconf,\ostate'})$.
  To do this, we first combine the the local symbolic configurations
  $\locsymbconf$ and $\locsymbconf_2$ and the sets of fragments
  $\symbrep(\locsymbconf)$ and $\symbrep(\locsymbconf_2)$, using an
%%   of $\thread_1$ and $\thread_2$ and then compute a representation of the
%%   the possible heaps whose projection onto $\thread_i$ satisfies
%%   $\symbrep(\locsymbconf_i)$ for $i=1,2$.
%% This is done by performing an
  operation called {\em intersection}, into
  a joint local symbolic configuration of $\thread$ and $\thread_2$ and
  a set $\fragset_{1,2}$ of fragments that represents the cells accessible
  to either $\thread$ or $\thread_2$.
  We thereafter symbolically compute the postcondition of the statement
  execution by $\thread_2$, in the same was as for local steps,
  and finally project the set of resulting fragments back onto $\thread$
  in the natural way, to obtain $\fragset'$.
\end{itemize}
In the following, we first describe the symbolic postcondition computation for
local steps, and thereafter the intersection operation.


\paragraph{Symbolic Postcondition Computation for Local Steps}
Let $\thread$ be an arbitrary thread, and assume
that $\tuple{\locsymbconf,\ostate} \in \domof{\symbrep}$.
For each statement that $\thread$ can execute in a configuration $\conf$
with $\sconf \satlocsymbconf{\thread} \tuple{\locsymbconf,\ostate}$ and
$\sconf \satfragset{\thread} \symbrep(\tuple{\locsymbconf,\ostate})$,
we must compute a local symbolic configuration $\locsymbconf'$, a new
observer location $\ostate'$ and a set  $\fragset'$ of fragments such that
such that the resulting configuration ${\sconf}'$ satisfies
  ${\sconf}' \satlocsymbconf{\thread} \tuple{\locsymbconf',\ostate'}$ and
  ${\sconf}' \satfragset{\thread} \fragset'$.
This computation has do be done differently for
each statement. For statements that do not affect the heap or pointer variables,
this computation is standard, and affects only the local symbolic
configuration, the observer location, and the $\vals$ component of
tags.
We therefore here describe how to compute the effect of statements that update
pointer variables or pointer fields of heap cells,
since these are the most interesting cases.

Let us fist consider a statement of form $\gvarof{g} := \lvarof{p}$,
which assigns the value of a local pointer variable $\lvarof{p}$ to a global
pointer variable $\gvarof{g}$. It is easy to update the $\pvars$ field of
tags to contain the variable $\gvarof{g}$ if and only if it contained the
variable $\lvarof{p}$ before the statement. 
The difficulty is to update the reachability information provided
by the fields $\reachfrom$ and $\reachto$ in each tag of a 
fragment, in particular whether $\gvarof{g}$ should be in such a
set after the statement
(if $\lvarof{p}$ would have been a global variable, the update would simply
reflect that $\gvarof{g}$ and $\lvarof{p}$ are now aliases, just as
in the update of $\pvars$).
In order to compute the postcondition with sufficient precision, we
%% However, since the $\reachfrom$ field does not include local variables, we
therefore investigate whether the set $\symbrep(\tuple{\locsymbconf,\ostate})$
of fragments allows to form a heap in which a $p$-cell can reach or be
reached from each tag of a fragment. It also checks whether a heap can be formed
in which a $p$-cell can not reach or be reached from such tags. For each
case that succeeds, the set $\fragset'$ will contain fragment with
corresponding content of $\reachto$ and $\reachfrom$ fields.

Our actual postcondition computation performs this investigation in a
systematic manner, by computing a set of transitive closure-like relations
between fragments.
First, define two tags
$\atag$ and $\atag'$ to be {\em consistent} if the concretizations of their
$\vals$-fields overlap, and if the other fields agree.
Thus, $\atag$ and $\atag'$ are consistent if there can exist a cell
$\cell$ accessible to $\thread$ in some heap,
with $\cell \satfrag{\thread}{\sconf} \atag$
and $\cell \satfrag{\thread}{\sconf} \atag'$.
%% \todo[inline]{To Quy: Can you really require that the data abstrations must
%%   be the same?}
Then, for two fragments $\frag_1$ and $\frag_2$ in a set $\fragset$ of fragments,
\begin{itemize}
\item let $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denote that $\outat{\frag_1}$   and $\inat{\frag_2}$ are consistent, and
  %% \todo[inline]{Quy: PLEASE  you provide the precise definition of when
  %%   $\tagat{\outat{\frag_1}}$ and $\tagat{\inat{\frag_2}}$ are consistent?}
  %% \quycom{They are consistent if they have same $\reachfrom$, $\reachto$, $\pvars$, $\private$, $\data$. This is for local thread. When we check for consistent between two tags when doing intersection, we have to define differently.}  
\item let $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denote that $\outat{\frag_1} = \outat{\frag_2}$ are consistent, and that either
  $\pvarsat{\inat{\frag_1}} \cap \pvarsat{\inat{\frag_2}} = \emptyset$ or that
  the global variables in  $\reachfromat{\inat{\frag_1}}$ are disjoint from
  those in $\reachfromat{\inat{\frag_2}}$.
  \bjcom{Question: Is this correct?}
%%   \quycom{$\reachfromat{\inat{\frag_1}} \cap \reachfromat{\inat{\frag_2}} = \emptyset$ here is not correct, we only need the global variables of reachfrom and reachto in this case}
%% \quycom{In my definition, the consistent here is defined for two views in the same threads. With the view from other thread, I use the notion of intersection.}
\end{itemize}
Intuitively, $\frag_1 \hookrightarrow_{\fragset} \frag_2$ denotes that it is
possible that  $\mathtt{next}(\cell_1) = \cell_2$ for some cells with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Intuitively, $\frag_1 \leftrightarrow_{\fragset} \frag_2$ denotes that it is
possible that
  $\mathtt{next}(\cell_1) = \mathtt{next}(\cell_2)$.
for different cells  $\cell_1$ and $\cell_2$ with
  $\cell_1 \lhd \frag_1$ and  $\cell_2 \lhd \frag_2$.
Note that the above definitions also work when some view(s) contain
$\nullconst$ or $\dangconst$.
We use these relations to define several derived relations:
%% \bjcom{We could use a common pattern for these and save space in definitions.}
\begin{itemize}
\item $\overset{+}\hookrightarrow_{\fragset}$ denotes the transitive closure
%%   of   $\hookrightarrow_{\fragset}$,
  and
   $\overset{*}\hookrightarrow_{\fragset}$ the reflexive transitive closure of
  $\hookrightarrow_{\fragset}$,
\item $\frag_1 \!  \overset{**}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that 
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{*+}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1', \frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{*\circ}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that $\exists \frag_1' \in \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2$ where
  $\frag_1 \!  \overset{*}\hookrightarrow_{\fragset} \frag_1'$,
\item $\frag_1 \!  \overset{++}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{+}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{+*}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1',\frag_2' \!\in\! \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2'$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1' \!$ and $\frag_2  \overset{*}\hookrightarrow_{\fragset} \! \frag_2'$,
\item $\frag_1 \!  \overset{+\circ}\leftrightarrow_{\fragset}  \! \frag_2$ denotes that
  $\exists \frag_1' \in \fragset$ with $\frag_1' \! \leftrightarrow_{\fragset} \! \frag_2$ where
  $\frag_1 \!  \overset{+}\hookrightarrow_{\fragset} \frag_1'$.
\end{itemize}
We say that $\frag_1$ and $\frag_2$ are {\em compatible} if $\frag_x \overset{*}\hookrightarrow \frag_y$ or $\frag_y \overset{*}\hookrightarrow \frag_x$ or $\frag_x \overset{**}\leftrightarrow \frag_y$. Intuitively, this means that $\frag_1$ and
$\frag_2$ can be satisfied by two cells in the same heap state.
\input viewrelations
\bjcom{Do we need to update the following example?}
Figure~\ref{fig:viewrelations} illustrates the above relations for a heap state
with $13$ heap cells. The figure shows 4 fragments that are satisfied by heap
cells, as denoted by green boxes, and how the relationship between heap cells
is reflect by relations between the corresponding fragments.

We can now describe how to perform the symbolic postcondition computations for
statements that assign to a pointer variable.

Consider a statement of form
${\tt x := y}$, where $\mathtt{x}$ and $\mathtt{y}$ are global or local
(to thread $\thread$) pointer variables. We must compute a set $\fragsetpost$ of
fragments which are satisfied by the configuration after the statement.
We must ensure that any cell $\cell$ which is accessible to $\thread$ after
the statement satisfies some fragment in $\fragsetpost$.
The cell $\cell$ must satisfy some
fragment $\frag$ in $\fragset$, and must be in the same heap state as
the cell pointed to by $\gvarof{y}$. 
This means that we can make a case analysis on the possible relationships
between $\frag$ and any fragment $\frag_y\in\fragset$ such that
$\mathtt{y} \in \pvarsat{\inat{\frag_y}}$.
Thus, for each fragment $\frag_y\in\fragset$ such that
$\mathtt{y} \in \pvarsat{\inat{\frag_y}}$ we let $\fragsetpost$ contain
the fragments obtained by the following transformations on fragments in
$\fragset$.
\begin{enumerate}
  \item
First, for the fragment $\frag_y$ itself, we let $\fragsetpost$ contain
$\frag'$, which is the same as $\frag_y$, except that
%% Let $\tt kill(x,v)$ be the procedure to remove $\tt x$ if it exists from
%% $\reachfromat{\inat{\frag}}$,
%% $\reachfromat{\outat{\frag}}$,
%% $\reachtoat{\inat{\frag}}$,
%% $\reachtoat{\outat{\frag}}$,
%% $\pvarsat{\inat{\frag}}$, and
%% $\pvarsat{\outat{\frag}}$.
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag_y}} \cup \set{x}$ and
  $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$
\end{itemize}
and furthermore, if $\gvarof{x}$ is a global variable, then
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ and
$\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ and
$\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$.
\end{itemize}
\item  for each fragment $\frag$ with $\frag \hookrightarrow_{\fragset} \frag_y$, let $\fragsetpost$ contain $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
\item We perform analogous inclusions for fragments $\frag$ with
  $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$,
  $\frag_y \overset{*}\hookrightarrow_{\fragset} \frag$,
  $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$, and
  $\frag_y \overset{*\circ}\leftrightarrow_{\fragset} \frag$. For space reasons,
  we show only the case of $\frag_y \overset{*+}\leftrightarrow_{\fragset} \frag$,
  in which case we let $\fragsetpost$ contain $\frag'$ which is same as $\frag$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$ if $\tt x$ is a global variable,
\end{itemize}
\end{enumerate}
The statement ${\tt x := y.next}$ is handled rather similarly to the preceding
case. Let us therefore describe the computation for statements of the form
${\tt x.next:= y}$.
This is the most difficult statement, since it is a destructive update of the heap. The statement affects reachability relations for both $\gvarof{x}$ and
$\gvarof{y}$. This means that we can make a case analysis on how a fragment
in $\fragset$ is related to some pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inat{\frag_x}}$, $\tt y \in \pvarsat{\inat{\frag_y}}$. 
Thus, for each pair of compatible fragments $\frag_x$, $\frag_y$ in $\fragset$ such that $\lvarof{x} \in \pvarsat{\inat{\frag_x}}$, $\tt y \in \pvarsat{\inat{\frag_y}}$, 
we let $\fragsetpost$ contain
the fragments obtained by the following transformations on fragments in
$\fragset$.
\begin{enumerate}
  \item
    First, let $\fragsetpost$ containt a new fragment $\frag_{new}$ of form
    $\fragtupleat{\frag_{new}}$
    $\tagat{\inat{\frag_{new}}} = \tagat{\inat{\frag_x}}$ and $\tagat{\outat{\frag_{new}}} = \tagat{\inat{\frag_y}}$ except that $\reachfromat{\outat{\frag_{new}}} = \reachfromat{\inat{\frag_y}} \cup \reachfromat{\inat{\frag_x}}$,
    and $\datarelat{\frag_{new}} = \set{<,=,>}$.
Thereafter, we add all possible fragments that can result from a transformation
of some fragment $\frag$ which is in $\frag$. This is done by an exhaustive
case analysis on the possible
relationship between $\frag$, $\frag_x$ and $\frag_y$.
Let us consider an interesting case, in which
$\frag_x \overset{*}\hookrightarrow_{\fragset} \frag$ and either $\frag \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\frag_y \overset{*+}\leftrightarrow \frag$.
In this case,
\begin{enumerate}
\item
  for each subset $\regset$ of observer registers in $\tt \reachfromat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$, we first create
  a fragment $\frag'$ which is same as $\frag$, except that $\reachfromat{\inat{\frag'}} = (\tt \reachfromat{\inat{\frag}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$.
\item
  Thereafter, 
for each set $\regset'$ of observer registers in $\reachfromat{\outat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$,  we let $\fragsetpost$ contain a fragment
$\frag''$ which is same as $\frag'$, except that $\reachfromat{\outat{\frag''}} = (\reachfromat{\outat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset'$. 
\end{enumerate}
\end{enumerate}
\todo[inline]{We should include an argument why the last case above is correct.
  Quy, could you produce one?}

\paragraph{Symbolic Postcondition Computation for Interference Steps.} 
The key step in this computation is
to form the intersection of two sets of fragments
$\fragset_1$ and $\fragset_2$, such that for the configuration $\conf$
we have $\conf \satfragset{\thread_i} \fragset_i$ for $i=1,2$.
In order to distinguish
between local variables of $\thread_1$ and $\thread_2$, we assume that local variable $\lvarof{x}$ of thread $\thread_i$ is named as $\lvarof{x[i]}$.
We must compute a set $\fragset$ which for each
heap cell accessible to either $\thread_1$ or $\thread_2$, the set $\fragset$ must
contain a fragment $\frag$ with $\cell \satfrag{1,2}{\sconf} \frag$.
\bjcom{This notation to be defined}
There are  here two possibilities.
\begin{itemize}
\item If $\cell$ is accessible to both $\thread_1$ and $\thread_2$, then
  there are fragments $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$
  such that $\cell \satfrag{1}{\sconf} \frag_1$ and $\cell \satfrag{2}{\sconf} \frag_2$.
  We use the notation $\frag_1 \sqcap \frag_2$ to denote a set of views such that
  whenever $\cell \satfrag{1}{\sconf} \frag_1$ and $\cell \satfrag{2}{\sconf} \frag_2$ then
  $\cell \satfrag{1,2}{\sconf} \frag$ for some $\frag \in (\frag_1 \sqcap \frag_2)$.
\item If $\cell$ is accessible to only one of $\thread_1$ and $\thread_2$,
  say $\thread_1$, then $\fragset$ should contain some fragment
  $\frag_1 \in \fragset_1$ with $\cell \satfrag{1,2}{\sconf} \frag_1$
  \bjcom{Check that we need not change $\frag_1$}
\end{itemize}
For a fragment $\frag$, define
$\greachfromat{\inat{\frag}}$ as the set of global variables in
$\reachfromat{\inat{\frag}}$. Define
$\greachtoat{\inat{\frag}}$,
$\greachfromat{\outat{\frag}}$,
$\greachtoat{\outat{\frag}}$,
$\gpvarsat{\inat{\frag}}$, and
$\gpvarsat{\outat{\frag}}$
analogously.
Define $\gtagat{\outat{\frag}}$ as the tuple
$\tuple{\gpvarsat{\outat{\frag}},\valsat{\outat{\frag}},\greachfromat{\outat{\frag}},\greachtoat{\outat{\frag}},\privateat{\outat{\frag}}}$.

\todo[inline]{Question to Quy: You have also used the notation
  $\gvalsat{\inat{\frag}}$. Will you need it, and if so what does it mean?} \quycom{Because in the data, I add data constraint between data fields and local data variable. When we do intersection, we do not need to care about this constraint because its local constraint}

Let us now describe how to compute  $\frag_1 \sqcap \frag_2$ for
two views $\frag_1 \in \fragset_1$ and $\frag_2 \in \fragset_2$.
Firstly, we consider the case where both $\frag_1$ and $\frag_2$ have size 2.
Let us consider some different cases.
They all take into account the  observation that if a cell $\cell$ satisfies
$\cell \satfrag{1}{\sconf} \frag_1$ and $\cell \satfrag{2}{\sconf} \frag_2$, then
the information about global variables in $\frag_1$ and $\frag_2$ must coincide.
 \begin{itemize}
 \item if $\greachfromat{\inat{\frag_1}} \neq \emptyset$ and $\greachfromat{\inat{\frag_2}} \neq \emptyset$ then the global information in $\frag_1$ and $\frag_2$ must coincide. We hence obtain:
  \begin{itemize}
  \item if $\gtagat{\inat{\frag_1}} = \gtagat{\inat{\frag_2}}$ and $\gtagat{\outat{\frag_1}} = \gtagat{\outat{\frag_2}}$ then $\frag_1 \sqcap v_2 = \set{\frag_{12}}$ where $\frag_{12}$ is identical to $\frag_1$ except that 
  \begin{itemize}
  \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$ 
  \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$
   \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
     \todo[inline]{Question to Quy: Why do this union only for $\pvars$ and $\reachfrom$, and not for $\reachto$ and $\vals$?}\quycom{we fixed this in the disscussion}
    \end{itemize}
  \todo[inline]{Question to Quy: Should we not have an ``else'' here, with
    $\frag_1 \sqcap \frag_2 = \emptyset$?}\quycom{we fixed this in the disscussion}
 \end{itemize}

 \item if $\greachfromat{\inat{\frag_1}} = \emptyset$, $\greachfromat{\inat{\frag_2}} = \emptyset$, $\greachfromat{\outat{\frag_1}} \neq \emptyset$ and $\greachfromat{\outat{\frag_2}} \neq \emptyset$ then 
  \begin{itemize}
  \item if $\gtagat{\outat{\frag_1}} = \gtagat{\outat{\frag_2}}$, $\privateat{\inat{\frag_1}} = \false$ and $\privateat{\inat{\frag_2}} = \false$ then $\frag_1 \sqcap \frag_2 = \set{\frag_1', \frag_2', \frag_{12}}$ where
      %$\frag_{12}$ is same as $\frag_1$ except that 
%    \begin{itemize}
%  \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$ 
%  \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
%  \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$
%   \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
%    \end{itemize} and
      \begin{itemize}
      \item
        $\frag_1'$ is same as $\frag_1$ except that 
    \begin{itemize}
  \item  $\pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\reachfromat{\outat{\frag_1'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
    \end{itemize}
  \item
    $\frag_2'$ is same as $\frag_2$ except that 
    \begin{itemize}
  \item  $\pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\reachfromat{\outat{\frag_2'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
    \end{itemize}
  \item
    $\frag_{12}$ is as in the previous case.
    \bjcom{to Quy: I added this, is it correct?}
      \end{itemize}
    \item if $\gtagat{\outat{\frag_1}} = \gtagat{\outat{\frag_2}}$ and $\privateat{\inat{\frag_1}} = \true$ or $\privateat{\inat{\frag_2}} = \true$ then $\frag_1 \sqcap \frag_2 = \set{\frag_1', \frag_2'}$ where
$\frag_1'$ and $\frag_2'$ are as above.
 \end{itemize}
 
 \item if $\greachfromat{\inat{\frag_1}} = \emptyset$, $\greachfromat{\inat{\frag_2}} = \emptyset$, $\greachfromat{\outat{\frag_1}} = \emptyset$ and $\greachfromat{\outat{\frag_2}} = \emptyset$ then 
 \begin{itemize}
 \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\privateat{\inat{\frag_1}} = false$, $\privateat{\outat{\frag_1}} = false$, $\privateat{\outat{\frag_1}} = false$ and $\privateat{\outat{\frag_2}} = false$ then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2',\frag_{12}\}$ %where $\frag_{12}$ is same as $\frag_1$ except that 
   % \begin{itemize}
 % \item $\pvarsat{\inat{\frag_{12}}} = \pvarsat{\inat{\frag_1}} \cup \pvarsat{\inat{\frag_2}}$ 
 % \item  $\pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
 % \item $\reachfromat{\inat{\frag_{12}}} = \reachfromat{\inat{\frag_{1}}} \cup \reachfromat{\inat{\frag_{2}}}$
 %  \item $\reachfromat{\outat{\frag_{12}}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
 %   \end{itemize} and 
 %   $\frag_{1'}$ is same as $\frag_1$ except that 
 %   \begin{itemize}
 % \item  $\pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \frag_2.vars(j_o)$
 % \item $\reachfromat{\outat{\frag_1'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
 %   \end{itemize}
 %  and $\frag_2'$ is same as $\frag_2$ except that 
 %   \begin{itemize}
 % \item  $\pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \frag_2.vars(j_o)$
 % \item $\reachfromat{\outat{\frag_2'}} = \reachfromat{\outat{\frag_{1}}} \cup \reachfromat{\outat{\frag_{2}}}$
 %   \end{itemize}
    
    
   \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, ($\privateat{\inat{\frag_1}} = true$ or $\privateat{\inat{\frag_2}} = true$) and $\privateat{\outat{\frag_1}} = false$ and $\privateat{\outat{\frag_2}} = false$ then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2'\}$  

  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\privateat{\outat{\frag_1}} = true$ or $\privateat{\outat{\frag_1}} = true$) then  $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$ 

    \item if $\tt gtag(\frag_1, o) \neq gtag(\frag_2, o)$ then $\frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$
 \end{itemize}
 
 \end{itemize}


 \section{Fragment Abstraction for  Skip-Lists}

 \todo[inline]{Here goes a description of the fragment abstraction for
   skip lists}
   \begin{itemize}
  \item In the fragment abstraction, $\tt tag$ is define exactly same as $\tt tag$ in SLL abstraction where $\reachfrom$ and $\reachto$ is defined based on the main level of skip-list. It means that we do not keep the reachability information in higher levels.
  \item Same as timestamp stacks and queues, in skip-list we keep the main level and abstract all the higher levels. It means that we do not distinguish the differences between high levels. Hence, we have two types of fragments including main level fragments and higher level fragments which are defined same as SLL fragments. 
   \end{itemize}
 \begin{figure}  
 \input skiplistshape  
 \caption{A concrete shape of 3-level skipl-list with two threads}
\end{figure}

 \begin{figure}  
 \input skiplistabs 
 \caption{skipl-list fragments \quycom{i am working with this figure}}
\end{figure}
\subsection{Abstract transformers for skip-lists}
Let us show how to perform the abstract transformer for skip-list programs on the set of fragments $\fragset$ depending on the particular statement.  We consider fragments of size $2$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \{{o}\}$, and $\tt next(i) = {o}$ and fragments of size $1$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \emptyset$, and $\tt next(i) = null$ or $\tt next(i) = \bot$. For each fragment $\tt v$, let $\tt v.level \in \{1,2\}$ be the level of $\tt v$.

\paragraph{Local Abstract Transformers:} First, let us show the abstract transformer on the set of fragment $\fragset$ in the fragment of the concurrent thread. Let $\fragset_1$ be set of fragments of level 1 in $\fragset$, $\fragset_2$ be set of fragments of level 2 in $\fragset$. For each program statement, let $\fragset_{post}$ be the set of fragments after executing the statement. Let $\fragset_{post}$ be initialized as the empty set.  Let $\tt R$ be the set of pairs of fragments. Intuitively, in each element in $\tt R$, the second fragment is the transformation of the first fragment. Let $\tt R$ be initialized as the empty set.
\begin{itemize}
\item ${\tt x := y}$: The transformer is performed as follows:  For each fragment $\tt \frag_y \in \fragset_1$ where $\tt y \in\pvarsat{\inat{ \frag_y}}$, 
%\begin{itemize}
\begin{enumerate}
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item for each fragment $\tt v$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*\circ}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
\item create $\tt v'$ which is same as $\tt \frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \cup \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\\gvarof{x}$ is a global variable
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\fragset'$
%\item for each fragment $\tt v'$ in $\fragset_{post}$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
\item for each fragment $\tt v \in \fragset_2$ we do as follows. For each $\tt (\frag_1,\frag_1')$, $\tt (\frag_2,\frag_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, and $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \frag_1'.i_1.vars$,
\item $\pvarsat{\outat{\frag'}} = \frag_2'.i_2.vars$,

\item $\reachfromat{\inat{\frag'}} = \frag_1'.i_1.reachfrom$,
\item $\reachfromat{\outat{\frag'}} = \frag_2'.i_2.reachfrom$,
\item $\reachtoat{\inat{\frag'}} = \frag_1'.i_1.reachto$,
\item $\reachtoat{\outat{\frag'}} = \frag_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\fragset_{post}$. 
\end{enumerate}
%\item If there does not exist such $\tt \frag_y$ in $\fragset_1$
%\end{itemize}
%\begin{enumerate}
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%%\begin{itemize}
%%\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
%%\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
%%\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
%% \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
%%\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\fragset_{post}$,
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%%\begin{itemize}
%%\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
%%\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
%%\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
%% \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
%%\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\fragset_{post}$,
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,i)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$ 
%\end{itemize}
%
%%4%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%5%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%6%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%7%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%8%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%9%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%10%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%11%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%12%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ} \leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%\end{enumerate}
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X := Y.NEXT1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item ${\tt x := y.next1}$: The local abstract transformer is quite similar to the previous case with slightly differences. For each fragment $\tt \frag_y \in S$ where $\tt y \in {\tt vars}(\tt i)$,
%\begin{enumerate}
%
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%\end{itemize}
%
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_y,o)$,
%	\item $\tt tag(v,i) = tag(\frag_1,i)$ where $\tt \frag_y \overset{+}\hookrightarrow_{\fragset} \frag_1$ 
%\end{itemize}
%
%%-------------------------------------------4------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%-------------------------------------------5------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-------------------------------------------6------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1 \overset{*}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_1 = \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%-------------------------------------------7-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%------------------------------------------8-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-----------------------------------------9-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_1$ or $\tt \frag_1 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%%-----------------------------------------10-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_2 \overset{*}\hookrightarrow_{\fragset} \frag_y$,
%\end{itemize}
%
%
%%-----------------------------------------11-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$  where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} \frag_2$ or $\tt \frag_2 \overset{*\circ}\leftrightarrow_{\fragset} \frag_y$
%\end{itemize}
%
%
%%-----------------------------------------12-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(\frag_1,i)$ where $\tt \frag_1y\overset{*}\hookrightarrow_{\fragset} \frag_1$,
%	\item $\tt tag(v,i) = tag(\frag_2,i)$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} \frag_2$ 
%\end{itemize}
%
%
%\end{enumerate}




\begin{enumerate}
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{*}\hookrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ then
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \cup \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize} 
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$

\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{+}\hookrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \cup \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*\circ}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*+}\leftrightarrow_{\fragset} v$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \{x\{$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$ ,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \setminus \set{x}$,
\item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \setminus \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{+\circ}\leftrightarrow_{\fragset} \frag_y$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \setminus \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \setminus \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$

\item create $\tt v'$ which is same as $\tt \frag_y$ except that
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \pvarsat{\inat{\frag}} \setminus \set{x}$,
\item $\pvarsat{\outat{\frag'}} = \pvarsat{\outat{\frag}} \cup \set{x}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag}} \setminus \set{x}$,
\item $\reachtoat{\inat{\frag'}} = \reachtoat{\inat{\frag}} \cup \set{x}$,
 \item $\reachfromat{\outat{\frag'}} = \reachfromat{\outat{\frag}} \cup \set{x}$,
 \item $\reachtoat{\outat{\frag'}} = \reachtoat{\outat{\frag}} \cup \set{x}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\fragset_{post}$, and $\tt (v,v')$ to $\tt R$
%\item for each fragment $\tt v'$ in $\fragset_o$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
%

\item for each fragment $\tt v \in \fragset_2$ we do as follows. For each $\tt (\frag_1,\frag_1')$, $\tt (\frag_2,\frag_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, and $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \frag_1'.i_1.vars$,
\item $\pvarsat{\outat{\frag'}} = \frag_2'.i_2.vars$,

\item $\reachfromat{\inat{\frag'}} = \frag_1'.i_1.reachfrom$,
\item $\reachfromat{\outat{\frag'}} = \frag_2'.i_2.reachfrom$,
\item $\reachtoat{\inat{\frag'}} = \frag_1'.i_1.reachto$,
\item $\reachtoat{\outat{\frag'}} = \frag_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\fragset_{post}$. 
\end{enumerate}	




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X.NEXT1 := Y %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item  ${\tt x.next1:= y}$: The local abstract transformer is performed by several steps as follows: For each pair of fragments $\frag_x$, $\tt \frag_y$ in $\fragset_1$ where $\tt x \pvarsat{\inat{\in \frag_x}}$, $\tt y \in\pvarsat{\inat{ \frag_y}}$, and $\frag_x \overset{*}\hookrightarrow \frag_y$ or $\tt \frag_y \overset{*}\hookrightarrow \frag_x$ or $\frag_x \overset{**}\leftrightarrow \frag_y$, let $\tt R_1$, $\tt R_2$, $\tt R_3$, $\tt R_4$, $\tt R_5$, $\tt R_6$ be initialized as $\tt R$,  
\begin{enumerate}
\item let $\tt \frag_{new}$ be the fragment of size 2 and of level 1 where $\tt tag(\frag_{new},i) = tag(\frag_x, i)$ and $\tt tag(\frag_{new},o) = tag(\frag_y,i)$ except that $\tt \reachfromat{\outat{\frag_{new}}} = \reachfromat{\inat{\frag_y}} \cup \reachfromat{\inat{\frag_x}}$,
\item  for each fragment $\tt v \in \fragset_1$ where $\tt v \overset{*}\hookrightarrow_{\fragset} \frag_x$, we do as follows: For each subset $\regset$ of observer registers in $\reachtoat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$


\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that
\begin{itemize}
\item $\reachtoat{\inat{\frag'}} = (\tt \reachtoat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}) \cup \reachto{\inat{\frag_y}} \cup \regset$.
\item $\reachtoat{\outat{\frag'}} = (\tt \reachtoat{\outat{\frag}} \cap \reachfromat{\inat{\frag_x}}) \cup \reachto{\inat{\frag_y}} \cup \regset$.
\end{itemize}
\item add $\tt v'$ to $\fragset_{post}$ 
\item add $\tt (v,v')$ to $\tt R_1$
\end{itemize}

\item for each fragment $\tt v \in \fragset_1$ where $\tt \frag_y \overset{*}\hookrightarrow_{\fragset} v$ or $\tt \frag_y = v$, 
\begin{itemize}
	\item create  $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
 \item $\tt \reachfromat{\inat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\inat{\frag}}$, 
\item $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
\end{itemize}
\item add $\tt v'$ to $\fragset_{post}$,
\item add $\tt (v,v')$ to $\tt R_2$
\end{itemize}
\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} v$ and either $\tt v \hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*o}\leftrightarrow_{\fragset} v$, 
\begin{itemize}
\item  create $\tt v'$ which is same as $\tt v$ except that $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
 \item add $\tt v'$ to $\fragset_{post}$, 
 \item add $\tt (v,v')$ to $\tt R_3$

\end{itemize}


\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} v$ and either $\tt v \hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*o}\leftrightarrow_{\fragset} v$,  
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$ then except that $\tt \reachfromat{\outat{\frag'}} = \reachfromat{\inat{\frag_x}} \cup \tt \reachfromat{\outat{\frag}}$, 
\item for each subset $\regset$ of observer registers in $\reachfromat{\inat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\reachfromat{\inat{\frag''}} = (\reachfromat{\inat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$.
\item add $\tt v''$ to $\fragset_{post}$,
\item add $\tt (v,v'')$ to $\tt R_4$
\end{itemize}
\end{itemize}

\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{**}\leftrightarrow_{\fragset} v$ and either $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\tt v \overset{*+}\leftrightarrow_{\fragset} \frag_y$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$
\item  add $\tt v'$ to $\fragset_{post}$,
\item add $\tt (v,v')$ to $\tt R_5$

\end{itemize}


\item for each fragment $\tt v \in \fragset_1$ where $\frag_x \overset{*}\hookrightarrow_{\fragset} v$ and either $\tt v \overset{+}\hookrightarrow_{\fragset} \frag_y$ or $\tt \frag_y \overset{*+}\leftrightarrow v$, then for each subset $\regset$ of observer registers in $\tt \reachfromat{\inat{\frag}} \cap \reachfromat{\inat{\frag_x}}$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that $\reachfromat{\inat{\frag'}} = (\tt \reachfromat{\inat{\frag}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset$. 
 \item for each set $\regset'$ of observer registers in $\reachfromat{\outat{\frag'}} \cap \reachfromat{\inat{\frag_x}}$,  
\begin{itemize}
\item create $\frag''$ which is same as $\frag'$, except that $\reachfromat{\outat{\frag''}} = (\reachfromat{\outat{\frag'}} \setminus \reachfromat{\inat{\frag_x}}) \cup \regset'$. 
\item add $\frag''$ to $\fragset_{post}$
\item add $\tt (v,v'')$ to $\tt R_6$
\end{itemize}
\end{itemize}
\item add $\tt \frag_{new}$ to $\fragset_{post}$ 
\end{enumerate}

\item for each fragment $\frag \in \fragset_2$ then we do as follows. for each $\tt (\frag_1,\frag_1') \in R_i$, $\tt (\frag_2,\frag_2') \in R_j$ where $\tt i \neq j$ and $\tt 1 \leq i,j \leq 6$. For each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{\frag_1.i, \frag_1.o\}$, $\tt i_2 \in \{\frag_2.i, \frag_2.o\}$, $\tt tag(v,i) = tag(\frag_1, i_1)$, $\tt tag(v,o) = tag(\frag_2, i_2)$. Create $\frag'$ which is same as $\frag$ except that 
\begin{itemize}
\item $\pvarsat{\inat{\frag'}} = \frag_1'.i_1.vars$,
\item $\pvarsat{\outat{\frag'}} = \frag_2'.i_2.vars$,

\item $\reachfromat{\inat{\frag'}} = \frag_1'.i_1.reachfrom$,
\item $\reachfromat{\outat{\frag'}} = \frag_2'.i_2.reachfrom$,
\item $\reachtoat{\inat{\frag'}} = \frag_1'.i_1.reachto$,
\item $\reachtoat{\outat{\frag'}} = \frag_2'.i_2.reachto$,
\end{itemize} then add $\frag'$ to $\fragset_{post}$. 


\newpage
 \end{itemize}
 
 \paragraph{Fragment Intersection:} Let us describe the intersection of two fragments $\tt \frag_1 \in \fragset_1$ and $\tt \frag_2 \in \fragset_2$ denoted as $\tt \frag_1 \sqcap \frag_2$. Firstly, we consider the case where both $\tt \frag_1$ and $\tt \frag_2$ have size 2.
 \begin{itemize}
 \item if $\tt \frag_1.greachfrom(i,\{1,2\}) \neq \emptyset$ and $\tt \frag_2.greachfrom(i,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(\frag_1, i) = gtag(\frag_2, i)$ and $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_{12}\}$ where $\tt \frag_{12}$ is same as $\tt \frag_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$ 
  \begin{itemize}
  \item $\tt \frag_{12}.vars(i) = \frag_1.vars(i) \cup \frag_2.vars(i)$ 
  \item  $\tt \pvarsat{\outat{\frag_{12}}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_{12}.reachfrom(i,l) = \frag_{1}.reachfrom(i,l) \cup \frag_{2}.reachfrom(i,l)$
   \item $\tt \frag_{12}.reachfrom(i,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
 \end{itemize}

 \item if $\tt \frag_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_1.greachfrom(o,\{1,2\}) \neq \emptyset$ and $\tt \frag_2.greachfrom(o,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\tt \frag_1.private(i) = false$ and $\tt \frag_2.private(i) = false$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1', \frag_2', \frag_{12}\}$ where %$\tt \frag_{12}$ is same as $\tt \frag_1$ except that 
  $\tt \frag_1'$ is same as $\tt \frag_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$
    \begin{itemize}
  \item  $\tt \pvarsat{\outat{\frag_1'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_1'.reachfrom(o,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
   and $\tt \frag_2'$ is same as $\tt \frag_2$ except that 
    \begin{itemize}
  \item  $\tt \pvarsat{\outat{\frag_2'}} = \pvarsat{\outat{\frag_1}} \cup \pvarsat{\outat{\frag_2}}$
  \item $\tt \frag_2'.reachfrom(o,l) = \frag_{1}.reachfrom(o,l) \cup \frag_{2}.reachfrom(o,l)$
    \end{itemize}
     \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\tt \frag_1.private(i) = true$ or $\tt \frag_2.private(i) = true$) then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1', \frag_2'\}$ 
 \end{itemize}
 
 
  \item if $\tt \frag_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt \frag_1.greachfrom(o,\{1,2\}) = \emptyset$ and $\tt \frag_2.greachfrom(o,\{1,2\}) = \emptyset$ then 
 \begin{itemize}
 
 
 \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, $\tt \frag_1.private(i) = false$, $\tt \privateat{\outat{\frag_1}} = false$, $\tt \privateat{\outat{\frag_1}} = false$ and $\tt \privateat{\outat{\frag_2}} = false$ then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2',\frag_{12}\}$ %where $\tt \frag_{12}$ is same as $\tt \frag_1$ except that 
    \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$, ($\tt \frag_1.private(i) = true$ or $\tt \frag_2.private(i) = true$) and $\tt \privateat{\outat{\frag_1}} = false$ and $\tt \privateat{\outat{\frag_2}} = false$ then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2,\frag_1',\frag_2'\}$  

  \item if $\tt gtag(\frag_1, o) = gtag(\frag_2, o)$ and ($\tt \privateat{\outat{\frag_1}} = true$ or $\tt \privateat{\outat{\frag_1}} = true$) then  $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$ 

    \item if $\tt gtag(\frag_1, o) \neq gtag(\frag_2, o)$ then $\tt \frag_1 \sqcap \frag_2 = \{\frag_1,\frag_2\}$
 \end{itemize}
 
 \end{itemize}



%
