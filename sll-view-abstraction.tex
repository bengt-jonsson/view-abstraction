\begin{center}
\begin{figure}
\input{sll-lazy-list-shape}
\caption{Example of Fragment Abstraction}
\label{lazylist}
\end{figure}
\end{center}
\section{Fragment Abstraction: Singly Linked Lists}
\label{sec:annotations}
This section describes how we employ fragment abstraction as a symbolic
representation of an unbounded heap and data domain in
thread-abstracted configurations. In this section, we describe how this is done
for singly linked lists, i.e., where each heap cell contains exactly one
$\intgrs$-field.

\todo[inline]{The two pictures must be merged}

So, consider a program with global variables $\glvarset$ and thread-local variables $\tvarset$. Consider a cell $\cell$, which is reachable from thread $t$.
Define
\begin{itemize}
\item
  $\pvarsof{\cell}$ is the set of (global or local) pointer variables of that
  point to $\cell$,
\item
  $\valsof{\cell}$ maps each $\mathbb{F}$-field $\field$ of $\cell$ to its value
  $\cellval(\cell,\field)$, and maps each $\intgrs$-field $\field$ to
  a mapping from $\intgrs$-terms to a subset of $\set{<, =, >}$
  \bjcom{Fix This}
\item
  $\reachfromof{\cell}$ is the set of
  \begin{inparaenum}[(a)]
\item global variables from which $\cell$ is reachable via a (possibly empty)
  sequence of {\tt next} pointers, and
\item observer registers whose value is equal to the value of the $\intgrs$-field of some cell from which $\cell$ is reachable.
  \end{inparaenum}
\item
  $\reachtoof{\cell}$ is the set of
  \begin{inparaenum}[(a)]
\item global variables which are reachable via a (possibly empty)
  sequence of {\tt next} pointers from $\cell$ is reachable, and 
\item observer registers whose value is equal to the value of the $\intgrs$-field of some cell which is reachable from $\cell$.
  \end{inparaenum}
\item
  $\privateof{\cell}$ is a boolean value, which is $\true$ if
  the cell represented by $\tt i$ can be seen only by the current thread.
\end{itemize}
A {\em tag} is a tuple
$\tagtuple$, where
\begin{itemize}
\item
  $\pvars$ is a set of (global or local) pointer variables,
\item
  $\vals$ is a mapping from fields, which maps each $\mathbb{F}$-field of cells to its appropriate domain, and each $\intgrs$-field to a mapping from $\intgrs$-terms to a subset of $\set{<, =, >}$,
 \item
   $\reachfrom$ and $\reachto$ are sets of global variables and observer registers, and
  \item $\private$ is a boolean value.
\end{itemize}
Let $\cell$  be a cell in a projection onto a thread $t$. Define the {\em tag} of
$\cell$, denoted $\tagof{\cell}$ as the tuple $\tagtupleof{\cell}$.

\bjcom{The following should be included more smoothly, if really needed}
Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$.

We can now define the concept of fragment.
An {\em SLL-fragment} is a triple
$\sllviewtuple$, where $\inputtag$ and $\outputtag$ are tags, and $\datarel$
is a subset of $\set{<, =, >}$.

Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
  
$\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. 

We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments, and any heap is ``broken down into pre-defined fragments''. A fragment retains the information about a particular part of a heap. This choice of fragments defines the level of abstraction that transforms heap into fragments. The abstract function $\alpha_k$ maps a heap into a set of fragments. Whereas, the concretization function $\gamma_k$ inputs a set of fragments, and returns the set of heaps that can be reconstructed from these fragments. 
\paragraph{Example:} Let us show an example of how a singly linked list (SLL) is split into a set of fragments. Fig.~\ref{lazylist}(a) shows an example of a concrete shape of a singly linked list. Each cell contains the values of $\tt val$, $\tt mark$, and $\tt lock$ from top to bottom, where \tick \; denotes $\tt true$, and \cross \; denotes $\tt false$ (or $\tt free$ for $\tt lock$) and the value of $\tt val$ is denoted by a pair of the observer register $\tt z$ and a subset of $\set{<, =, >}$. There are two threads $1$ and $2$ with two local variables $\tt c_1$ and $\tt c_2$. There are two global variables $\tt H$ and $\tt T$ pointing to the head and tail of the list. The observer register $\tt z$ has value 8. Fig.~\ref{lazylist}(b) shows the result of splitting the list in Fig.~\ref{lazylist}(a) into fragments where each heap fragment is a small list of two nodes. Fig.~\ref{lazylist}(c) shows the abstraction of fragments in Fig.~\ref{lazylist}(b) where for each cell $\cell$, the value of $val$ is abstracted to a subset in $\tt \{<z, =z, >z\}$, the reachability relation between $\cell$ and global variables and observer registers is abstracted to the predicate $\tt X \mapsto \tt Y$ where $\tt X$, $\tt Y$ are sets of global variables and observer registers, $\tt i$ or $\tt o$ states that $\cell$ is an input or output cell.

\paragraph{Fragment Definition:} A heap fragment of size $\tt k$ is represented as \begin{center}
	${\tt v} = \viewconf$ where 
\end{center} 

%We first introduce the abstraction at the heart of the method. The abstraction takes its input as a set of pre-defined fragments parameterized by a constant $\tt k$, and any heap is “broken down into pieces” of size (at most) k, called fragments. A fragment retains the information about $\tt k$ connected cells from a heap and abstracts away the other cells. This choice defines the level of abstraction that transforms heap into fragments.There is a certain freedom in what information to retain and what to abstract away. The abstract function $\alpha_k$ maps a heap into a set of heap fragments of sizes $\tt k$. The concretization function $\gamma_k$ inputs a set of heap fragments, and returns the set of heaps that can be reconstructed from the these fragments. Let us represent symbolic representations of heap fragments. A heap fragment of size $\tt k$ is represented as ${\tt \Omega} = \viewconf$ where 
\begin{itemize}
% \item $\tt key$ maps each pair of pointer variables to a subset of $\set{<, =, >}$,
% \item $\mathbb{I}$ is a tuple  $\tuple{\tt I, i, o}$ where $\tt I$ is a finite set of $\tt k$ {\em indices}, representing cells. The two sets $\tt i \subseteq I $ and $\tt o \subseteq I$ with $\tt i \cap o = \emptyset$ are sets of {\em input} and {\em output} indices representing {\em input} and {\em output cells}.
 \item $\tt I$ is the partitioning of $\tt I_{inp}$, $\tt I_{out}$ and $\tt I_{int}$ where $\tt I_{inp}$ and $\tt I_{out}$ are sets of {\em input} and {\em output} indices representing {\em input} and {\em output} cells, $\tt I_{int}$ is the set of indices representing {\em internal} cells.

 \item $\tt next$ maps each index in $\tt I_{inp} \; \cup \; \tt I_{int}$ to a value in $\indices \; \cup \; \{\tt null, \bot\}$. Intuitively, $\tt next(i)$ represents the successor of the cell represented by $\tt i$.
%\item $\tt next: \tt I_{inp} \cup \tt I_{int} \mapsto \tt I_{inp} \cup \tt I_{int} \cup \{\tt null, \bot\}$ maps each index in $\indices / \indices_{\tt o}$ to a value in $\indices \cup \{\tt null, \bot\}$. Intuitively, $\tt next(i)$ represents the successor of the cell represented by $\tt i$.


\item
  ${\tt vars}$ maps each index to a set of (global or local) pointer variables.
\item
  ${\tt data}$ maps each $\mathbb{F}$-field value of cells to their appropriate domains, and each $\intgrs$-field to a mapping from $\intgrs$-terms to a subset of $\set{<, =, >}$.
%\item
  %${\tt Val}^{\tt g}$ maps an index in $\indices \setminus \{\tt i_\bot, \tt i_{null}\}$ to an set of global variables. Intuitively, ${\tt Val}^{\tt g}(\tt i) = \{\tt v_1,v_2,..,v_n\}$ if $\cell_{\tt i}$ is reachable from the cells pointed by $\tt v_1$, $\tt v_2$,..,$\tt v_n$. 

%\item
%  ${\tt reachfrom}$ maps each index $\tt i$ in $\indices$ to a predicate, formed as a pair $\tt (X,Y)$ where, letting $\cell_{\tt i}$ be the cell represented by $\tt i$,
%   \begin{itemize}
% \item $\tt X$ is the set of (i) global variables from which $\cell_{\tt i}$ is reachable by at least one step, and
%  (ii) observer registers whose values are equal to $\intgrs$-field values of cells from which $\cell_{\tt i}$ is reachable by at least one step.
%  \item $\tt Y$ is the set of
%  (i) global variables which are reachable from $\cell_{\tt i}$ by at least one step, and
%  (ii) observer registers whose values are equal to $\intgrs$-field values of cells which are reachable from $\cell_{\tt i}$ by at least one step.
%\end{itemize}
 
 \item
  ${\tt reachfrom}$ maps each index $\tt i \in \indices$ to a set of (a) global variables from which $\tt i$ is reachable, and
  (b) observer registers whose values are equal to $\intgrs$-field values of cells from which $\tt i$ is reachable.
\item  ${\tt reachto}$ maps each index $\tt i \in \indices$ to a set of
  (a) global variables which are reachable from $\tt i$, and
  (b) observer registers whose values are equal to $\intgrs$-field values of cells which are reachable from $\tt i$.
 \item $\tt \phi$ maps each pair of indices to a subset of $\set{<, =, >}$. Intuitively, $\tt \phi(i_1, i_2)$ presents the ordering between $\tt i_1.d$ and $\tt i_2.d$ for  $\intgrs$-field $\tt d$.
  \item $\tt private$ maps each index $\tt i \in \indices$ to a boolean value. Intuitively, if $\tt private(i) = true$ then the cell represented by $\tt i$ can be seen only by the concurrent thread.
 
  \end{itemize}
For a fragment $\tt v$ and index $\tt i$, let $\tt tag(v,i)$ be the tuple $\tt \tuple{\tt vars(i), data(i),{\tt reachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$. Let $\tt gtag(v,i)$ be the tuple $\tt \tuple{\tt gvars(i), gdata(i),{\tt greachfrom}(\tt i), {\tt reachto}(\tt i), private(i )}$ where $\tt gvars(i)$ is the set of global variables in $\tt vars(i)$ and $\tt greachfrom(i)$ is the set of global variables in $\tt reachfrom(i)$. Note that in each fragment $\tt v$, for two indices $\tt i_1$, $\tt i_2$ where $\tt next(i_1) = i_2$, we always have $\tt {\tt reachfrom}(\tt i_1) \subseteq \tt {\tt reachfrom}(\tt i_2)$ and $\tt {\tt reachto}(\tt i_1) = \tt {\tt reachto}(\tt i_2) \cup X$ where $\tt X$ is the set of global variables in ${\tt vars}(\tt i_1)$ and observer registers $\tt z$ which are equal to $\tt i_1.d$ for $\intgrs$-field $\tt d$. 
%\paragraph{Abstract Configuration}:
%A abstract {\it configuration} of a program $\prog$ in the fragment of a single thread $\thread$
% is a tuple
%$\tuple{\tt c,\lambda, \Omega , S}$ where
%\begin{itemize}
%\item $\tt c$ is an observer configuration, 
%\item $\lambda$ is the label of the program statement, 
%\item $\tt \Omega$ is a tuple $\tt \tuple{\Omega_p, \Omega_l, Val}$ where $\tt \Omega_p$ contains a set ordering constrains between pointer variables, $\tt \Omega_l$ contains a set ordering constrains between data local variables and $\tt Val$ maps each data local variable to its value.
%\item $\tt S$ is a set of fragments.
%\end{itemize}
%
%% We use $\confsetof\prog$ to denote the set of configurations

\section{Abstract transformers for singly linked lists}
%For each operation $\tt op$ in the intermediate representation of the analysed program corresponding to the function $\tt f_{\tt op}$ on concrete configurations $\tt F =\tuple{\athreads,\lstatemapping,\heap}$ , we define an abstract transformer ${\tt \Gamma}_{\tt op}$ on a set of fragments $\tt A$ such that the result of ${\tt \Gamma}_{\tt op}(A)$ denotes the set $\tt f_{\tt op}(F)$. Let us present the abstract transformers corresponding to some operations on the set $\mathbb A$. Two fragments $\tt \Omega_1$ and $\tt \Omega_2$ are relevant if (I) they have the same program counter and observer register and (II) their global relationship are consistent. The abstract transformer is performed by several following steps:
%\begin{enumerate}
%\item Combine all relevant fragments $\tt \Omega_1$,..,$\tt \Omega_n \in \mathbb A$ which contains variables appearing in the operation. Let $\tt \Omega^c_1$,..,$\tt \Omega^c_m$ be the result of the combination.
 %\item For each fragment $\tt \Omega^c_i$ where $0 \leq \tt i \leq m$, compute the abstract transformer $\tt \Omega_p = {\Gamma}_{\tt op}(\tt \Omega^c_i)$, then split $\tt \Omega_p$ into set of new fragments 
%\end{enumerate}
Let us show how to perform the abstract transformer for singly linked list programs on the set of fragments $\tt S$ depending on the particular statement. In this case, we consider fragments of size $2$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \{o\}$,$\tt I_{int} = \emptyset$ and $\tt next(i) = o$, and fragments of size $1$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \emptyset$, $\tt I_{int} = \emptyset$ and $\tt next(i) = null$ or $\tt next(i) = \bot$. Before describing in detail to compute abstract transformers, let us define several important concepts.

%\paragraph{Index Consistency:} Let $\tt i_1 \equiv i_2$ denotes that $\tt i_1$ and $\tt i_2$ are equivalent. Intuitively, $\tt i_1 \equiv i_2$ iff  ${\tt Val}^{\tt v}(\tt i_1) = {\tt Val}^{\tt v}(\tt i_2)$, ${\tt Val}^{\tt d}(\tt i_1) = {\tt Val}^{\tt d}(\tt i_2)$, $\tt private(i_1) = private(i_2)$ and $\tt \Phi(i_1.d, z) = \Phi(i_2.d, z)$ for every $\intgrs$-field $\tt d$ and $\intgrs$-term $\tt z$.  The indices $\tt i_1$ and $\tt i_2$ are consistent if they satisfy one of those conditions below
%\begin{itemize}
%	\item $\tt i_1$ is an {\em input} index, $\tt i_2$ is an {\em output} index, $\tt i_1 \equiv i_2$ and ${\tt Val}^{\tt r}(\tt i_1) = {\tt Val}^{\tt r}(\tt i_2)$, or
%	\item $\tt i_1$ is an {\em output} index, $\tt i_2$ is an {\em input} index, $\tt i_1 \equiv i_2$ and ${\tt Val}^{\tt r}(\tt i_1) = {\tt Val}^{\tt r}(\tt i_2)$, or
%	\item both $\tt i_1$ and $\tt i_2$ are output indices, $\tt i_1 \equiv i_2$, $\tt X_1 \cap X_2 = \emptyset$ and $\tt Y_1 = Y_2$ where $\tt {\tt Val}^{\tt r}(\tt i_1) = X1 \mapsto Y1$,  $\tt {\tt Val}^{\tt r}(\tt i_2) = X2 \mapsto Y2$
%\end{itemize}
\paragraph{Fragment Consistency:} For two fragments $\tt v_1$ and $\tt v_2$ with sizes of 2, let $\tt i$ and $\tt o$ be the {\em input} and {\em output} indices of $\tt v_1$, let $\tt j_i$ and $\tt j_o$ be the {\em input} and {\em output} indices of $\tt v_2$.
 \begin{itemize}
 \item   $\tt v_1$ and $\tt v_2$ are forward consistent, denoted as $\tt v_1 \hookrightarrow_S v_2$ if $\tt tag( v_1,\tt o) = tag(v_2,\tt j_i)$.   
 \item $\tt v_1$ and $\tt v_2$ is branch consistent, denoted as $\tt v_1 \leftrightarrow_S v_2$ if $\tt tag( v_1,\tt o) = tag(v_2,\tt j_o)$, $\tt G_1 \cap G_2 = \emptyset$ and $\tt v_1.{\tt reachto}(\tt i) = v_2.{\tt reachto}(\tt j_i)$ where $\tt G_1$ is the set of global variables in $\tt v_1.{\tt reachfrom}(\tt o)$,  $\tt G_2$ is the set of global variables in $\tt v_2.{\tt reachfrom}(\tt j_o)$. 
 
    \end{itemize}
For two fragments $\tt v_1$ and $\tt v_2$ with sizes of 1, let $\tt i$ be the {\em input} index of $\tt v_1$, let $\tt j_i$ be the {\em input} index of $\tt v_2$.
 \begin{itemize}

 \item $\tt v_1$ and $\tt v_2$ is branch consistent, denoted as $\tt v_1 \leftrightarrow_S v_2$ if $\tt v_1.next(i) = v_2.next(i)$ and $\tt G_1 \cap G_2 = \emptyset$ where $\tt G_1$ is the set of global variables in $\tt v_1.{\tt reachfrom}(\tt i)$,  $\tt G_2$ is the set of global variables in $\tt v_2.{\tt reachfrom}(\tt j_i)$.
 \end{itemize}
For two fragments $\tt v_1$ and $\tt v_2$, let we define several more relations between them as following:
\begin{itemize}
\item  $\tt v_1 \overset{+}\hookrightarrow_S v_2$ if there exists $\tt v$ such that $\tt v_1 \overset{*}\hookrightarrow_S v$ and $\tt v \hookrightarrow_S v_2$  where  $\tt \overset{*}\hookrightarrow_S$ is the transitive closure of $\tt \hookrightarrow_S$. 
\item $\tt v_1  \overset{**}\leftrightarrow_S  v_2$ if there exist $\tt v_1'$, $\tt v_2'$ such that ($\tt v_1  \overset{*}\hookrightarrow_S v_1'$ or $\tt v_1 = v_1'$), and ($\tt v_2  \overset{*}\hookrightarrow_S v_2'$ or $\tt v_2 = v_2'$) as well as $\tt v_1' \leftrightarrow_S v_2'$. 
\item $\tt v_1  \overset{*+}\leftrightarrow_S v_2$ if there exist $\tt v_1'$, $\tt v_2'$ such that ($\tt v_1  \overset{*}\hookrightarrow_S v_1'$ or $\tt v_1 = v_1'$), and $\tt v_2  \overset{*}\hookrightarrow_S v_2'$ as well as $\tt v_1' \leftrightarrow_S v_2'$. 
\item $\tt v_1  \overset{*o}\leftrightarrow_S v_2$ if there exist $\tt v_1'$ such that ($\tt v_1  \overset{*}\hookrightarrow_S v_1'$ or  $\tt v_1 = v_1'$) and  $\tt v_2 \leftrightarrow_S v_1'$.
\item $\tt v_1 \overset{++}\leftrightarrow_S v_2$ if there exist $\tt v_1'$, $\tt v_2'$ such that $\tt v_1  \overset{*}\hookrightarrow_S v_1'$, and $\tt v_2  \overset{*}\hookrightarrow_S v_2'$ as well as $\tt v_1' \leftrightarrow_S v_2'$.

\item $\tt v_1 \overset{+*}\leftrightarrow_S v_2$ if there exist $\tt v_1'$, $\tt v_2'$ such that $\tt v_1  \overset{*}\hookrightarrow_S v_1'$, and ($\tt v_2  \overset{*}\hookrightarrow_S v_2'$ or $\tt v_2 = v_2'$) as well as $\tt v_1' \leftrightarrow_S v_2'$.

\item $\tt v_1 \overset{+o}\leftrightarrow_S v_2$ if there exist $\tt v_1'$ such that $\tt v_1  \overset{*}\hookrightarrow_S v_1'$, and $\tt v_1' \leftrightarrow_S v_2'$.
\end{itemize}
 
\paragraph{Fragment Intersection:} Let us describe the intersection of two fragments $\tt v_1 \in S_1$ and $\tt v_2 \in S_2$ denoted as $\tt v_1 \sqcap v_2$. Firstly, we consider the case where both $\tt v_1$ and $\tt v_2$ have size 2.
 \begin{itemize}
 \item if $\tt v_1.greachfrom(i) \neq \emptyset$ and $\tt v_2.greachfrom(i) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(v_1, i) = gtag(v_2, i)$ and $\tt gtag(v_1, o) = gtag(v_2, o)$ then $\tt v_1 \sqcap v_2 = \{v_{12}\}$ where $\tt v_{12}$ is same as $\tt v_1$ except that 
  \begin{itemize}
  \item $\tt v_{12}.vars(i) = v_1.vars(i) \cup v_2.vars(i)$ 
  \item  $\tt v_{12}.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
  \item $\tt v_{12}.i.reachfrom = v_{1}.i.reachfrom \cup v_{2}.i.reachfrom$
   \item $\tt v_{12}.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
    \end{itemize}
 \end{itemize}

 \item if $\tt v_1.greachfrom(i) = \emptyset$, $\tt v_2.greachfrom(i) = \emptyset$, $\tt v_1.greachfrom(o) \neq \emptyset$ and $\tt v_2.greachfrom(o) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(v_1, o) = gtag(v_2, o)$, $\tt v_1.private.(i) = false$ and $\tt v_2.private.(i) = false$ then $\tt v_1 \sqcap v_2 = \{v_1', v_2', v_{12}\}$ where %$\tt v_{12}$ is same as $\tt v_1$ except that 
%    \begin{itemize}
%  \item $\tt v_{12}.vars(i) = v_1.vars(i) \cup v_2.vars(i)$ 
%  \item  $\tt v_{12}.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
%  \item $\tt v_{12}.i.reachfrom = v_{1}.i.reachfrom \cup v_{2}.i.reachfrom$
%   \item $\tt v_{12}.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
%    \end{itemize} and
    
     $\tt v_1'$ is same as $\tt v_1$ except that 
    \begin{itemize}
  \item  $\tt v_1'.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
  \item $\tt v_1'.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
    \end{itemize}
   and $\tt v_2'$ is same as $\tt v_2$ except that 
    \begin{itemize}
  \item  $\tt v_2'.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
  \item $\tt v_2'.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
    \end{itemize}
     \item if $\tt gtag(v_1, o) = gtag(v_2, o)$ and ($\tt v_1.private.(i) = true$ or $\tt v_2.private.(i) = true$) then $\tt v_1 \sqcap v_2 = \{v_1', v_2'\}$ 
 \end{itemize}
 
 
 
 
 
 
 
 
 \item if $\tt v_1.greachfrom(i) = \emptyset$, $\tt v_2.greachfrom(i) = \emptyset$, $\tt v_1.greachfrom(o) = \emptyset$ and $\tt v_2.greachfrom(o) = \emptyset$ then 
 \begin{itemize}
 \item if $\tt gtag(v_1, o) = gtag(v_2, o)$, $\tt v_1.private.(i) = false$, $\tt v_1.private.(o) = false$, $\tt v_1.private.(o) = false$ and $\tt v_2.private.(o) = false$ then  $\tt v_1 \sqcap v_2 = \{v_1,v_2,v_1',v_2',v_{12}\}$ %where $\tt v_{12}$ is same as $\tt v_1$ except that 
   % \begin{itemize}
 % \item $\tt v_{12}.vars(i) = v_1.vars(i) \cup v_2.vars(i)$ 
 % \item  $\tt v_{12}.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
 % \item $\tt v_{12}.i.reachfrom = v_{1}.i.reachfrom \cup v_{2}.i.reachfrom$
 %  \item $\tt v_{12}.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
 %   \end{itemize} and 
 %   $\tt v_{1'}$ is same as $\tt v_1$ except that 
 %   \begin{itemize}
 % \item  $\tt v_1'.vars(o) = v_1.vars(o) \cup v_2.vars(j_o)$
 % \item $\tt v_1'.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
 %   \end{itemize}
 %  and $\tt v_2'$ is same as $\tt v_2$ except that 
 %   \begin{itemize}
 % \item  $\tt v_2'.vars(o) = v_1.vars(o) \cup v_2.vars(j_o)$
 % \item $\tt v_2'.o.reachfrom = v_{1}.o.reachfrom \cup v_{2}.o.reachfrom$
 %   \end{itemize}
    
    
   \item if $\tt gtag(v_1, o) = gtag(v_2, o)$, ($\tt v_1.private.(i) = true$ or $\tt v_2.private.(i) = true$) and $\tt v_1.private.(o) = false$ and $\tt v_2.private.(o) = false$ then  $\tt v_1 \sqcap v_2 = \{v_1,v_2,v_1',v_2'\}$  

  \item if $\tt gtag(v_1, o) = gtag(v_2, o)$ and ($\tt v_1.private.(o) = true$ or $\tt v_1.private.(o) = true$) then  $\tt v_1 \sqcap v_2 = \{v_1,v_2\}$ 

    \item if $\tt gtag(v_1, o) \neq gtag(v_2, o)$ then $\tt v_1 \sqcap v_2 = \{v_1,v_2\}$
 \end{itemize}
 
 \end{itemize}


%For the case when $\tt v_1$ and $\tt v_2$ have size 1, let $\tt i$ be the {\em input} index of $\tt v_1$, let $\tt j_i$ be the {\em input} index of $\tt v_2$.
% \begin{itemize}
%
% \item if $\tt reachfrom(i) \neq \emptyset$ and $\tt reachfrom(j_i) \neq \emptyset$ then 
%  \begin{itemize}
%  \item if $\tt gtag(v_1, i) = gtag(v_2, j_i)$ then $\tt v_1 \cap v_2 = v_{12}$ where $\tt v_{12}$ is same as $\tt v_1$ except that $\tt v_{12}.vars(i) = v_1.vars(i) \cup v_2.vars(j_i)$.
%  \item if $\tt gtag(v_1, i) \neq gtag(v_2, j_i)$ then $\tt v_1 \cap v_2 = \emptyset$
% \end{itemize}
% 
%  \item if $\tt v1.greachfrom(i) = \emptyset$ and $\tt greachfrom(j_i) = \emptyset$ then 
%  \begin{itemize}
%  \item if $\tt gtag(v_1, i) = gtag(v_2, j_i)$ then $\tt v_1 \cap v_2 = v_{12}$ where $\tt v_{12}$ is same as $\tt v_1$ except that $\tt v_{12}.vars(i) = v_1.vars(i) \cup v_2.vars(j_i)$.
%  \item if $\tt gtag(v_1, i) \neq gtag(v_2, j_i)$ then $\tt v_1 \cap v_2 = \{v_1,v_2\}$
% \end{itemize}
% 
% \end{itemize}
\paragraph{Local Abstract Transformers:} Firstly, let us show the abstract transformer on the set of fragment $\tt S$ in the fragment of the concurrent thread. Let $\tt kill(x,v)$ be the procedure to remove $\tt x$ if it exists from $\tt v.{\tt reachfrom}(\tt i)$, $\tt v.{\tt reachfrom}(\tt o)$, $\tt v.{\tt reachto}(\tt i)$, $\tt v.{\tt reachto}(\tt o)$, $\tt v.{\tt vars}(\tt i)$, and $\tt v.{\tt vars}(\tt o)$. For each program statement, let $\tt S_{post}$ be the set of fragments after executing the statement. Let $\tt S_{post}$ be initialized as the empty set.
\begin{itemize}

\item ${\tt x := y}$: The transformer is performed as following: For each fragment $\tt v_y \in S$ where $\tt y \in v_y.{\tt vars}(\tt i)$,
\begin{enumerate}
\item  for each fragment $\tt v$ where $\tt v \hookrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v \overset{+}\hookrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v_3$ where $\tt v_y \overset{*}\hookrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v_y \overset{*+}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v_y \overset{*o}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item create $\tt v'$ which is same as $\tt v_y$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \cup \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
%\item for each fragment $\tt v'$ in $\tt S_{post}$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
\end{enumerate}

	
	
	
	
	
	
	
	
	
	
	
\item ${\tt x := y.next}$: The local abstract transformer is quite similar to the previous case with slightly differences. For each fragment $\tt v_y \in S$ where $\tt y \in {\tt vars}(\tt i)$,
\begin{enumerate}
\item  for each fragment $\tt v$ where $\tt v \overset{*}\hookrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,

\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,

 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v_y \hookrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ then
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \cup \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v_y \leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize} 
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,

\item for each fragment $\tt v$ where $\tt v_y \overset{+}\hookrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v_y \overset{*o}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,

\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v_y \overset{*+}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\{$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
\item for each fragment $\tt v$ where $\tt v \overset{+o}\leftrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,

\item create $\tt v'$ which is same as $\tt v_y$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ if $\tt x$ is a global variable,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$ if $\tt x$ is a global variable,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$ if $\tt x$ is a global variable,
\end{itemize}
and add $\tt v'$ to $\tt S_{post}$,
%\item for each fragment $\tt v'$ in $\tt S_o$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
%
\end{enumerate}	




\item  ${\tt x.next:= y}$: The local abstract transformer is performed by several steps as follows: For each pair of fragments $\tt v_x$, $\tt v_y$ in $\tt S$ where $\tt x \in v_x.{\tt vars}(\tt i)$, $\tt y \in v_y.{\tt vars}(\tt i)$, and $\tt v_x \overset{*}\hookrightarrow v_y$ or $\tt v_y \overset{*}\hookrightarrow v_x$ or $\tt v_x \overset{**}\leftrightarrow v_y$
\begin{enumerate}
\item let $\tt v_{new}$ be the fragment of size 2 where $\tt tag(v_{new},i) = tag(v_x, i)$ and $\tt tag(v_{new},o) = tag(v_y,i)$ except that $\tt v_{new}.o.reachfrom = v_y.i.reachfrom \cup v_x.i.reachfrom$,
\item  for each fragment $\tt v \in S$ where $\tt v \overset{*}\hookrightarrow_S v_x$, we do as follows: For each subset $\tt regs$ of observer registers in $\tt v.reachto(\tt i) \cap \tt v_x.i.reachfrom$
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that
\begin{itemize}
\item $\tt v'.reachto(\tt i) = (\tt v.reachto(\tt i) \cap v_x.i.reachfrom) \cup v_y.reachto(\tt i) \cup regs$.
\item $\tt v'.reachto(\tt o) = (\tt v.reachto(\tt o) \cap v_x.i.reachfrom) \cup v_y.reachto(\tt i) \cup regs$.
\end{itemize}
\item add $\tt v'$ to $\tt S_{post}$
\end{itemize}

\item for each fragment $\tt v$ where $\tt v_y \overset{*}\hookrightarrow_S v$ or $\tt v_y = v$, 
\begin{itemize}
	\item create  $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
 \item $\tt \tt v'.i.reachfrom = v_x.i.reachfrom \cup \tt v.i.reachfrom$, 
\item $\tt \tt v'.o.reachfrom = v_x.i.reachfrom \cup \tt v.o.reachfrom$, 
\end{itemize}
\item add $\tt v'$ to $\tt S_{post}$
\end{itemize}
\item for each fragment $\tt v$ where $\tt v_x \overset{**}\leftrightarrow_S v$ and either $\tt v \hookrightarrow_S v_y$ or $\tt v_y \overset{*o}\leftrightarrow_S v$, 
\begin{itemize}
\item  create $\tt v'$ which is same as $\tt v$ except that $\tt \tt v'.o.reachfrom = v_x.i.reachfrom \cup \tt v.o.reachfrom$, 
 \item add $\tt v'$ to $\tt S_{post}$ 
\end{itemize}


\item for each fragment $\tt v$ where $\tt v_x \overset{*}\hookrightarrow_S v$ and either $\tt v \hookrightarrow_S v_y$ or $\tt v_y \overset{*o}\leftrightarrow_S v$,  
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$ then except that $\tt \tt v'.o.reachfrom = v_x.i.reachfrom \cup \tt v.o.reachfrom$, 
\item for each subset $\tt regs$ of observer registers in $\tt v'.i.reachfrom \cap \tt v_x.i.reachfrom$
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\tt v''.i.reachfrom = (\tt v'.i.reachfrom \setminus v_x.i.reachfrom) \cup regs$.
\item add $\tt v''$ to $\tt S_{post}$
\end{itemize}
\end{itemize}

\item for each fragment $\tt v$ where $\tt v_x \overset{**}\leftrightarrow_S v$ and either $\tt v \overset{+}\hookrightarrow_S v_y$ or $\tt v \overset{*+}\leftrightarrow_S v_y$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$
\item  add $\tt v'$ to $\tt S_{post}$
\end{itemize}


\item for each fragment $\tt v$ where $\tt v_x \overset{*}\hookrightarrow_S v$ and either $\tt v \overset{+}\hookrightarrow_S v_y$ or $\tt v_y \overset{*+}\leftrightarrow v$, then for each subset $\tt regs$ of observer registers in $\tt v.i.reachfrom \cap \tt v_x.i.reachfrom$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that $\tt v'.i.reachfrom = (\tt v.i.reachfrom \setminus v_x.i.reachfrom) \cup regs$. 
 \item for each set $\tt regs'$ of observer registers in $\tt v'.o.reachfrom \cap \tt v_x.i.reachfrom$,  
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\tt v''.o.reachfrom = (\tt v'.o.reachfrom \setminus v_x.i.reachfrom) \cup regs'$. 
\item add $\tt v''$ to $\tt S_{post}$
\end{itemize}
\end{itemize}
\item add $\tt v_{new}$ to $\tt S_{post}$
\end{enumerate}

\newpage

 \end{itemize}
\section{Abstract transformers for skip-lists}
Let us show how to perform the abstract transformer for skip-list programs on the set of fragments $\tt S$ depending on the particular statement.  We consider fragments of size $2$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \{{o}\}$, and $\tt next(i) = {o}$ and fragments of size $1$ where $\tt I_{inp} = \{i\}$, $\tt I_{out} = \emptyset$, and $\tt next(i) = null$ or $\tt next(i) = \bot$. For each fragment $\tt v$, let $\tt v.level \in \{1,2\}$ be the level of $\tt v$.

\paragraph{Local Abstract Transformers:} First, let us show the abstract transformer on the set of fragment $\tt S$ in the fragment of the concurrent thread. Let $\tt S_1$ be set of fragments of level 1 in $\tt S$, $\tt S_2$ be set of fragments of level 2 in $\tt S$. For each program statement, let $\tt S_{post}$ be the set of fragments after executing the statement. Let $\tt S_{post}$ be initialized as the empty set.  Let $\tt R$ be the set of pairs of fragments. Intuitively, in each element in $\tt R$, the second fragment is the transformation of the first fragment. Let $\tt R$ be initialized as the empty set.
\begin{itemize}
\item ${\tt x := y}$: The transformer is performed as follows:  For each fragment $\tt v_y \in S_1$ where $\tt y \in v_y.{\tt vars}(\tt i)$, 
%\begin{itemize}
\begin{enumerate}
\item  for each fragment $\tt v \in S_1$ where $\tt v \hookrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v \overset{+}\hookrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v_y \overset{*}\hookrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt S'$
\item for each fragment $\tt v$ where $\tt v_y \overset{*+}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt S'$
\item for each fragment $\tt v \in S_1$ where $\tt v_y \overset{*o}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt S'$
\item create $\tt v'$ which is same as $\tt v_y$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \cup \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
 \item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt S'$
%\item for each fragment $\tt v'$ in $\tt S_{post}$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
\item for each fragment $\tt v \in S_2$ we do as follows. For each $\tt (v_1,v_1')$, $\tt (v_2,v_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{v_1.i, v_1.o\}$, $\tt i_2 \in \{v_2.i, v_2.o\}$, $\tt tag(v,i) = tag(v_1, i_1)$, and $\tt tag(v,o) = tag(v_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v_1'.i_1.vars$,
\item $\tt v'.o.vars = v_2'.i_2.vars$,

\item $\tt v'.i.reachfrom = v_1'.i_1.reachfrom$,
\item $\tt v'.o.reachfrom = v_2'.i_2.reachfrom$,
\item $\tt v'.i.reachto = v_1'.i_1.reachto$,
\item $\tt v'.o.reachto = v_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\tt S_{post}$. 
\end{enumerate}
%\item If there does not exist such $\tt v_y$ in $\tt S_1$
%\end{itemize}
%\begin{enumerate}
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_y,i)$,
%	\item $\tt tag(v,i) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%%\begin{itemize}
%%\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
%%\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
%%\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
%% \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
%%\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\tt S_{post}$,
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_y,i)$,
%	\item $\tt tag(v,i) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%%\begin{itemize}
%%\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
%%\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
%%\item if $\tt x$ is a global variable
%%\begin{itemize}
%%\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
%%\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
%% \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
%%\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
%%\end{itemize}
%%\end{itemize}
%%and add $\tt v'$ to $\tt S_{post}$,
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_y,i)$,
%	\item $\tt tag(v,i) = tag(v_1,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_1$ 
%\end{itemize}
%
%%4%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_2 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%
%%5%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_2$ or $\tt v_2 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%
%%6%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_2$ 
%\end{itemize}
%
%
%%7%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_1$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_2 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%
%%8%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_1$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_2$ or $\tt v_2 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%
%%9%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_1$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_2$ 
%\end{itemize}
%
%
%%10%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o} \leftrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_2 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%
%%11%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o} \leftrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_2$ or $\tt v_2 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%
%%12%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o} \leftrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_2$ 
%\end{itemize}
%
%\end{enumerate}
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X := Y.NEXT1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item ${\tt x := y.next1}$: The local abstract transformer is quite similar to the previous case with slightly differences. For each fragment $\tt v_y \in S$ where $\tt y \in {\tt vars}(\tt i)$,
%\begin{enumerate}
%
%%1%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_y,o)$,
%	\item $\tt tag(v,i) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$ or $\tt v_1 = v_y$,
%\end{itemize}
%
%%2%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_y,o)$,
%	\item $\tt tag(v,i) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%%3%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_y,o)$,
%	\item $\tt tag(v,i) = tag(v_1,i)$ where $\tt v_y \overset{+}\hookrightarrow_S v_1$ 
%\end{itemize}
%
%%-------------------------------------------4------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$ or $\tt v_1 = v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_2 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%
%%-------------------------------------------5------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$ or $\tt v_1 = v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_2$ or $\tt v_2 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%
%%-------------------------------------------6------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1 \overset{*}\hookrightarrow_S v_y$ or $\tt v_1 = v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_2$ 
%\end{itemize}
%
%
%%-------------------------------------------7-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o}\leftrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_2 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%
%%------------------------------------------8-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o}\leftrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_2$ or $\tt v_2 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%
%%-----------------------------------------9-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_1$ or $\tt v_1 \overset{*o}\leftrightarrow_S v_y$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_2$ 
%\end{itemize}
%
%
%%-----------------------------------------10-------------------------------------------%
%
%\item  for each fragment $\tt v$ where 
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_1$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_2 \overset{*}\hookrightarrow_S v_y$,
%\end{itemize}
%
%
%%-----------------------------------------11-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$  where $\tt v_y \overset{*}\hookrightarrow_S v_1$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*+}\leftrightarrow_S v_2$ or $\tt v_2 \overset{*o}\leftrightarrow_S v_y$
%\end{itemize}
%
%
%%-----------------------------------------12-------------------------------------------%
%\item  for each fragment $\tt v$ where
%\begin{itemize}
%	\item $\tt tag(v,o) = tag(v_1,i)$ where $\tt v_1y\overset{*}\hookrightarrow_S v_1$,
%	\item $\tt tag(v,i) = tag(v_2,i)$ where $\tt v_y \overset{*}\hookrightarrow_S v_2$ 
%\end{itemize}
%
%
%\end{enumerate}




\begin{enumerate}
\item  for each fragment $\tt v \in S_1$ where $\tt v \overset{*}\hookrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v_y \hookrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ then
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \cup \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v_y \leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize} 
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$

\item for each fragment $\tt v \in S_1$ where $\tt v_y \overset{+}\hookrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \cup \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v_y \overset{*o}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v_y \overset{*+}\leftrightarrow_S v$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\{$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$ ,
\item $\tt v'.i.reachto = v.i.reachto \setminus \{x\}$,
\item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$,
\item $\tt v'.o.reachto = v.o.reachto \setminus \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
\item for each fragment $\tt v \in S_1$ where $\tt v \overset{+o}\leftrightarrow_S v_y$, create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \setminus \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \setminus \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$

\item create $\tt v'$ which is same as $\tt v_y$ except that
\begin{itemize}
\item $\tt v'.i.vars = v.i.vars \setminus \{x\}$,
\item $\tt v'.o.vars = v.o.vars \cup \{x\}$,
\item if $\tt x$ is a global variable
\begin{itemize}
\item $\tt v'.i.reachfrom = v.i.reachfrom \setminus \{x\}$,
\item $\tt v'.i.reachto = v.i.reachto \cup \{x\}$,
 \item $\tt v'.o.reachfrom = v.o.reachfrom \cup \{x\}$,
 \item $\tt v'.o.reachto = v.o.reachto \cup \{x\}$,
\end{itemize}
\end{itemize}
then add $\tt v'$ to $\tt S_{post}$, and $\tt (v,v')$ to $\tt R$
%\item for each fragment $\tt v'$ in $\tt S_o$, assign $\tt v'.data.(i).(y.d)$ to $\tt v'.data.(i).(x.d)$ for $\tt i \in \{i, o\}$.
%

\item for each fragment $\tt v \in S_2$ we do as follows. For each $\tt (v_1,v_1')$, $\tt (v_2,v_2') \in R$, for each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{v_1.i, v_1.o\}$, $\tt i_2 \in \{v_2.i, v_2.o\}$, $\tt tag(v,i) = tag(v_1, i_1)$, and $\tt tag(v,o) = tag(v_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v_1'.i_1.vars$,
\item $\tt v'.o.vars = v_2'.i_2.vars$,

\item $\tt v'.i.reachfrom = v_1'.i_1.reachfrom$,
\item $\tt v'.o.reachfrom = v_2'.i_2.reachfrom$,
\item $\tt v'.i.reachto = v_1'.i_1.reachto$,
\item $\tt v'.o.reachto = v_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\tt S_{post}$. 
\end{enumerate}	




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% X.NEXT1 := Y %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item  ${\tt x.next1:= y}$: The local abstract transformer is performed by several steps as follows: For each pair of fragments $\tt v_x$, $\tt v_y$ in $\tt S_1$ where $\tt x \in v_x.{\tt vars}(\tt i)$, $\tt y \in v_y.{\tt vars}(\tt i)$, and $\tt v_x \overset{*}\hookrightarrow v_y$ or $\tt v_y \overset{*}\hookrightarrow v_x$ or $\tt v_x \overset{**}\leftrightarrow v_y$, let $\tt R_1$, $\tt R_2$, $\tt R_3$, $\tt R_4$, $\tt R_5$, $\tt R_6$ be initialized as $\tt R$,  
\begin{enumerate}
\item let $\tt v_{new}$ be the fragment of size 2 and of level 1 where $\tt tag(v_{new},i) = tag(v_x, i)$ and $\tt tag(v_{new},o) = tag(v_y,i)$ except that $\tt v_{new}.o.reachfrom = v_y.i.reachfrom \cup v_x.i.reachfrom$,
\item  for each fragment $\tt v \in S_1$ where $\tt v \overset{*}\hookrightarrow_S v_x$, we do as follows: For each subset $\tt regs$ of observer registers in $\tt v.reachto(\tt i) \cap \tt v_x.i.reachfrom$


\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that
\begin{itemize}
\item $\tt v'.i.reachto = (\tt v.i.reachto \cap v_x.i.reachfrom) \cup v_y.i.reachto \cup regs$.
\item $\tt v'.o.reachto = (\tt v.o.reachto \cap v_x.i.reachfrom) \cup v_y.i.reachto \cup regs$.
\end{itemize}
\item add $\tt v'$ to $\tt S_{post}$ 
\item add $\tt (v,v')$ to $\tt R_1$
\end{itemize}

\item for each fragment $\tt v \in S_1$ where $\tt v_y \overset{*}\hookrightarrow_S v$ or $\tt v_y = v$, 
\begin{itemize}
	\item create  $\tt v'$ which is same as $\tt v$ except that
\begin{itemize}
 \item $\tt \tt v'.i.reachfrom = v_x.i.reachfrom \cup \tt v.i.reachfrom$, 
\item $\tt \tt v'.o.reachfrom = v_x.i.reachfrom \cup \tt v.o.reachfrom$, 
\end{itemize}
\item add $\tt v'$ to $\tt S_{post}$,
\item add $\tt (v,v')$ to $\tt R_2$
\end{itemize}
\item for each fragment $\tt v \in S_1$ where $\tt v_x \overset{**}\leftrightarrow_S v$ and either $\tt v \hookrightarrow_S v_y$ or $\tt v_y \overset{*o}\leftrightarrow_S v$, 
\begin{itemize}
\item  create $\tt v'$ which is same as $\tt v$ except that $\tt \tt v'.o.reachfrom = v_x.i.reachfrom \cup \tt v.o.reachfrom$, 
 \item add $\tt v'$ to $\tt S_{post}$, 
 \item add $\tt (v,v')$ to $\tt R_3$

\end{itemize}


\item for each fragment $\tt v \in S_1$ where $\tt v_x \overset{*}\hookrightarrow_S v$ and either $\tt v \hookrightarrow_S v_y$ or $\tt v_y \overset{*o}\leftrightarrow_S v$,  
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$ then except that $\tt \tt v'.o.reachfrom = v_x.i.reachfrom \cup \tt v.o.reachfrom$, 
\item for each subset $\tt regs$ of observer registers in $\tt v'.i.reachfrom \cap \tt v_x.i.reachfrom$
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\tt v''.i.reachfrom = (\tt v'.i.reachfrom \setminus v_x.i.reachfrom) \cup regs$.
\item add $\tt v''$ to $\tt S_{post}$,
\item add $\tt (v,v'')$ to $\tt R_4$
\end{itemize}
\end{itemize}

\item for each fragment $\tt v \in S_1$ where $\tt v_x \overset{**}\leftrightarrow_S v$ and either $\tt v \overset{+}\hookrightarrow_S v_y$ or $\tt v \overset{*+}\leftrightarrow_S v_y$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$
\item  add $\tt v'$ to $\tt S_{post}$,
\item add $\tt (v,v')$ to $\tt R_5$

\end{itemize}


\item for each fragment $\tt v \in S_1$ where $\tt v_x \overset{*}\hookrightarrow_S v$ and either $\tt v \overset{+}\hookrightarrow_S v_y$ or $\tt v_y \overset{*+}\leftrightarrow v$, then for each subset $\tt regs$ of observer registers in $\tt v.i.reachfrom \cap \tt v_x.i.reachfrom$, 
\begin{itemize}
\item create $\tt v'$ which is same as $\tt v$, except that $\tt v'.i.reachfrom = (\tt v.i.reachfrom \setminus v_x.i.reachfrom) \cup regs$. 
 \item for each set $\tt regs'$ of observer registers in $\tt v'.o.reachfrom \cap \tt v_x.i.reachfrom$,  
\begin{itemize}
\item create $\tt v''$ which is same as $\tt v'$, except that $\tt v''.o.reachfrom = (\tt v'.o.reachfrom \setminus v_x.i.reachfrom) \cup regs'$. 
\item add $\tt v''$ to $\tt S_{post}$
\item add $\tt (v,v'')$ to $\tt R_6$
\end{itemize}
\end{itemize}
\item add $\tt v_{new}$ to $\tt S_{post}$ 
\end{enumerate}

\item for each fragment $\tt v \in S_2$ then we do as follows. for each $\tt (v_1,v_1') \in R_i$, $\tt (v_2,v_2') \in R_j$ where $\tt i \neq j$ and $\tt 1 \leq i,j \leq 6$. For each pair of indices $\tt i_1$, $\tt i_2$ such that $\tt i_1 \in \{v_1.i, v_1.o\}$, $\tt i_2 \in \{v_2.i, v_2.o\}$, $\tt tag(v,i) = tag(v_1, i_1)$, $\tt tag(v,o) = tag(v_2, i_2)$. Create $\tt v'$ which is same as $\tt v$ except that 
\begin{itemize}
\item $\tt v'.i.vars = v_1'.i_1.vars$,
\item $\tt v'.o.vars = v_2'.i_2.vars$,

\item $\tt v'.i.reachfrom = v_1'.i_1.reachfrom$,
\item $\tt v'.o.reachfrom = v_2'.i_2.reachfrom$,
\item $\tt v'.i.reachto = v_1'.i_1.reachto$,
\item $\tt v'.o.reachto = v_2'.i_2.reachto$,
\end{itemize} then add $\tt v'$ to $\tt S_{post}$. 


\newpage
 \end{itemize}
 
 \paragraph{Fragment Intersection:} Let us describe the intersection of two fragments $\tt v_1 \in S_1$ and $\tt v_2 \in S_2$ denoted as $\tt v_1 \sqcap v_2$. Firstly, we consider the case where both $\tt v_1$ and $\tt v_2$ have size 2.
 \begin{itemize}
 \item if $\tt v_1.greachfrom(i,\{1,2\}) \neq \emptyset$ and $\tt v_2.greachfrom(i,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(v_1, i) = gtag(v_2, i)$ and $\tt gtag(v_1, o) = gtag(v_2, o)$ then $\tt v_1 \sqcap v_2 = \{v_{12}\}$ where $\tt v_{12}$ is same as $\tt v_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$ 
  \begin{itemize}
  \item $\tt v_{12}.vars(i) = v_1.vars(i) \cup v_2.vars(i)$ 
  \item  $\tt v_{12}.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
  \item $\tt v_{12}.reachfrom(i,l) = v_{1}.reachfrom(i,l) \cup v_{2}.reachfrom(i,l)$
   \item $\tt v_{12}.reachfrom(i,l) = v_{1}.reachfrom(o,l) \cup v_{2}.reachfrom(o,l)$
    \end{itemize}
 \end{itemize}

 \item if $\tt v_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt v_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt v_1.greachfrom(o,\{1,2\}) \neq \emptyset$ and $\tt v_2.greachfrom(o,\{1,2\}) \neq \emptyset$ then 
  \begin{itemize}
  \item if $\tt gtag(v_1, o) = gtag(v_2, o)$, $\tt v_1.private.(i) = false$ and $\tt v_2.private.(i) = false$ then $\tt v_1 \sqcap v_2 = \{v_1', v_2', v_{12}\}$ where %$\tt v_{12}$ is same as $\tt v_1$ except that 
  $\tt v_1'$ is same as $\tt v_1$ except that, for all $\tt l \in \{1,2 \{1,2\}\}$
    \begin{itemize}
  \item  $\tt v_1'.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
  \item $\tt v_1'.reachfrom(o,l) = v_{1}.reachfrom(o,l) \cup v_{2}.reachfrom(o,l)$
    \end{itemize}
   and $\tt v_2'$ is same as $\tt v_2$ except that 
    \begin{itemize}
  \item  $\tt v_2'.vars(o) = v_1.vars(o) \cup v_2.vars(o)$
  \item $\tt v_2'.reachfrom(o,l) = v_{1}.reachfrom(o,l) \cup v_{2}.reachfrom(o,l)$
    \end{itemize}
     \item if $\tt gtag(v_1, o) = gtag(v_2, o)$ and ($\tt v_1.private.(i) = true$ or $\tt v_2.private.(i) = true$) then $\tt v_1 \sqcap v_2 = \{v_1', v_2'\}$ 
 \end{itemize}
 
 
  \item if $\tt v_1.greachfrom(i,\{1,2\}) = \emptyset$, $\tt v_2.greachfrom(i,\{1,2\}) = \emptyset$, $\tt v_1.greachfrom(o,\{1,2\}) = \emptyset$ and $\tt v_2.greachfrom(o,\{1,2\}) = \emptyset$ then 
 \begin{itemize}
 
 
 \item if $\tt gtag(v_1, o) = gtag(v_2, o)$, $\tt v_1.private.(i) = false$, $\tt v_1.private.(o) = false$, $\tt v_1.private.(o) = false$ and $\tt v_2.private.(o) = false$ then  $\tt v_1 \sqcap v_2 = \{v_1,v_2,v_1',v_2',v_{12}\}$ %where $\tt v_{12}$ is same as $\tt v_1$ except that 
    \item if $\tt gtag(v_1, o) = gtag(v_2, o)$, ($\tt v_1.private.(i) = true$ or $\tt v_2.private.(i) = true$) and $\tt v_1.private.(o) = false$ and $\tt v_2.private.(o) = false$ then  $\tt v_1 \sqcap v_2 = \{v_1,v_2,v_1',v_2'\}$  

  \item if $\tt gtag(v_1, o) = gtag(v_2, o)$ and ($\tt v_1.private.(o) = true$ or $\tt v_1.private.(o) = true$) then  $\tt v_1 \sqcap v_2 = \{v_1,v_2\}$ 

    \item if $\tt gtag(v_1, o) \neq gtag(v_2, o)$ then $\tt v_1 \sqcap v_2 = \{v_1,v_2\}$
 \end{itemize}
 
 \end{itemize}



