%--------------------------------------------------------
\section{Experimental Results}
\label{section:experiments}
%--------------------------------------------------------
\newcommand{\emm}{(emm)}
%\begin{wrapfigure}{r}[0pt]{0.5\textwidth}
%\vspace{5mm}

 Based on our framework, we have implemented a tool in OCaml, and used it for verifying various kinds of concurrent data structures implementation of stack, queue and set. These algorithms includes singly-linked lists algorithms, skip-list sets and priority queues as well as timestamps stack and queue.  

\begin{figure}[]
%% \vspace*{-1cm}
\center
\begin{tabular}{|c | c || c | c |}
  \hline
   \textsf{{\textbf{Algorithms}}} &  \textsf{{\textbf{Time (s)}}} & \textsf{{\textbf{Algorithms}}} &  \textsf{{\textbf{Time (s)}}}  \\

\hline
\hline
%\hline
%
%\textsf{TS stack  ~\cite{ts-stack}}  & \textsf{176} & \textsf{DGLM queue  ~\cite{Doherty:lockfree}}&  \textsf {16} \\
%\hline
%
%\textsf{TS queue  ~\cite{ts-stack}}& \textsf{101} & \textsf{Vechev-CAS set  ~\cite{Vechev:list}}  & \textsf{86} \\
%\hline
%\textsf{Lock-free skip-list   ~\cite{ArtOfMpP}}& \textsf{1992} & \textsf{Vechev-DCAS set  ~\cite{Vechev:list}}   & \textsf{16} \\
%\hline
%
%\textsf{Lock-based skip-list ~\cite{lockskiplist}}& \textsf{500} & \textsf{Michael lock-free set ~\cite{Michael:list}}  & \textsf{178} \\
%\hline
% 
%\textsf{Priority queue skip-list 1 ~\cite{Shavit:ElimQueue}}  &  \textsf{1320} & \textsf{Pessimistic set  ~\cite{ArtOfMpP}}&\textsf{30}\\
%\hline
%
%\textsf{Priority queue skip-list 2~\cite{Linden:opodis13}}  &  \textsf{599} &\textsf{Optimistic set ~\cite{ArtOfMpP}}& \textsf{25}\\
%\hline
%\textsf{Treiber stack  ~\cite{Treiber:stack}} & \textsf {18} & \textsf{Lazy set ~\cite{Lazyset}  }  & \textsf {34}\\
%\hline
%
%\textsf{MS lock-free queue  ~\cite{MS:QueueAlgorithms}}& \textsf{21} & \textsf {O$\textquotesingle $Hearn set  ~\cite{OHearnlist}} & \textsf{88}\\
%\hline
%
%&   & \textsf{HM lock-free set  ~\cite{ArtOfMpP} } & \textsf{120}\\
%



\textsf{Treiber stack  ~\cite{Treiber:stack}} & \textsf {18} & \textsf {O$\textquotesingle $Hearn set  ~\cite{OHearnlist}} & \textsf{88}  \\
\textsf{MS lock-free queue  ~\cite{MS:QueueAlgorithms}}& \textsf{21} & \textsf{HM lock-free set  ~\cite{ArtOfMpP} } & \textsf{120}  \\
\textsf{DGLM queue  ~\cite{Doherty:lockfree}}&  \textsf {16} & \textsf{Harris lock-free set  ~\cite{Harris:list}} & \textsf{320}  \\
\textsf{Vechev-CAS set  ~\cite{Vechev:list}}  & \textsf{86} &  \textsf{Unordered set  ~\cite{Zhang:unorderedlist} & \textsf{1230} \\
\cline{3-4}
\textsf{Vechev-DCAS set  ~\cite{Vechev:list}}   & \textsf{16} & \textsf{TS stack  ~\cite{ts-stack}}  & \textsf{176} \\
\textsf{Michael lock-free set ~\cite{Michael:list}}  & \textsf{178} & \textsf{TS queue  ~\cite{ts-stack}} & \textsf{101} \\
\cline{3-4}
\textsf{Pessimistic set  ~\cite{ArtOfMpP}}&\textsf{30} & \textsf{Lock-free skip-list   ~\cite{ArtOfMpP}}& \textsf{1992} \\
\textsf{Optimistic set ~\cite{ArtOfMpP}}& \textsf{25} & \textsf{Lock-based skip-list ~\cite{lockskiplist}}& \textsf{500} \\
\textsf{Lazy set ~\cite{Lazyset}}  & \textsf {34} & \textsf{Priority queue skip-list 1 ~\cite{Shavit:ElimQueue}} &\textsf{1320} \\
& & \textsf{Priority queue skip-list 2~\cite{Linden:opodis13}}  &  \textsf{599} \\
\hline
\end{tabular}

%\vspace{10mm}
%\vspace*{-0.3cm}
\caption{Experimental results for verifying concurrent programs}
%\vspace*{-0.7cm}
\label{Experiments:fig}
\end{figure}
%\vspace{-0.2cm}
\paragraph{Singly-linked list benchmarks:} These benchmarks include stacks, queues and sets algorithms which already verified in our previous work in ~\cite{Quy:sas16}, in which we extended this approach to handle SLL implementations of concurrent sets by adapting a well-known abstraction of singly-linked lists ~\cite{MYRS:Canonical} for concurrent programs.
The resulting technique is specifically tailored for singly-links in a slightly ad-hoc way.
Our fragment abstraction is significantly simpler conceptually, and can therefore be used directly
also for other classes of heap structures. Our approach of previous work is strong enough to verify  concurrent set
implementations based on sorted and non-sorted singly-linked lists having non-optimistic contains (or lookup) operations we consider, such as the lock-free sets of {\it HM}~\cite{ArtOfMpP}, {\it Harris}~\cite{Harris:list}, or {\it Michael}~\cite{Michael:list}, or unordered set of~\cite{Zhang:unorderedlist} which have not done automatically before. Our fragment abstraction can handle them as well.

\paragraph{Skiplist benchmarks:} We consider four skiplist algorithms including one lock-based skiplist set~\cite{MS:QueueAlgorithms}, one lock-free skiplist ~\cite{ArtOfMpP} skiplist which is described in section 2, and two skip-list based priority queues. The challenge for verifying these algorithms is to deal with the problem of unbounded number of levels in these skiplists. In addition, in the lock-free skiplist ~\cite{ArtOfMpP} and priority queue ~\cite{Linden:opodis13}, the skiplist shape is not well formed, it means that each higher level list is not always a sub-list of lower level lists. This makes the verification tasks became extremely difficult, these algorithms have not been formally verified by any previous work. By applying our fragment abstraction,  to the best of our knowledge, we are the first one who is able to verify these concurrent skiplists automatically. 

\paragraph{Timestamp benchmarks:} We consider two challenging timestamp algorithms in ~\cite{ts-stack}, the timestamp stack uses an array of singly-linked lists (SLLs), one for each thread, accessed via the thread-indexed array ${\tt pools[maxThreads]}$ of pointers to the first cell of each list. Each list cell contains a data value, a timestamp value, a ${\tt next}$ pointer, and a boolean flag ${\tt mark}$ which indicates whether the node is logically removed from the stack. The $\tt push$ method of a thread push an to ``its own'' list, and can $\tt pop$ method pop the youngest element from any list. The timestamp queue uses the same data structure as timestamp stack, and it also push an element to its own list. However, the its dequeue method removes the oldest element from any list. There are two challenges problems of verifying these algorithm, the fist challenge is how to deal with unbounded number of SLLs and the second challenge is that the lineatization points of the algorithms are not fixed, they are depended on the future behaviors of the algorithms. By using our fragment abstraction and observers for stack and queue in ~\cite{BEEH:icalp15}. Our tool is the first one which verifies these two algorithms automatically.

\paragraph{Running Times.}The experiments were performed on a desktop 2.8 GHz processor with 8GB memory. The results are presented in Fig.~\ref{Experiments:fig}, where running times are given in seconds. In our experiment, we run the tool together with observer in \cite{AHHR:integrated:rep}, \cite{BEEH:icalp15} and controller in~\cite{Quy:sas16} to verify linearization properties of the algorithms. All experiments start from the initial heap,  
and end either when the analysis reaches the fixed point or when a violation of safety properties or linearizability is detected. As can be seen from the table, the running times vary in the different examples. This is due to the types of shapes that are produced during the analysis. For instance, skip-list algorithms have much longer running times. This is due to the number of pointer variables and their complicated shapes. Whereas, other algorithms 
produce simple shape patterns and hence they have shorter running times.
\paragraph{Error Detection}
 In addition to establishing correctness of the original versions of the
benchmark algorithms, we tested our tool with intentionally inserted bugs. For example, we emitted setting time statement in line 5 of the {\tt push} method in TS stack algorithm. The tool, as expected, successfully detected and reported the bug.
 

%
%\paragraph{Helping.}
%The algorithms marked by  \checkmark \; use helping.
%%
%We run  some of the algorithms with two different helping patterns
%(such as the ones described in Sec.~\ref{programs:section}),
%and report the execution time for each.




%\expcloseparagraph{Consistency.}
%In the case of algorithms where the controller
%performs multiple linearizations for the same thread (e.g.,
%the {\tt Lazy Set} algorithm), our prototype checks
%{\it automatically} that
%(i) 
%each thread linearizes at least once during
%its execution, and 
%(ii) the
%last value communicated to the observer is identical to the value $r$
%actually returned by the thread.
%%
%To do that, the prototype adds two extra variables per thread, namely
%a Boolean variable $b$ which records that at least one
% linearization has taken place, and a variable $v$ of type 
%$\intgrs\cup\set{\star}$, for some $\star\not\in\intgrs$,
%where $v$ is initialized to $\star$.
%%
%The variable $v$ records the value that has been communicated to
%the observer by the thread.
%%
%%
%Furthermore, we have to take into account the fact 
%that ``false'' linearization points
%may change the state of the observer.
%%
%Each time the controller performs a linearization,
%it will check if the value of $v$ of is different from $\star$.
%%
%If {\it yes} then the thread has already linearized once and the run 
%of the program is stopped.
%%
%Otherwise, it updates the value of $b$ to {\tt true},
%and then decides either
%to perform a linearization or not.
%%
%In the former case, it updates the value of $v$ 
%to the value communicated to the observer.
%%
%In the latter case, it will not update the value of $v$.
%%
%This will continue, until we reach the {\tt return} statement of the thread.
%%
%We report an error if
%(i) the observer has reached a bad state.
%(ii) $b={\tt false}$ holds, since this means the existence of
%a run long of which the thread never linearizes, or
%(iii) $(b={\tt true})\wedge(v\neq\star)\wedge(v\neq r)$
%holds since this means that we have linearized with the wrong value.
%
%\paragraph{Arrays.}
%Our tool does not currently support arrays, and hence
%we have transformed arrays to singly-linked lists
%in the algorithms that use the former.
%
%\paragraph{Safety Properties.}
%Our tool is also capable of verifying 
% memory related safety properties such as the absence of
%null pointer dereferencing, 
%dangling pointers,  double-freeing, cycles, and
%dereferencing of freed nodes, as well as sortedness.
%%
%%We check these properties for all the algorithms we consider.
%%
%In fact,  for each algorithm,
%the time reported in Fig.~\ref{Experiments:fig} is the sum of the 
%times taken to show linearizability and all the properties mentioned above.
%



\


