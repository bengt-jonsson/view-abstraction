%--------------------------------------------------------
\section{Experimental Results}
\label{section:experiments}
%--------------------------------------------------------
\newcommand{\emm}{(emm)}
%\begin{wrapfigure}{r}[0pt]{0.5\textwidth}
%\vspace{5mm}

 Based on our framework, we have implemented a tool in OCaml, and used it for verifying various kinds of concurrent data structures implementation of stacks, priority queues, queues and sets. All of them are based on heap structures. There are three types of heap structures we consider in our experiments.
\begin{figure}[]
%% \vspace*{-1cm}
\center
\begin{tabular}{|l | r| r | l | r | r |}
  \hline
  \multirow{2}{*}{\textsf{{\textbf{Algorithms}}}} &   \multicolumn{2}{c|}{\textsf{{\textbf{Time (s)}}}} & \multirow{2}{*}{\textsf{{\textbf{Algorithms}}}} &  \multicolumn{2}{c|}{\textsf{{\textbf{Time (s)}}}}  \\
   \cline{2-3} \cline{5-6} 
& \multicolumn{1}{c|}{\textsf{a}} & \multicolumn{1}{c|}{\textsf{b}} & & \multicolumn{1}{c|}{\textsf{a}} & \multicolumn{1}{c|}{\textsf{b}} \\
\hline
%\hline
%
%\textsf{TS stack  ~\cite{ts-stack}}  & \textsf{176} & \textsf{DGLM queue  ~\cite{Doherty:lockfree}}&  \textsf {16} \\
%\hline
%
%\textsf{TS queue  ~\cite{ts-stack}}& \textsf{101} & \textsf{Vechev-CAS set  ~\cite{Vechev:list}}  & \textsf{86} \\
%\hline
%\textsf{Lock-free skiplist   ~\cite{ArtOfMpP}}& \textsf{1992} & \textsf{Vechev-DCAS set  ~\cite{Vechev:list}}   & \textsf{16} \\
%\hline
%
%\textsf{Lock-based skiplist ~\cite{lockskiplist}}& \textsf{500} & \textsf{Michael lock-free set ~\cite{Michael:list}}  & \textsf{178} \\
%\hline
% 
%\textsf{Priority queue skiplist 1 ~\cite{Shavit:ElimQueue}}  &  \textsf{1320} & \textsf{Pessimistic set  ~\cite{ArtOfMpP}}&\textsf{30}\\
%\hline
%
%\textsf{Priority queue skiplist 2~\cite{Linden:opodis13}}  &  \textsf{599} &\textsf{Optimistic set ~\cite{ArtOfMpP}}& \textsf{25}\\
%\hline
%\textsf{Treiber stack  ~\cite{Treiber:stack}} & \textsf {18} & \textsf{Lazy set ~\cite{Lazyset}  }  & \textsf {34}\\
%\hline
%
%\textsf{MS lock-free queue  ~\cite{MS:QueueAlgorithms}}& \textsf{21} & \textsf {O$\textquotesingle $Hearn set  ~\cite{OHearnlist}} & \textsf{88}\\
%\hline
%
%&   & \textsf{HM lock-free set  ~\cite{ArtOfMpP} } & \textsf{120}\\
%


%\textit{\textsf{SLLs}}  & & & \textit{\textsf {SLLs}} &  &  \\

%\hline

\textsf{Treiber stack  ~\cite{Treiber:stack}} & \textsf {18} & \textsf {0.18} & \textsf {O$\textquotesingle $Hearn set  ~\cite{OHearnlist}} & \textsf{88} & \textsf{12} \\
\textsf{MS lock-free queue  ~\cite{MS:QueueAlgorithms}}& \textsf{22} & \textsf {21} & \textsf{HM lock-free set  ~\cite{ArtOfMpP} } & \textsf{120} & \textsf{462} \\
\textsf{DGLM queue  ~\cite{Doherty:lockfree}}&  \textsf {16} & \textsf{16} & \textsf{Harris lock-free set  ~\cite{Harris:list}} & \textsf{950} & \textsf {1512} \\
\textsf{Vechev-CAS set  ~\cite{Vechev:list}}  & \textsf{86} & \textsf {24} & \textsf{Unordered set  ~\cite{Zhang:unorderedlist}} & \textsf{1230} & \textsf {2301} \\
\cline{4-5}
\textsf{Vechev-DCAS set  ~\cite{Vechev:list}}   & \textsf{16} & \textsf{16} & \textsf{TS stack  ~\cite{ts-stack}}  & \textsf{176} &\\
\textsf{Michael lock-free set ~\cite{Michael:list}}  & \textsf{178} & \textsf{110} & \textsf{TS queue  ~\cite{ts-stack}} & \textsf{101} &\\
\cline{4-5}
\textsf{Pessimistic set  ~\cite{ArtOfMpP}}&\textsf{30} & \textsf{1.51} & \textsf{Lock-free skiplist   ~\cite{ArtOfMpP}}& \textsf{1992} & \\
\textsf{Optimistic set ~\cite{ArtOfMpP}}& \textsf{25} & \textsf{60} & \textsf{Lock-based skiplist ~\cite{lockskiplist}}& \textsf{500} & \\
\textsf{Lazy set ~\cite{Lazyset}}  & \textsf {34} & \textsf{289} & \textsf{Priority queue skiplist 1 ~\cite{Shavit:queue}} &\textsf{1320} & \\
& & &\textsf{Priority queue skiplist 2~\cite{Linden:opodis13}}  &  \textsf{599} &\\
\hline
 %% \multicolumn{1}{l}{\textsf{a: Our tool, b:~\cite{Quy:sas16} }} & \multicolumn{1}{l}{}  & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
% \multicolumn{1}{l}{b:~\cite{Quy:sas16}} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} \\
\end{tabular}

%\vspace{10mm}
%\vspace*{-0.3cm}
\caption{Times for verifying concurrent data structure implementations.
Column {\bf a} shows the verification times for our tool based on fragment abstraction.
Column {\bf b} shows the verification times for the tool for SLLs in our previous
work~\protect\cite{Quy:sas16}}
%\vspace*{-0.7cm}
\label{Experiments:fig}
\end{figure}
%\vspace{-0.2cm}
\paragraph{Singly-linked list benchmarks:} These benchmarks include stacks, queues and sets algorithms which are the well-known in the literature. The challenge is that in some set implementation, the linearization points are not fixed, they depended on the future of each execution. The sets with non fixed linearization points are the lazy set ~\cite{Lazyset}, lock-free sets of {\it HM}~\cite{ArtOfMpP}, {\it Harris}~\cite{Harris:list}, {\it Michael}~\cite{Michael:list}, and unordered set of~\cite{Zhang:unorderedlist}. By using observers and controllers in our previous work~\cite{Quy:sas16}. Our approach is simple and strong enough to verify these singly-linked list benchmarks.

%Our previous work handles SLL implementations of concurrent sets by adapting a well-known abstraction of singly-linked lists ~\cite{MYRS:Canonical} for concurrent programs.
%The resulting technique is specifically tailored for singly-links in a slightly ad-hoc way.
%Our fragment abstraction is significantly simpler conceptually, and can therefore be used directly
%also for other classes of heap structures. Our approach of previous work is strong enough to verify  concurrent set
%implementations based on sorted and non-sorted singly-linked lists having non-optimistic contains (or lookup) operations we consider, such as the lock-free sets of {\it HM}~\cite{ArtOfMpP}, {\it Harris}~\cite{Harris:list}, or {\it Michael}~\cite{Michael:list}, or unordered set of~\cite{Zhang:unorderedlist} which have not done automatically before. Our fragment abstraction can handle them as well.

\paragraph{Skiplist benchmarks:} We consider four skiplist algorithms including the lock-based skiplist set~\cite{MS:QueueAlgorithms}, the lock-free skiplist set which is described in section 2~\cite{ArtOfMpP}, and two skiplist-based priority queues~\cite{Linden:opodis13},~\cite{Shavit:queue}. One challenge for verifying these algorithms is to deal with unbounded number of levels. In addition, in the lock-free skiplist~\cite{ArtOfMpP} and priority queue ~\cite{Linden:opodis13}, the skiplist shape is not well formed, it means that each higher level list is not always a sub-list of lower level lists. This makes the verification tasks became extremely difficult, these algorithms have not been formally verified by any previous work. By applying our fragment abstraction,  to the best of our knowledge, we provide first framework which formally verify these concurrent skiplists algorithms. 

\paragraph{Arrays of singly-linked list benchmarks:} We consider two challenging timestamp algorithms in \cite{ts-stack}. There are two challenges problems of verifying these algorithm, the fist challenge is how to deal with unbounded number of SLLs and the second challenge is that the lineatization points of the algorithms are not fixed, but depended on the future of each execution. By combining our fragment abstraction and the observers for stacks and queues in \cite{BEEH:icalp15} and the controllers in~\cite{Quy:sas16} . Our tool is the first one verifing these two algorithms automatically.

\paragraph{Running Times.}The experiments were performed on a desktop 2.8 GHz processor with 8GB memory. The results are presented in Fig.~\ref{Experiments:fig}, where running times are given in seconds. The column \textsf{a} show the running times of our tool, whereas the column \textsf{b} show the running time of algorithms which can be verified by our previous work~\cite{Quy:sas16}.  In our experiments, we run the tool together with observer in \cite{AHHR:integrated}, \cite{BEEH:icalp15} and controller in~\cite{Quy:sas16} to verify linearization properties of the algorithms. All experiments start from the initial heap,  
and end either when the analysis reaches the fixed point or when a violation of safety properties or linearizability is detected. As can be seen from the table, the running times vary in the different examples. This is due to the types of shapes that are produced during the analysis. For instance, skiplist algorithms have much longer running times. This is due to the number of pointer variables and their complicated shapes. Whereas, other algorithms 
produce simple shape patterns and hence they have shorter running times.
\paragraph{Error Detection}
 In addition to establishing correctness of the original versions of the
benchmark algorithms, we tested our tool with intentionally inserted bugs. For example, we emitted setting time statement in line 5 of the ${\tt push}$ method in TS stack algorithm, or we emitted the $\tt CAS$ statements in lock-free algorithms. The tool, as expected, successfully detected and reported the bug. 
 

%
%\paragraph{Helping.}
%The algorithms marked by  \checkmark \; use helping.
%%
%We run  some of the algorithms with two different helping patterns
%(such as the ones described in Sec.~\ref{programs:section}),
%and report the execution time for each.




%\expcloseparagraph{Consistency.}
%In the case of algorithms where the controller
%performs multiple linearizations for the same thread (e.g.,
%the {\tt Lazy Set} algorithm), our prototype checks
%{\it automatically} that
%(i) 
%each thread linearizes at least once during
%its execution, and 
%(ii) the
%last value communicated to the observer is identical to the value $r$
%actually returned by the thread.
%%
%To do that, the prototype adds two extra variables per thread, namely
%a Boolean variable $b$ which records that at least one
% linearization has taken place, and a variable $v$ of type 
%$\intgrs\cup\set{\star}$, for some $\star\not\in\intgrs$,
%where $v$ is initialized to $\star$.
%%
%The variable $v$ records the value that has been communicated to
%the observer by the thread.
%%
%%
%Furthermore, we have to take into account the fact 
%that ``false'' linearization points
%may change the state of the observer.
%%
%Each time the controller performs a linearization,
%it will check if the value of $v$ of is different from $\star$.
%%
%If {\it yes} then the thread has already linearized once and the run 
%of the program is stopped.
%%
%Otherwise, it updates the value of $b$ to {\tt true},
%and then decides either
%to perform a linearization or not.
%%
%In the former case, it updates the value of $v$ 
%to the value communicated to the observer.
%%
%In the latter case, it will not update the value of $v$.
%%
%This will continue, until we reach the {\tt return} statement of the thread.
%%
%We report an error if
%(i) the observer has reached a bad state.
%(ii) $b={\tt false}$ holds, since this means the existence of
%a run long of which the thread never linearizes, or
%(iii) $(b={\tt true})\wedge(v\neq\star)\wedge(v\neq r)$
%holds since this means that we have linearized with the wrong value.
%
%\paragraph{Arrays.}
%Our tool does not currently support arrays, and hence
%we have transformed arrays to singly-linked lists
%in the algorithms that use the former.
%
%\paragraph{Safety Properties.}
%Our tool is also capable of verifying 
% memory related safety properties such as the absence of
%null pointer dereferencing, 
%dangling pointers,  double-freeing, cycles, and
%dereferencing of freed nodes, as well as sortedness.
%%
%%We check these properties for all the algorithms we consider.
%%
%In fact,  for each algorithm,
%the time reported in Fig.~\ref{Experiments:fig} is the sum of the 
%times taken to show linearizability and all the properties mentioned above.
%



\


