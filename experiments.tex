%--------------------------------------------------------
\section{Experimental Results}
\label{section:experiments}
%--------------------------------------------------------
\newcommand{\emm}{(emm)}
%\begin{wrapfigure}{r}[0pt]{0.5\textwidth}
%\vspace{5mm}
\begin{figure}[]
%% \vspace*{-1cm}
\center



\begin{tabular}{|c | c | }
  \hline
   \textsf{{\textbf{Algorithms}}} &  \textsf{{\textbf{Time (s)}}} \\
\hline
\textsf{{\textit{Timestamps}}} & \\
\hline
\textsf{TS stack  ~\cite{MS:QueueAlgorithms}}\;\;\;\;\;\;  & \textsf{76.02} \\
\textsf{TS queue  ~\cite{MS:QueueAlgorithms}}& \textsf{11.07} \\
\hline
 \textsf{{\textit{Skip-lists}}} &   \\
\hline
\;\;\;\;\textsf{Lock-free skip-list   ~\cite{ArtOfMpP}}\;\;\;\;\;\;  & \textsf{1992.32} \\

\textsf{Optimistic skip-list ~\cite{MS:QueueAlgorithms}}& \textsf{500.07} \\
 
\textsf{Priority queue skip-list 1 ~\cite{Shavit:ElimQueue}}  &  \textsf{1320.56} \\

\textsf{Priority queue skip-list 2~\cite{Shavit:ElimQueue}}  &  \textsf{599.56} \\
\hline
   \textsf{{\textit{Singly-linked lists}}} &   \\
\hline
\textsf{Treiber stack  ~\cite{Treiber:stack}}\;\;\;\;\;\; & \textsf {0.18} \\

\textsf{MS lock-free queue  ~\cite{MS:QueueAlgorithms}}& \textsf{21.07} \\

\textsf{DGLM queue  ~\cite{Doherty:lockfree}}&  \textsf {16.99} \\

\textsf{Vechev-CAS set  ~\cite{Vechev:list}}  & \textsf{86.01} \\

\textsf{Vechev-DCAS set  ~\cite{Vechev:list}}   & \textsf{16.02}  \\

\textsf{Michael lock-free set ~\cite{Michael:list}}  & \textsf{178.01}  \\

\textsf{Pessimistic set  ~\cite{ArtOfMpP}}&\textsf{30.51} \\

\textsf{Optimistic set ~\cite{ArtOfMpP}}& \textsf{25.43} \\

\textsf{Lazy set ~\cite{Lazyset}  }  & \textsf {34} \\

\textsf {O$\textquotesingle $Hearn set  ~\cite{OHearnlist}}     & \textsf{88.01} \\

\textsf{HM lock-free set  ~\cite{ArtOfMpP} } & \textsf{120.01} \\
\hline
\end{tabular}

%\vspace{10mm}
%\vspace*{-0.3cm}
\caption{Experimental results for verifying concurrent programs}
%\vspace*{-0.7cm}
\label{Experiments:fig}
\end{figure}
%\vspace{-0.2cm}
\todo{I am working here}
Based on our framework, we have implemented a tool in OCaml, and used
it for
verifying concurrent algorithms (both lock-based and lock-free)
including timestamps stack and queue, skip-list sets and priority queues as well as singly-linked lists algorithms. 
The experiments were performed on a desktop 2.8 GHz processor with 8GB memory. The results are presented in Fig.~\ref{Experiments:fig},
where running times are given in seconds. 
All experiments start from the initial heap,  
and end either when the analysis reaches the fixed point or when a violation of linearizability is detected. 

%
%\paragraph{Helping.}
%The algorithms marked by  \checkmark \; use helping.
%%
%We run  some of the algorithms with two different helping patterns
%(such as the ones described in Sec.~\ref{programs:section}),
%and report the execution time for each.




%\expcloseparagraph{Consistency.}
%In the case of algorithms where the controller
%performs multiple linearizations for the same thread (e.g.,
%the {\tt Lazy Set} algorithm), our prototype checks
%{\it automatically} that
%(i) 
%each thread linearizes at least once during
%its execution, and 
%(ii) the
%last value communicated to the observer is identical to the value $r$
%actually returned by the thread.
%%
%To do that, the prototype adds two extra variables per thread, namely
%a Boolean variable $b$ which records that at least one
% linearization has taken place, and a variable $v$ of type 
%$\intgrs\cup\set{\star}$, for some $\star\not\in\intgrs$,
%where $v$ is initialized to $\star$.
%%
%The variable $v$ records the value that has been communicated to
%the observer by the thread.
%%
%%
%Furthermore, we have to take into account the fact 
%that ``false'' linearization points
%may change the state of the observer.
%%
%Each time the controller performs a linearization,
%it will check if the value of $v$ of is different from $\star$.
%%
%If {\it yes} then the thread has already linearized once and the run 
%of the program is stopped.
%%
%Otherwise, it updates the value of $b$ to {\tt true},
%and then decides either
%to perform a linearization or not.
%%
%In the former case, it updates the value of $v$ 
%to the value communicated to the observer.
%%
%In the latter case, it will not update the value of $v$.
%%
%This will continue, until we reach the {\tt return} statement of the thread.
%%
%We report an error if
%(i) the observer has reached a bad state.
%(ii) $b={\tt false}$ holds, since this means the existence of
%a run long of which the thread never linearizes, or
%(iii) $(b={\tt true})\wedge(v\neq\star)\wedge(v\neq r)$
%holds since this means that we have linearized with the wrong value.
%
%\paragraph{Arrays.}
%Our tool does not currently support arrays, and hence
%we have transformed arrays to singly-linked lists
%in the algorithms that use the former.
%
%\paragraph{Safety Properties.}
%Our tool is also capable of verifying 
% memory related safety properties such as the absence of
%null pointer dereferencing, 
%dangling pointers,  double-freeing, cycles, and
%dereferencing of freed nodes, as well as sortedness.
%%
%%We check these properties for all the algorithms we consider.
%%
%In fact,  for each algorithm,
%the time reported in Fig.~\ref{Experiments:fig} is the sum of the 
%times taken to show linearizability and all the properties mentioned above.
%
\paragraph{Running Times.}
As can be seen from the table, the running times
vary in the different examples.
%
This is due to the types of shapes that are produced during the analysis.
%
For instance, skip-lists algorithm have much longer running times. This is due to 
the number of pointer variables and their complicated shapes. Whereas, stack and queue algorithms 
produce simple shape patterns and hence they have shorter running times.
\paragraph{Error Detection}
 In addition to establishing correctness of the original versions of the
benchmark algorithms, we tested our tool with intentionally inserted bugs. For example, we emitted broadcast messages in the controllers or inserted bugs into the codes of algorithms. In all cases, the tool, as expected, successfully detected and reported the bug. In the {\tt Lazy Set} algorithm, when we emitted rule $\rulename_7$ in Fig. ~\ref{rrules:lazy:list:fig}, the tool reported an error. As another example, when we removed the statement in line 4 of 
the add method in the {\tt Lazy Set} algorithm, the tool also reported an error.
 



